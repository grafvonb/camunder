//go:build ignore
// Package c87camunda provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package c87camunda

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AuthorizationPatchRequestAction.
const (
	ADD    AuthorizationPatchRequestAction = "ADD"
	REMOVE AuthorizationPatchRequestAction = "REMOVE"
)

// Defines values for DocumentReferenceBaseCamundaDocumentType.
const (
	Camunda DocumentReferenceBaseCamundaDocumentType = "camunda"
)

// Defines values for IncidentFilterRequestBaseErrorType.
const (
	IncidentFilterRequestBaseErrorTypeCALLEDDECISIONERROR        IncidentFilterRequestBaseErrorType = "CALLED_DECISION_ERROR"
	IncidentFilterRequestBaseErrorTypeCALLEDELEMENTERROR         IncidentFilterRequestBaseErrorType = "CALLED_ELEMENT_ERROR"
	IncidentFilterRequestBaseErrorTypeCONDITIONERROR             IncidentFilterRequestBaseErrorType = "CONDITION_ERROR"
	IncidentFilterRequestBaseErrorTypeDECISIONEVALUATIONERROR    IncidentFilterRequestBaseErrorType = "DECISION_EVALUATION_ERROR"
	IncidentFilterRequestBaseErrorTypeEXECUTIONLISTENERNORETRIES IncidentFilterRequestBaseErrorType = "EXECUTION_LISTENER_NO_RETRIES"
	IncidentFilterRequestBaseErrorTypeEXTRACTVALUEERROR          IncidentFilterRequestBaseErrorType = "EXTRACT_VALUE_ERROR"
	IncidentFilterRequestBaseErrorTypeFORMNOTFOUND               IncidentFilterRequestBaseErrorType = "FORM_NOT_FOUND"
	IncidentFilterRequestBaseErrorTypeIOMAPPINGERROR             IncidentFilterRequestBaseErrorType = "IO_MAPPING_ERROR"
	IncidentFilterRequestBaseErrorTypeJOBNORETRIES               IncidentFilterRequestBaseErrorType = "JOB_NO_RETRIES"
	IncidentFilterRequestBaseErrorTypeMESSAGESIZEEXCEEDED        IncidentFilterRequestBaseErrorType = "MESSAGE_SIZE_EXCEEDED"
	IncidentFilterRequestBaseErrorTypeRESOURCENOTFOUND           IncidentFilterRequestBaseErrorType = "RESOURCE_NOT_FOUND"
	IncidentFilterRequestBaseErrorTypeUNHANDLEDERROREVENT        IncidentFilterRequestBaseErrorType = "UNHANDLED_ERROR_EVENT"
	IncidentFilterRequestBaseErrorTypeUNKNOWN                    IncidentFilterRequestBaseErrorType = "UNKNOWN"
	IncidentFilterRequestBaseErrorTypeUNSPECIFIED                IncidentFilterRequestBaseErrorType = "UNSPECIFIED"
)

// Defines values for IncidentFilterRequestBaseState.
const (
	IncidentFilterRequestBaseStateACTIVE   IncidentFilterRequestBaseState = "ACTIVE"
	IncidentFilterRequestBaseStateMIGRATED IncidentFilterRequestBaseState = "MIGRATED"
	IncidentFilterRequestBaseStatePENDING  IncidentFilterRequestBaseState = "PENDING"
	IncidentFilterRequestBaseStateRESOLVED IncidentFilterRequestBaseState = "RESOLVED"
)

// Defines values for IncidentItemBaseErrorType.
const (
	IncidentItemBaseErrorTypeCALLEDDECISIONERROR        IncidentItemBaseErrorType = "CALLED_DECISION_ERROR"
	IncidentItemBaseErrorTypeCALLEDELEMENTERROR         IncidentItemBaseErrorType = "CALLED_ELEMENT_ERROR"
	IncidentItemBaseErrorTypeCONDITIONERROR             IncidentItemBaseErrorType = "CONDITION_ERROR"
	IncidentItemBaseErrorTypeDECISIONEVALUATIONERROR    IncidentItemBaseErrorType = "DECISION_EVALUATION_ERROR"
	IncidentItemBaseErrorTypeEXECUTIONLISTENERNORETRIES IncidentItemBaseErrorType = "EXECUTION_LISTENER_NO_RETRIES"
	IncidentItemBaseErrorTypeEXTRACTVALUEERROR          IncidentItemBaseErrorType = "EXTRACT_VALUE_ERROR"
	IncidentItemBaseErrorTypeFORMNOTFOUND               IncidentItemBaseErrorType = "FORM_NOT_FOUND"
	IncidentItemBaseErrorTypeIOMAPPINGERROR             IncidentItemBaseErrorType = "IO_MAPPING_ERROR"
	IncidentItemBaseErrorTypeJOBNORETRIES               IncidentItemBaseErrorType = "JOB_NO_RETRIES"
	IncidentItemBaseErrorTypeMESSAGESIZEEXCEEDED        IncidentItemBaseErrorType = "MESSAGE_SIZE_EXCEEDED"
	IncidentItemBaseErrorTypeRESOURCENOTFOUND           IncidentItemBaseErrorType = "RESOURCE_NOT_FOUND"
	IncidentItemBaseErrorTypeUNHANDLEDERROREVENT        IncidentItemBaseErrorType = "UNHANDLED_ERROR_EVENT"
	IncidentItemBaseErrorTypeUNKNOWN                    IncidentItemBaseErrorType = "UNKNOWN"
	IncidentItemBaseErrorTypeUNSPECIFIED                IncidentItemBaseErrorType = "UNSPECIFIED"
)

// Defines values for IncidentItemBaseState.
const (
	IncidentItemBaseStateACTIVE   IncidentItemBaseState = "ACTIVE"
	IncidentItemBaseStateMIGRATED IncidentItemBaseState = "MIGRATED"
	IncidentItemBaseStatePENDING  IncidentItemBaseState = "PENDING"
	IncidentItemBaseStateRESOLVED IncidentItemBaseState = "RESOLVED"
)

// Defines values for OperationItemState.
const (
	OperationItemStateCOMPLETED OperationItemState = "COMPLETED"
	OperationItemStateFAILED    OperationItemState = "FAILED"
	OperationItemStateLOCKED    OperationItemState = "LOCKED"
	OperationItemStateSCHEDULED OperationItemState = "SCHEDULED"
	OperationItemStateSENT      OperationItemState = "SENT"
)

// Defines values for OperationItemType.
const (
	ADDVARIABLE              OperationItemType = "ADD_VARIABLE"
	CANCELPROCESSINSTANCE    OperationItemType = "CANCEL_PROCESS_INSTANCE"
	DELETEDECISIONDEFINITION OperationItemType = "DELETE_DECISION_DEFINITION"
	DELETEPROCESSDEFINITION  OperationItemType = "DELETE_PROCESS_DEFINITION"
	DELETEPROCESSINSTANCE    OperationItemType = "DELETE_PROCESS_INSTANCE"
	MIGRATEPROCESSINSTANCE   OperationItemType = "MIGRATE_PROCESS_INSTANCE"
	MODIFYPROCESSINSTANCE    OperationItemType = "MODIFY_PROCESS_INSTANCE"
	RESOLVEINCIDENT          OperationItemType = "RESOLVE_INCIDENT"
	UPDATEVARIABLE           OperationItemType = "UPDATE_VARIABLE"
)

// Defines values for PartitionHealth.
const (
	Dead      PartitionHealth = "dead"
	Healthy   PartitionHealth = "healthy"
	Unhealthy PartitionHealth = "unhealthy"
)

// Defines values for PartitionRole.
const (
	Follower PartitionRole = "follower"
	Inactive PartitionRole = "inactive"
	Leader   PartitionRole = "leader"
)

// Defines values for ProcessInstanceItemBaseState.
const (
	ProcessInstanceItemBaseStateACTIVE      ProcessInstanceItemBaseState = "ACTIVE"
	ProcessInstanceItemBaseStateCANCELED    ProcessInstanceItemBaseState = "CANCELED"
	ProcessInstanceItemBaseStateCOMPLETED   ProcessInstanceItemBaseState = "COMPLETED"
	ProcessInstanceItemBaseStateINCIDENT    ProcessInstanceItemBaseState = "INCIDENT"
	ProcessInstanceItemBaseStateUNKNOWN     ProcessInstanceItemBaseState = "UNKNOWN"
	ProcessInstanceItemBaseStateUNSPECIFIED ProcessInstanceItemBaseState = "UNSPECIFIED"
)

// ActivatedJob Base properties for ActivatedJob
type ActivatedJob = ActivatedJobBase

// ActivatedJobBase Base properties for ActivatedJob
type ActivatedJobBase struct {
	// CustomHeaders a set of custom headers defined during modelling; returned as a serialized JSON document
	CustomHeaders *map[string]interface{} `json:"customHeaders,omitempty"`

	// Deadline when the job can be activated again, sent as a UNIX epoch timestamp
	Deadline *int64 `json:"deadline,omitempty"`

	// ElementId the associated task element ID
	ElementId *string `json:"elementId,omitempty"`

	// ProcessDefinitionId the bpmn process ID of the job's process definition
	ProcessDefinitionId *string `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionVersion the version of the job's process definition
	ProcessDefinitionVersion *int32 `json:"processDefinitionVersion,omitempty"`

	// Retries the amount of retries left to this job (should always be positive)
	Retries *int32 `json:"retries,omitempty"`

	// TenantId The ID of the tenant that owns the job
	TenantId *string `json:"tenantId,omitempty"`

	// Type the type of the job (should match what was requested)
	Type *string `json:"type,omitempty"`

	// Variables All variables visible to the task scope, computed at activation time
	Variables *map[string]interface{} `json:"variables,omitempty"`

	// Worker the name of the worker which activated this job
	Worker *string `json:"worker,omitempty"`
}

// ActivatedJobResult Base properties for ActivatedJob
type ActivatedJobResult = ActivatedJobBase

// AuthorizationPatchRequest defines model for AuthorizationPatchRequest.
type AuthorizationPatchRequest struct {
	// Action Indicates if permissions should be added or removed.
	Action *AuthorizationPatchRequestAction `json:"action,omitempty"`

	// Permissions The permissions to add/remove.
	Permissions *[]struct {
		// PermissionType Specifies the type of permissions.
		PermissionType interface{} `json:"permissionType,omitempty"`

		// ResourceIds A list of resource IDs the permission relates to.
		ResourceIds *[]string `json:"resourceIds,omitempty"`
	} `json:"permissions,omitempty"`

	// ResourceType The type of resource to add/remove perissions to/from.
	ResourceType interface{} `json:"resourceType,omitempty"`
}

// AuthorizationPatchRequestAction Indicates if permissions should be added or removed.
type AuthorizationPatchRequestAction string

// BrokerInfo Provides information on a broker node.
type BrokerInfo struct {
	// Host The hostname for reaching the broker.
	Host *string `json:"host,omitempty"`

	// NodeId The unique (within a cluster) node ID for the broker.
	NodeId *int32 `json:"nodeId,omitempty"`

	// Partitions A list of partitions managed or replicated on this broker.
	Partitions *[]Partition `json:"partitions,omitempty"`

	// Port The port for reaching the broker.
	Port *int32 `json:"port,omitempty"`

	// Version The broker version.
	Version *string `json:"version,omitempty"`
}

// CancelProcessInstanceRequest defines model for CancelProcessInstanceRequest.
type CancelProcessInstanceRequest struct {
	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *int64 `json:"operationReference,omitempty"`
}

// Changeset JSON object with changed task attribute values.
//
// The following attributes can be adjusted with this endpoint, additional attributes
// will be ignored:
//
// * `candidateGroups` - reset by providing an empty list
// * `candidateUsers` - reset by providing an empty list
// * `dueDate` - reset by providing an empty String
// * `followUpDate` - reset by providing an empty String
// * `priority` - minimum 0, maximum 100, default 50
//
// Providing any of those attributes with a `null` value or omitting it preserves
// the persisted attribute's value.
//
// The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
// This ensures correct event emission for assignee changes.
type Changeset struct {
	// CandidateGroups The list of candidate groups of the task. Reset by providing an empty list.
	CandidateGroups nullable.Nullable[[]string] `json:"candidateGroups,omitempty"`

	// CandidateUsers The list of candidate users of the task. Reset by providing an empty list.
	CandidateUsers nullable.Nullable[[]string] `json:"candidateUsers,omitempty"`

	// DueDate The due date of the task. Reset by providing an empty String.
	DueDate nullable.Nullable[time.Time] `json:"dueDate,omitempty"`

	// FollowUpDate The follow-up date of the task. Reset by providing an empty String.
	FollowUpDate nullable.Nullable[time.Time] `json:"followUpDate,omitempty"`

	// Priority The priority of the task.
	Priority             nullable.Nullable[int32] `json:"priority,omitempty"`
	AdditionalProperties map[string]interface{}   `json:"-"`
}

// ClockPinRequest defines model for ClockPinRequest.
type ClockPinRequest struct {
	// Timestamp The exact time in epoch milliseconds to which the clock should be pinned.
	Timestamp int64 `json:"timestamp"`
}

// CreateProcessInstanceRequest Base properties for CreateProcessInstanceRequest
type CreateProcessInstanceRequest = CreateProcessInstanceRequestBase

// CreateProcessInstanceRequestBase Base properties for CreateProcessInstanceRequest
type CreateProcessInstanceRequestBase struct {
	// AwaitCompletion Wait for the process instance to complete. If the process instance completion does
	// not occur within the requestTimeout, the request will be closed. This can lead to a 504
	// response status. Disabled by default.
	AwaitCompletion *bool `json:"awaitCompletion,omitempty"`

	// FetchVariables List of variables names to be included in the response.
	// If empty, all visible variables in the root scope will be returned.
	FetchVariables *[]string `json:"fetchVariables,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be >0 if provided.
	OperationReference *int64 `json:"operationReference,omitempty"`

	// ProcessDefinitionId The BPMN process ID of the process definition to start an instance of.
	// Cannot be used together with processDefinitionKey.
	ProcessDefinitionId *string `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionVersion The version of the process. Only considered when a processDefinitionId is provided.
	// By default, the latest version of the process is used.
	ProcessDefinitionVersion *int32 `json:"processDefinitionVersion,omitempty"`

	// RequestTimeout Timeout (in ms) the request waits for the process to complete. By default or
	// when set to 0, the generic request timeout configured in the cluster is applied.
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`

	// StartInstructions List of start instructions. By default, the process instance will start at
	// the start event. If provided, the process instance will apply start instructions
	// after it has been created.
	StartInstructions *[]ProcessInstanceCreationStartInstruction `json:"startInstructions,omitempty"`

	// TenantId The tenant ID of the process definition.
	TenantId *string `json:"tenantId,omitempty"`

	// Variables JSON object that will instantiate the variables for the root variable scope
	// of the process instance.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// CreateProcessInstanceResponse Base properties for CreateProcessInstanceResponse
type CreateProcessInstanceResponse = CreateProcessInstanceResponseBase

// CreateProcessInstanceResponseBase Base properties for CreateProcessInstanceResponse
type CreateProcessInstanceResponseBase struct {
	// ProcessDefinitionId The BPMN process ID of the process definition which was used to create the process.
	// instance
	ProcessDefinitionId *string `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionVersion The version of the process definition which was used to create the process instance.
	ProcessDefinitionVersion *int32 `json:"processDefinitionVersion,omitempty"`

	// TenantId The tenant ID of the created process instance.
	TenantId *string `json:"tenantId,omitempty"`

	// Variables All the variables visible in the root scope.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// CreateProcessInstanceResult Base properties for CreateProcessInstanceResponse
type CreateProcessInstanceResult = CreateProcessInstanceResponseBase

// DecisionDefinitionFilter Base properties for DecisionDefinitionFilterRequest
type DecisionDefinitionFilter = DecisionDefinitionFilterRequestBase

// DecisionDefinitionFilterRequest Base properties for DecisionDefinitionFilterRequest
type DecisionDefinitionFilterRequest = DecisionDefinitionFilterRequestBase

// DecisionDefinitionFilterRequestBase Base properties for DecisionDefinitionFilterRequest
type DecisionDefinitionFilterRequestBase struct {
	// DecisionDefinitionId The DMN id of the decision definition.
	DecisionDefinitionId *string `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionName The DMN name of the decision definition.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionRequirementsId the DMN id of the decision requirements graph that the decision definition is part of.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// TenantId The tenant id of the decision definition.
	TenantId *string `json:"tenantId,omitempty"`

	// Version The assigned version of the decision definition.
	Version *int32 `json:"version,omitempty"`
}

// DecisionDefinitionItem Base properties for DecisionDefinitionItem
type DecisionDefinitionItem = DecisionDefinitionItemBase

// DecisionDefinitionItemBase Base properties for DecisionDefinitionItem
type DecisionDefinitionItemBase struct {
	// DecisionDefinitionId The DMN id of the decision definition.
	DecisionDefinitionId *string `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionName The DMN name of the decision definition.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionRequirementsId the DMN id of the decision requirements graph that the decision definition is part of.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// TenantId The tenant id of the decision definition.
	TenantId *string `json:"tenantId,omitempty"`

	// Version The assigned version of the decision definition.
	Version *int32 `json:"version,omitempty"`
}

// DecisionDefinitionResult Base properties for DecisionDefinitionItem
type DecisionDefinitionResult = DecisionDefinitionItemBase

// DecisionDefinitionSearchQuery defines model for DecisionDefinitionSearchQuery.
type DecisionDefinitionSearchQuery = SearchQueryRequest

// DecisionDefinitionSearchQueryRequest defines model for DecisionDefinitionSearchQueryRequest.
type DecisionDefinitionSearchQueryRequest = SearchQueryRequest

// DecisionDefinitionSearchQueryResponse defines model for DecisionDefinitionSearchQueryResponse.
type DecisionDefinitionSearchQueryResponse = SearchQueryResponse

// DecisionDefinitionSearchQueryResult defines model for DecisionDefinitionSearchQueryResult.
type DecisionDefinitionSearchQueryResult = SearchQueryResponse

// DecisionEvaluationInstruction Base properties for EvaluateDecisionRequest
type DecisionEvaluationInstruction = EvaluateDecisionRequestBase

// DecisionInstanceFilter Base properties for DecisionInstanceFilterRequest
type DecisionInstanceFilter = DecisionInstanceFilterRequestBase

// DecisionInstanceFilterRequest Base properties for DecisionInstanceFilterRequest
type DecisionInstanceFilterRequest = DecisionInstanceFilterRequestBase

// DecisionInstanceFilterRequestBase Base properties for DecisionInstanceFilterRequest
type DecisionInstanceFilterRequestBase struct {
	// DecisionDefinitionId The ID of the DMN decision.
	DecisionDefinitionId *string `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionName The name of the DMN decision.
	DecisionDefinitionName *string                   `json:"decisionDefinitionName,omitempty"`
	DecisionDefinitionType *DecisionInstanceTypeEnum `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// EvaluationFailure The evaluation failure of the decision instance.
	EvaluationFailure *string                    `json:"evaluationFailure,omitempty"`
	State             *DecisionInstanceStateEnum `json:"state,omitempty"`

	// TenantId The tenant ID of the decision instance.
	TenantId *string `json:"tenantId,omitempty"`
}

// DecisionInstanceItem Base properties for DecisionInstanceItem
type DecisionInstanceItem = DecisionInstanceItemBase

// DecisionInstanceItemBase Base properties for DecisionInstanceItem
type DecisionInstanceItemBase struct {
	// DecisionDefinitionId The ID of the DMN decision.
	DecisionDefinitionId *string `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionName The name of the DMN decision.
	DecisionDefinitionName *string                   `json:"decisionDefinitionName,omitempty"`
	DecisionDefinitionType *DecisionInstanceTypeEnum `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// EvaluationDate The evaluation date of the decision instance.
	EvaluationDate *time.Time `json:"evaluationDate,omitempty"`

	// EvaluationFailure The evaluation failure of the decision instance.
	EvaluationFailure *string `json:"evaluationFailure,omitempty"`

	// Result The result of the decision instance.
	Result *string                    `json:"result,omitempty"`
	State  *DecisionInstanceStateEnum `json:"state,omitempty"`

	// TenantId The tenant ID of the decision instance.
	TenantId *string `json:"tenantId,omitempty"`
}

// DecisionInstanceResult Base properties for DecisionInstanceItem
type DecisionInstanceResult = DecisionInstanceItemBase

// DecisionInstanceSearchQuery defines model for DecisionInstanceSearchQuery.
type DecisionInstanceSearchQuery = SearchQueryRequest

// DecisionInstanceSearchQueryRequest defines model for DecisionInstanceSearchQueryRequest.
type DecisionInstanceSearchQueryRequest = SearchQueryRequest

// DecisionInstanceSearchQueryResponse defines model for DecisionInstanceSearchQueryResponse.
type DecisionInstanceSearchQueryResponse = SearchQueryResponse

// DecisionInstanceSearchQueryResult defines model for DecisionInstanceSearchQueryResult.
type DecisionInstanceSearchQueryResult = SearchQueryResponse

// DecisionInstanceStateEnum defines model for DecisionInstanceStateEnum.
type DecisionInstanceStateEnum = interface{}

// DecisionInstanceTypeEnum defines model for DecisionInstanceTypeEnum.
type DecisionInstanceTypeEnum = interface{}

// DecisionRequirementsFilter Base properties for DecisionRequirementsFilterRequest
type DecisionRequirementsFilter = DecisionRequirementsFilterRequestBase

// DecisionRequirementsFilterRequest Base properties for DecisionRequirementsFilterRequest
type DecisionRequirementsFilterRequest = DecisionRequirementsFilterRequestBase

// DecisionRequirementsFilterRequestBase Base properties for DecisionRequirementsFilterRequest
type DecisionRequirementsFilterRequestBase struct {
	// DecisionRequirementsId the DMN id of the decision requirements.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsName The DMN name of the decision requirements.
	DecisionRequirementsName *string `json:"decisionRequirementsName,omitempty"`

	// TenantId The tenant ID of the decision requirements.
	TenantId *string `json:"tenantId,omitempty"`

	// Version The assigned version of the decision requirements.
	Version *int32 `json:"version,omitempty"`
}

// DecisionRequirementsItem Base properties for DecisionRequirementsItem
type DecisionRequirementsItem = DecisionRequirementsItemBase

// DecisionRequirementsItemBase Base properties for DecisionRequirementsItem
type DecisionRequirementsItemBase struct {
	// DecisionRequirementsId the DMN id of the decision requirements.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsName The DMN name of the decision requirements.
	DecisionRequirementsName *string `json:"decisionRequirementsName,omitempty"`

	// ResourceName The name of the resource from which this decision requirements was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The tenant ID of the decision requirements.
	TenantId *string `json:"tenantId,omitempty"`

	// Version The assigned version of the decision requirements.
	Version *int32 `json:"version,omitempty"`
}

// DecisionRequirementsResult Base properties for DecisionRequirementsItem
type DecisionRequirementsResult = DecisionRequirementsItemBase

// DecisionRequirementsSearchQuery defines model for DecisionRequirementsSearchQuery.
type DecisionRequirementsSearchQuery = SearchQueryRequest

// DecisionRequirementsSearchQueryRequest defines model for DecisionRequirementsSearchQueryRequest.
type DecisionRequirementsSearchQueryRequest = SearchQueryRequest

// DecisionRequirementsSearchQueryResponse defines model for DecisionRequirementsSearchQueryResponse.
type DecisionRequirementsSearchQueryResponse = SearchQueryResponse

// DecisionRequirementsSearchQueryResult defines model for DecisionRequirementsSearchQueryResult.
type DecisionRequirementsSearchQueryResult = SearchQueryResponse

// DeleteResourceRequest defines model for DeleteResourceRequest.
type DeleteResourceRequest struct {
	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *int64 `json:"operationReference,omitempty"`
}

// DeploymentDecision Base properties for DeploymentDecision.
type DeploymentDecision = DeploymentDecisionBase

// DeploymentDecisionBase Base properties for DeploymentDecision.
type DeploymentDecisionBase struct {
	// DecisionDefinitionId The dmn decision ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific decision.
	DecisionDefinitionId *string `json:"decisionDefinitionId,omitempty"`

	// DecisionRequirementsId The dmn ID of the decision requirements graph that this decision is part of, as parsed during deployment.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// Name The DMN name of the decision, as parsed during deployment.
	Name *string `json:"name,omitempty"`

	// TenantId The tenant ID of the deployed decision.
	TenantId *string `json:"tenantId,omitempty"`

	// Version The assigned decision version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentDecisionRequirements Base properties for DeploymentDecisionRequirements.
type DeploymentDecisionRequirements = DeploymentDecisionRequirementsBase

// DeploymentDecisionRequirementsBase Base properties for DeploymentDecisionRequirements.
type DeploymentDecisionRequirementsBase struct {
	// DecisionRequirementsId The dmn decision requirements ID, as parsed during deployment; together with the versions forms a unique identifier for a specific decision.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsName The DMN name of the decision requirements, as parsed during deployment.
	DecisionRequirementsName *string `json:"decisionRequirementsName,omitempty"`

	// ResourceName The resource name from which this decision requirements was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The tenant ID of the deployed decision requirements.
	TenantId *string `json:"tenantId,omitempty"`

	// Version The assigned decision requirements version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentDecisionRequirementsResult Base properties for DeploymentDecisionRequirements.
type DeploymentDecisionRequirementsResult = DeploymentDecisionRequirementsBase

// DeploymentDecisionResult Base properties for DeploymentDecision.
type DeploymentDecisionResult = DeploymentDecisionBase

// DeploymentForm Base properties for DeploymentForm.
type DeploymentForm = DeploymentFormBase

// DeploymentFormBase Base properties for DeploymentForm.
type DeploymentFormBase struct {
	// FormId The form ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific form.
	FormId *string `json:"formId,omitempty"`

	// ResourceName The resource name from which this form was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The tenant ID of the deployed form.
	TenantId *string `json:"tenantId,omitempty"`

	// Version The assigned form version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentFormResult Base properties for DeploymentForm.
type DeploymentFormResult = DeploymentFormBase

// DeploymentMetadata defines model for DeploymentMetadata.
type DeploymentMetadata struct {
	// DecisionDefinition A deployed decision.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	DecisionDefinition *DeploymentDecision `json:"decisionDefinition,omitempty"`

	// DecisionRequirements Deployed decision requirements.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	DecisionRequirements *DeploymentDecisionRequirements `json:"decisionRequirements,omitempty"`

	// Form A deployed form.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Form *DeploymentForm `json:"form,omitempty"`

	// ProcessDefinition A deployed process.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	ProcessDefinition *DeploymentProcess `json:"processDefinition,omitempty"`

	// Resource A deployed Resource.
	Resource *DeploymentResource `json:"resource,omitempty"`
}

// DeploymentMetadataResult defines model for DeploymentMetadataResult.
type DeploymentMetadataResult struct {
	// DecisionDefinition A deployed decision.
	DecisionDefinition *DeploymentDecisionResult `json:"decisionDefinition,omitempty"`

	// DecisionRequirements Deployed decision requirements.
	DecisionRequirements *DeploymentDecisionRequirementsResult `json:"decisionRequirements,omitempty"`

	// Form A deployed form.
	Form *DeploymentFormResult `json:"form,omitempty"`

	// ProcessDefinition A deployed process.
	ProcessDefinition *DeploymentProcessResult `json:"processDefinition,omitempty"`

	// Resource A deployed Resource.
	Resource *DeploymentResourceResult `json:"resource,omitempty"`
}

// DeploymentProcess Base properties for DeploymentProcess.
type DeploymentProcess = DeploymentProcessBase

// DeploymentProcessBase Base properties for DeploymentProcess.
type DeploymentProcessBase struct {
	// ProcessDefinitionId The bpmn process ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific process definition.
	ProcessDefinitionId *string `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionVersion The assigned process version.
	ProcessDefinitionVersion *int32 `json:"processDefinitionVersion,omitempty"`

	// ResourceName The resource name from which this process was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The tenant ID of the deployed process.
	TenantId *string `json:"tenantId,omitempty"`
}

// DeploymentProcessResult Base properties for DeploymentProcess.
type DeploymentProcessResult = DeploymentProcessBase

// DeploymentResource Base properties for DeploymentResource.
type DeploymentResource = DeploymentResourceBase

// DeploymentResourceBase Base properties for DeploymentResource.
type DeploymentResourceBase struct {
	// ResourceId The resource ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific form.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceName The resource name from which this resource was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The tenant ID of the deployed form.
	TenantId *string `json:"tenantId,omitempty"`

	// Version The assigned resource version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentResourceResult Base properties for DeploymentResource.
type DeploymentResourceResult = DeploymentResourceBase

// DeploymentResponse Base properties for DeploymentResponse
type DeploymentResponse = DeploymentResponseBase

// DeploymentResponseBase Base properties for DeploymentResponse
type DeploymentResponseBase struct {
	TenantId *string `json:"tenantId,omitempty"`
}

// DeploymentResult Base properties for DeploymentResponse
type DeploymentResult = DeploymentResponseBase

// DocumentCreationBatchResponse defines model for DocumentCreationBatchResponse.
type DocumentCreationBatchResponse = DocumentCreationBatchResponseBase

// DocumentCreationBatchResponseBase defines model for DocumentCreationBatchResponseBase.
type DocumentCreationBatchResponseBase struct {
	// FailedDocuments Documents that failed creation.
	FailedDocuments *[]DocumentCreationFailureDetail `json:"failedDocuments,omitempty"`
}

// DocumentCreationBatchResult defines model for DocumentCreationBatchResult.
type DocumentCreationBatchResult = DocumentCreationBatchResponseBase

// DocumentCreationFailureDetail defines model for DocumentCreationFailureDetail.
type DocumentCreationFailureDetail struct {
	// Detail The detail of the failure.
	Detail *string `json:"detail,omitempty"`

	// FileName The name of the file.
	FileName *string `json:"fileName,omitempty"`
}

// DocumentDetails Information about the document.
type DocumentDetails = DocumentMetadataBase

// DocumentLink defines model for DocumentLink.
type DocumentLink struct {
	// ExpiresAt The date and time when the link expires.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Url The link to the document.
	Url *string `json:"url,omitempty"`
}

// DocumentLinkRequest defines model for DocumentLinkRequest.
type DocumentLinkRequest struct {
	// TimeToLive The time-to-live of the document link in ms.
	TimeToLive *int64 `json:"timeToLive,omitempty"`
}

// DocumentMetadata Information about the document.
type DocumentMetadata = DocumentMetadataBase

// DocumentMetadataBase Information about the document.
type DocumentMetadataBase struct {
	// ContentType The content type of the document.
	ContentType *string `json:"contentType,omitempty"`

	// CustomProperties Custom properties of the document.
	CustomProperties *map[string]interface{} `json:"customProperties,omitempty"`

	// ExpiresAt The date and time when the document expires.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// FileName The name of the file.
	FileName *string `json:"fileName,omitempty"`

	// ProcessDefinitionId The ID of the process definition that created the document.
	ProcessDefinitionId *string `json:"processDefinitionId,omitempty"`

	// Size The size of the document in bytes.
	Size *int64 `json:"size,omitempty"`
}

// DocumentReference defines model for DocumentReference.
type DocumentReference = DocumentReferenceBase

// DocumentReferenceBase defines model for DocumentReferenceBase.
type DocumentReferenceBase struct {
	// CamundaDocumentType Document discriminator. Always set to "camunda".
	CamundaDocumentType *DocumentReferenceBaseCamundaDocumentType `json:"camunda.document.type,omitempty"`

	// ContentHash The hash of the document.
	ContentHash *string `json:"contentHash,omitempty"`

	// DocumentId The ID of the document.
	DocumentId *string `json:"documentId,omitempty"`

	// StoreId The ID of the document store.
	StoreId *string `json:"storeId,omitempty"`
}

// DocumentReferenceBaseCamundaDocumentType Document discriminator. Always set to "camunda".
type DocumentReferenceBaseCamundaDocumentType string

// DocumentReferenceResult defines model for DocumentReferenceResult.
type DocumentReferenceResult = DocumentReferenceBase

// EvaluateDecisionRequest Base properties for EvaluateDecisionRequest
type EvaluateDecisionRequest = EvaluateDecisionRequestBase

// EvaluateDecisionRequestBase Base properties for EvaluateDecisionRequest
type EvaluateDecisionRequestBase struct {
	// DecisionDefinitionId The ID of the decision to be evaluated.
	// Cannot be used together with decisionDefinitionKey. When using the decision ID, the latest
	// deployed version of the decision is used.
	DecisionDefinitionId *string `json:"decisionDefinitionId,omitempty"`

	// TenantId The tenant ID of the decision.
	TenantId *string `json:"tenantId,omitempty"`

	// Variables The message variables as JSON document.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// EvaluateDecisionResponse Base properties for EvaluateDecisionResponse
type EvaluateDecisionResponse = EvaluateDecisionResponseBase

// EvaluateDecisionResponseBase Base properties for EvaluateDecisionResponse
type EvaluateDecisionResponseBase struct {
	// DecisionDefinitionId The ID of the decision which was evaluated.
	DecisionDefinitionId *string `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionName The name of the decision which was evaluated.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionVersion The version of the decision which was evaluated.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// DecisionRequirementsId The ID of the decision requirements graph that the decision which was evaluated is part of.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// FailedDecisionDefinitionId The ID of the decision which failed during evaluation.
	FailedDecisionDefinitionId *string `json:"failedDecisionDefinitionId,omitempty"`

	// FailureMessage Message describing why the decision which was evaluated failed.
	FailureMessage *string `json:"failureMessage,omitempty"`

	// Output JSON document that will instantiate the result of the decision which was evaluated.
	Output *string `json:"output,omitempty"`

	// TenantId The tenant ID of the evaluated decision.
	TenantId *string `json:"tenantId,omitempty"`
}

// EvaluateDecisionResult Base properties for EvaluateDecisionResponse
type EvaluateDecisionResult = EvaluateDecisionResponseBase

// EvaluatedDecisionInputItem The decision inputs that were evaluated within this decision evaluation.
type EvaluatedDecisionInputItem struct {
	// InputId The ID of the evaluated decision input.
	InputId *string `json:"inputId,omitempty"`

	// InputName The name of the evaluated decision input.
	InputName *string `json:"inputName,omitempty"`

	// InputValue The value of the evaluated decision input.
	InputValue *string `json:"inputValue,omitempty"`
}

// EvaluatedDecisionItem Base properties for EvaluatedDecisionItem
type EvaluatedDecisionItem = EvaluatedDecisionItemBase

// EvaluatedDecisionItemBase Base properties for EvaluatedDecisionItem
type EvaluatedDecisionItemBase struct {
	// DecisionDefinitionId The ID of the decision which was evaluated.
	DecisionDefinitionId *string `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionName The name of the decision which was evaluated.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionType The type of the decision which was evaluated.
	DecisionDefinitionType *string `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision which was evaluated.
	DecisionDefinitionVersion *int32                        `json:"decisionDefinitionVersion,omitempty"`
	EvaluatedInputs           *[]EvaluatedDecisionInputItem `json:"evaluatedInputs,omitempty"`
	MatchedRules              *[]MatchedDecisionRuleItem    `json:"matchedRules,omitempty"`

	// Output JSON document that will instantiate the result of the decision which was evaluated.
	Output *string `json:"output,omitempty"`

	// TenantId The tenant ID of the evaluated decision.
	TenantId *string `json:"tenantId,omitempty"`
}

// EvaluatedDecisionOutputItem The evaluated decision outputs.
type EvaluatedDecisionOutputItem struct {
	// OutputId The ID of the evaluated decision output.
	OutputId *string `json:"outputId,omitempty"`

	// OutputName The name of the evaluated decision output.
	OutputName *string `json:"outputName,omitempty"`

	// OutputValue The value of the evaluated decision output.
	OutputValue *string `json:"outputValue,omitempty"`
}

// EvaluatedDecisionResult Base properties for EvaluatedDecisionItem
type EvaluatedDecisionResult = EvaluatedDecisionItemBase

// FlowNodeInstanceFilter Base properties for FlowNodeInstanceFilterRequest
type FlowNodeInstanceFilter = FlowNodeInstanceFilterRequestBase

// FlowNodeInstanceFilterRequest Base properties for FlowNodeInstanceFilterRequest
type FlowNodeInstanceFilterRequest = FlowNodeInstanceFilterRequestBase

// FlowNodeInstanceFilterRequestBase Base properties for FlowNodeInstanceFilterRequest
type FlowNodeInstanceFilterRequestBase struct {
	// FlowNodeId The flow node id
	FlowNodeId *string `json:"flowNodeId,omitempty"`

	// FlowNodeName The flow node name
	FlowNodeName *string `json:"flowNodeName,omitempty"`

	// Incident Shows whether this flow node instance has an incident related to
	Incident *bool `json:"incident,omitempty"`

	// State The state, one of ACTIVE, COMPLETED, TERMINATED.
	State *string `json:"state,omitempty"`

	// TenantId The tenant id
	TenantId *string `json:"tenantId,omitempty"`

	// TreePath The path of keys from process instance to this flow node instance separated by '/'
	TreePath *string `json:"treePath,omitempty"`

	// Type The flow node type
	Type *string `json:"type,omitempty"`
}

// FlowNodeInstanceItem Base properties for FlowNodeInstanceItem
type FlowNodeInstanceItem = FlowNodeInstanceItemBase

// FlowNodeInstanceItemBase Base properties for FlowNodeInstanceItem
type FlowNodeInstanceItemBase struct {
	EndDate      *string `json:"endDate,omitempty"`
	FlowNodeId   *string `json:"flowNodeId,omitempty"`
	FlowNodeName *string `json:"flowNodeName,omitempty"`
	Incident     *bool   `json:"incident,omitempty"`
	StartDate    *string `json:"startDate,omitempty"`
	State        *string `json:"state,omitempty"`
	TenantId     *string `json:"tenantId,omitempty"`
	TreePath     *string `json:"treePath,omitempty"`
	Type         *string `json:"type,omitempty"`
}

// FlowNodeInstanceResult Base properties for FlowNodeInstanceItem
type FlowNodeInstanceResult = FlowNodeInstanceItemBase

// FlowNodeInstanceSearchQuery defines model for FlowNodeInstanceSearchQuery.
type FlowNodeInstanceSearchQuery = SearchQueryRequest

// FlowNodeInstanceSearchQueryRequest defines model for FlowNodeInstanceSearchQueryRequest.
type FlowNodeInstanceSearchQueryRequest = SearchQueryRequest

// FlowNodeInstanceSearchQueryResponse defines model for FlowNodeInstanceSearchQueryResponse.
type FlowNodeInstanceSearchQueryResponse = SearchQueryResponse

// FlowNodeInstanceSearchQueryResult defines model for FlowNodeInstanceSearchQueryResult.
type FlowNodeInstanceSearchQueryResult = SearchQueryResponse

// IncidentFilter Base properties for IncidentFilterRequest
type IncidentFilter = IncidentFilterRequestBase

// IncidentFilterRequest Base properties for IncidentFilterRequest
type IncidentFilterRequest = IncidentFilterRequestBase

// IncidentFilterRequestBase Base properties for IncidentFilterRequest
type IncidentFilterRequestBase struct {
	// CreationTime Date of incident creation.
	CreationTime *time.Time `json:"creationTime,omitempty"`

	// ErrorMessage Error message which describes the error in more detail.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// ErrorType Incident error type with a defined set of values.
	ErrorType *IncidentFilterRequestBaseErrorType `json:"errorType,omitempty"`

	// FlowNodeId The flow node id associated to this incident.
	FlowNodeId *string `json:"flowNodeId,omitempty"`

	// ProcessDefinitionId The bpmn process id associated to this incident.
	ProcessDefinitionId *string `json:"processDefinitionId,omitempty"`

	// State State of this incident with a defined set of values.
	State *IncidentFilterRequestBaseState `json:"state,omitempty"`

	// TenantId The tenant id of the incident.
	TenantId *string `json:"tenantId,omitempty"`

	// TreePath The path from process instance via flow node ids and flow node instance keys leading to this incident.
	TreePath *string `json:"treePath,omitempty"`
}

// IncidentFilterRequestBaseErrorType Incident error type with a defined set of values.
type IncidentFilterRequestBaseErrorType string

// IncidentFilterRequestBaseState State of this incident with a defined set of values.
type IncidentFilterRequestBaseState string

// IncidentItem Base properties for IncidentItem
type IncidentItem = IncidentItemBase

// IncidentItemBase Base properties for IncidentItem
type IncidentItemBase struct {
	// CreationTime Date of incident creation.
	CreationTime *time.Time `json:"creationTime,omitempty"`

	// ErrorMessage Error message which describes the error in more detail.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// ErrorType Incident error type with a defined set of values.
	ErrorType *IncidentItemBaseErrorType `json:"errorType,omitempty"`

	// FlowNodeId The flow node id associated to this incident.
	FlowNodeId *string `json:"flowNodeId,omitempty"`

	// ProcessDefinitionId The bpmn process id associated to this incident.
	ProcessDefinitionId *string `json:"processDefinitionId,omitempty"`

	// State State of this incident with a defined set of values.
	State *IncidentItemBaseState `json:"state,omitempty"`

	// TenantId The tenant id of the incident.
	TenantId *string `json:"tenantId,omitempty"`

	// TreePath The path from process instance via flow node ids and flow node instance keys leading to this incident.
	TreePath *string `json:"treePath,omitempty"`
}

// IncidentItemBaseErrorType Incident error type with a defined set of values.
type IncidentItemBaseErrorType string

// IncidentItemBaseState State of this incident with a defined set of values.
type IncidentItemBaseState string

// IncidentResult Base properties for IncidentItem
type IncidentResult = IncidentItemBase

// IncidentSearchQuery defines model for IncidentSearchQuery.
type IncidentSearchQuery = SearchQueryRequest

// IncidentSearchQueryRequest defines model for IncidentSearchQueryRequest.
type IncidentSearchQueryRequest = SearchQueryRequest

// IncidentSearchQueryResponse defines model for IncidentSearchQueryResponse.
type IncidentSearchQueryResponse = SearchQueryResponse

// IncidentSearchQueryResult defines model for IncidentSearchQueryResult.
type IncidentSearchQueryResult = SearchQueryResponse

// JobActivationRequest defines model for JobActivationRequest.
type JobActivationRequest struct {
	// FetchVariable a list of variables to fetch as the job variables; if empty, all visible variables at the time of activation for the scope of the job will be returned
	FetchVariable nullable.Nullable[[]string] `json:"fetchVariable,omitempty"`

	// MaxJobsToActivate the maximum jobs to activate by this request
	MaxJobsToActivate int32 `json:"maxJobsToActivate"`

	// RequestTimeout The request will be completed when at least one job is activated or after the requestTimeout (in ms). If the requestTimeout = 0, a default timeout is used. If the requestTimeout < 0, long polling is disabled and the request is completed immediately, even when no job is activated.
	RequestTimeout nullable.Nullable[int64] `json:"requestTimeout,omitempty"`

	// TenantIds a list of IDs of tenants for which to activate jobs
	TenantIds nullable.Nullable[[]string] `json:"tenantIds,omitempty"`

	// Timeout a job returned after this call will not be activated by another call until the timeout (in ms) has been reached
	Timeout int64 `json:"timeout"`

	// Type the job type, as defined in the BPMN process (e.g. <zeebe:taskDefinition type="payment-service" />)
	Type string `json:"type"`

	// Worker the name of the worker activating the jobs, mostly used for logging purposes
	Worker nullable.Nullable[string] `json:"worker,omitempty"`
}

// JobActivationResponse Base properties for JobActivationResponse
type JobActivationResponse = JobActivationResponseBase

// JobActivationResponseBase Base properties for JobActivationResponse
type JobActivationResponseBase = map[string]interface{}

// JobActivationResult Base properties for JobActivationResponse
type JobActivationResult = JobActivationResponseBase

// JobChangeset JSON object with changed job attribute values.
//
// The following attributes can be adjusted with this endpoint, additional attributes
// will be ignored:
//
// * `retries` - The new amount of retries for the job; must be a positive number.
// * `timeout` - The duration of the new timeout in ms, starting from the current moment.
//
// Providing any of those attributes with a null value or omitting it preserves the persisted attributeâ€™s value.
//
// The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
type JobChangeset struct {
	// Retries The new amount of retries for the job; must be a positive number.
	Retries nullable.Nullable[int32] `json:"retries,omitempty"`

	// Timeout The duration of the new timeout in ms, starting from the current moment.
	Timeout nullable.Nullable[int64] `json:"timeout,omitempty"`
}

// JobCompletionRequest defines model for JobCompletionRequest.
type JobCompletionRequest struct {
	// Variables The variables to complete the job with.
	Variables nullable.Nullable[map[string]interface{}] `json:"variables,omitempty"`
}

// JobErrorRequest defines model for JobErrorRequest.
type JobErrorRequest struct {
	// ErrorCode The error code that will be matched with an error catch event.
	ErrorCode string `json:"errorCode"`

	// ErrorMessage An error message that provides additional context.
	ErrorMessage nullable.Nullable[string] `json:"errorMessage,omitempty"`

	// Variables JSON object that will instantiate the variables at the local scope of the error catch event that catches the thrown error.
	Variables nullable.Nullable[map[string]interface{}] `json:"variables,omitempty"`
}

// JobFailRequest defines model for JobFailRequest.
type JobFailRequest struct {
	// ErrorMessage An optional message describing why the job failed. This is particularly useful if a job runs out of retries and an incident is raised, as this message can help explain why an incident was raised.
	ErrorMessage nullable.Nullable[string] `json:"errorMessage,omitempty"`

	// Retries The amount of retries the job should have left
	Retries *int32 `json:"retries,omitempty"`

	// RetryBackOff The backoff timeout (in ms) for the next retry.
	RetryBackOff *int64 `json:"retryBackOff,omitempty"`

	// Variables JSON object that will instantiate the variables at the local scope of the job's associated task.
	Variables nullable.Nullable[map[string]interface{}] `json:"variables,omitempty"`
}

// JobUpdateRequest defines model for JobUpdateRequest.
type JobUpdateRequest struct {
	// Changeset JSON object with changed job attribute values.
	//
	// The following attributes can be adjusted with this endpoint, additional attributes
	// will be ignored:
	//
	// * `retries` - The new amount of retries for the job; must be a positive number.
	// * `timeout` - The duration of the new timeout in ms, starting from the current moment.
	//
	// Providing any of those attributes with a null value or omitting it preserves the persisted attributeâ€™s value.
	//
	// The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
	Changeset JobChangeset `json:"changeset"`
}

// LicenseResponse The response of a license request.
type LicenseResponse struct {
	// LicenseType Will return the license type property of the Camunda license
	LicenseType *string `json:"licenseType,omitempty"`

	// ValidLicense True if the Camunda license is valid, false if otherwise
	ValidLicense *bool `json:"validLicense,omitempty"`
}

// MatchedDecisionRuleItem The decision rules that matched within this decision evaluation.
type MatchedDecisionRuleItem struct {
	EvaluatedOutputs *[]EvaluatedDecisionOutputItem `json:"evaluatedOutputs,omitempty"`

	// RuleId The ID of the matched rule.
	RuleId *string `json:"ruleId,omitempty"`

	// RuleIndex The index of the matched rule.
	RuleIndex *int32 `json:"ruleIndex,omitempty"`
}

// MessageCorrelationRequest defines model for MessageCorrelationRequest.
type MessageCorrelationRequest struct {
	// CorrelationKey The correlation key of the message
	CorrelationKey *string `json:"correlationKey,omitempty"`

	// Name The message name as defined in the BPMN process
	Name *string `json:"name,omitempty"`

	// TenantId the tenant for which the message is published
	TenantId nullable.Nullable[string] `json:"tenantId,omitempty"`

	// Variables The message variables as JSON document
	Variables nullable.Nullable[map[string]interface{}] `json:"variables,omitempty"`
}

// MessageCorrelationResponse Base properties for MessageCorrelationResponse
type MessageCorrelationResponse = MessageCorrelationResponseBase

// MessageCorrelationResponseBase Base properties for MessageCorrelationResponse
type MessageCorrelationResponseBase struct {
	// TenantId The tenant ID of the correlated message
	TenantId *string `json:"tenantId,omitempty"`
}

// MessageCorrelationResult Base properties for MessageCorrelationResponse
type MessageCorrelationResult = MessageCorrelationResponseBase

// MessagePublicationRequest defines model for MessagePublicationRequest.
type MessagePublicationRequest struct {
	// CorrelationKey The correlation key of the message.
	CorrelationKey string `json:"correlationKey"`

	// MessageId The unique ID of the message. Only useful to ensure only one message with the given ID
	// will ever be published (during its lifetime).
	MessageId nullable.Nullable[string] `json:"messageId,omitempty"`

	// Name The name of the message.
	Name string `json:"name"`

	// TenantId The tenant of the message sender.
	TenantId nullable.Nullable[string] `json:"tenantId,omitempty"`

	// TimeToLive Timespan (in ms) to buffer the message on the broker.
	TimeToLive *int64 `json:"timeToLive,omitempty"`

	// Variables The message variables as JSON document.
	Variables nullable.Nullable[map[string]interface{}] `json:"variables,omitempty"`
}

// MessagePublicationResponse Base properties for MessagePublicationResponse
type MessagePublicationResponse = MessagePublicationResponseBase

// MessagePublicationResponseBase Base properties for MessagePublicationResponse
type MessagePublicationResponseBase struct {
	// TenantId The tenant ID of the message.
	TenantId *string `json:"tenantId,omitempty"`
}

// MessagePublicationResult Base properties for MessagePublicationResponse
type MessagePublicationResult = MessagePublicationResponseBase

// MigrateProcessInstanceMappingInstruction The mapping instructions describe how to map elements from the source process definition to the target process definition.
type MigrateProcessInstanceMappingInstruction struct {
	// SourceElementId The element ID to migrate from.
	SourceElementId string `json:"sourceElementId"`

	// TargetElementId The element ID to migrate into.
	TargetElementId string `json:"targetElementId"`
}

// MigrateProcessInstanceRequest Base properties for MigrateProcessInstanceRequest
type MigrateProcessInstanceRequest = MigrateProcessInstanceRequestBase

// MigrateProcessInstanceRequestBase Base properties for MigrateProcessInstanceRequest
type MigrateProcessInstanceRequestBase struct {
	MappingInstructions *[]MigrateProcessInstanceMappingInstruction `json:"mappingInstructions,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation. Must be > 0 if provided.
	OperationReference *int64 `json:"operationReference,omitempty"`
}

// ModifyProcessInstanceActivateInstruction Base properties for ModifyProcessInstanceActivateInstruction
type ModifyProcessInstanceActivateInstruction = ModifyProcessInstanceActivateInstructionBase

// ModifyProcessInstanceActivateInstructionBase Base properties for ModifyProcessInstanceActivateInstruction
type ModifyProcessInstanceActivateInstructionBase struct {
	// ElementId The ID of the element that should be activated.
	ElementId            *string                                     `json:"elementId,omitempty"`
	VariableInstructions *[]ModifyProcessInstanceVariableInstruction `json:"variableInstructions,omitempty"`
}

// ModifyProcessInstanceRequest Base properties for ModifyProcessInstanceRequest
type ModifyProcessInstanceRequest = ModifyProcessInstanceRequestBase

// ModifyProcessInstanceRequestBase Base properties for ModifyProcessInstanceRequest
type ModifyProcessInstanceRequestBase struct {
	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation. Must be > 0 if provided.
	OperationReference *int64 `json:"operationReference,omitempty"`
}

// ModifyProcessInstanceTerminateInstruction Instructions describing which elements should be terminated.
type ModifyProcessInstanceTerminateInstruction struct {
	// ElementInstanceKey The ID of the element that should be terminated.
	ElementInstanceKey int64 `json:"elementInstanceKey"`
}

// ModifyProcessInstanceVariableInstruction Instructions describing which variables should be created.
type ModifyProcessInstanceVariableInstruction struct {
	// ScopeId The ID of the element in which scope the variables should be created.
	// Leave empty to create the variables in the global scope of the process instance
	ScopeId *string `json:"scopeId,omitempty"`

	// Variables JSON document that will instantiate the variables for the root variable scope of the process instance.
	// It must be a JSON object, as variables will be mapped in a key-value fashion.
	Variables map[string]interface{} `json:"variables"`
}

// OperationItem  Operation
type OperationItem struct {
	BatchOperationId *string             `json:"batchOperationId,omitempty"`
	CompletedDate    *time.Time          `json:"completedDate,omitempty"`
	ErrorMessage     *string             `json:"errorMessage,omitempty"`
	Id               *string             `json:"id,omitempty"`
	State            *OperationItemState `json:"state,omitempty"`
	Type             *OperationItemType  `json:"type,omitempty"`
}

// OperationItemState defines model for OperationItem.State.
type OperationItemState string

// OperationItemType defines model for OperationItem.Type.
type OperationItemType string

// Partition Provides information on a partition within a broker node.
type Partition struct {
	// Health Describes the current health of the partition.
	Health *PartitionHealth `json:"health,omitempty"`

	// PartitionId The unique ID of this partition.
	PartitionId *int32 `json:"partitionId,omitempty"`

	// Role Describes the Raft role of the broker for a given partition.
	Role *PartitionRole `json:"role,omitempty"`
}

// PartitionHealth Describes the current health of the partition.
type PartitionHealth string

// PartitionRole Describes the Raft role of the broker for a given partition.
type PartitionRole string

// ProblemDetail A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type ProblemDetail struct {
	// Detail An explanation of the problem in more detail.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI identifying the origin of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code for this problem.
	Status *int32 `json:"status,omitempty"`

	// Title A summary of the problem type.
	Title *string `json:"title,omitempty"`

	// Type A URI identifying the problem type.
	Type *string `json:"type,omitempty"`
}

// ProcessInstanceCreationInstruction Base properties for CreateProcessInstanceRequest
type ProcessInstanceCreationInstruction = CreateProcessInstanceRequestBase

// ProcessInstanceCreationStartInstruction defines model for ProcessInstanceCreationStartInstruction.
type ProcessInstanceCreationStartInstruction struct {
	// ElementId Future extensions might include:
	//   - different types of start instructions
	//   - ability to set local variables for different flow scopes
	//
	// For now, however, the start instruction is implicitly a "startBeforeElement" instruction
	ElementId *string `json:"elementId,omitempty"`
}

// ProcessInstanceFilter Base properties for ProcessInstanceFilterRequest
type ProcessInstanceFilter = ProcessInstanceFilterRequestBase

// ProcessInstanceFilterRequest Base properties for ProcessInstanceFilterRequest
type ProcessInstanceFilterRequest = ProcessInstanceFilterRequestBase

// ProcessInstanceFilterRequestBase Base properties for ProcessInstanceFilterRequest
type ProcessInstanceFilterRequestBase struct {
	Active           *bool   `json:"active,omitempty"`
	ActivityId       *string `json:"activityId,omitempty"`
	BatchOperationId *string `json:"batchOperationId,omitempty"`

	// BpmnProcessId The bpmn process ID.
	BpmnProcessId            *string                               `json:"bpmnProcessId,omitempty"`
	Canceled                 *bool                                 `json:"canceled,omitempty"`
	Completed                *bool                                 `json:"completed,omitempty"`
	EndDate                  *time.Time                            `json:"endDate,omitempty"`
	ErrorMessage             *string                               `json:"errorMessage,omitempty"`
	Finished                 *bool                                 `json:"finished,omitempty"`
	Incidents                *bool                                 `json:"incidents,omitempty"`
	ProcessDefinitionVersion *int32                                `json:"processDefinitionVersion,omitempty"`
	RetriesLeft              *bool                                 `json:"retriesLeft,omitempty"`
	Running                  *bool                                 `json:"running,omitempty"`
	StartDate                *time.Time                            `json:"startDate,omitempty"`
	TenantId                 *string                               `json:"tenantId,omitempty"`
	Variable                 *ProcessInstanceVariableFilterRequest `json:"variable,omitempty"`
}

// ProcessInstanceItem Base properties for ProcessInstanceItem
type ProcessInstanceItem = ProcessInstanceItemBase

// ProcessInstanceItemBase Base properties for ProcessInstanceItem
type ProcessInstanceItemBase struct {
	BpmnProcessId      *string                         `json:"bpmnProcessId,omitempty"`
	CallHierarchy      *[]ProcessInstanceReferenceItem `json:"callHierarchy,omitempty"`
	EndDate            *time.Time                      `json:"endDate,omitempty"`
	HasActiveOperation *bool                           `json:"hasActiveOperation,omitempty"`
	Incident           *bool                           `json:"incident,omitempty"`
	Operations         *[]OperationItem                `json:"operations,omitempty"`

	// ProcessDefinitionName The process name.
	ProcessDefinitionName    *string                       `json:"processDefinitionName,omitempty"`
	ProcessDefinitionVersion *int32                        `json:"processDefinitionVersion,omitempty"`
	RootInstanceId           *string                       `json:"rootInstanceId,omitempty"`
	StartDate                *time.Time                    `json:"startDate,omitempty"`
	State                    *ProcessInstanceItemBaseState `json:"state,omitempty"`
	TenantId                 *string                       `json:"tenantId,omitempty"`
}

// ProcessInstanceItemBaseState defines model for ProcessInstanceItemBase.State.
type ProcessInstanceItemBaseState string

// ProcessInstanceMigrationInstruction Base properties for MigrateProcessInstanceRequest
type ProcessInstanceMigrationInstruction = MigrateProcessInstanceRequestBase

// ProcessInstanceModificationActivateInstruction Base properties for ModifyProcessInstanceActivateInstruction
type ProcessInstanceModificationActivateInstruction = ModifyProcessInstanceActivateInstructionBase

// ProcessInstanceModificationInstruction Base properties for ModifyProcessInstanceRequest
type ProcessInstanceModificationInstruction = ModifyProcessInstanceRequestBase

// ProcessInstanceModificationTerminateInstruction Instructions describing which elements should be terminated.
type ProcessInstanceModificationTerminateInstruction struct {
	// ElementInstanceKey The ID of the element that should be terminated.
	ElementInstanceKey string `json:"elementInstanceKey"`
}

// ProcessInstanceReferenceItem Process instance reference description
type ProcessInstanceReferenceItem struct {
	InstanceId            *string `json:"instanceId,omitempty"`
	ProcessDefinitionId   *string `json:"processDefinitionId,omitempty"`
	ProcessDefinitionName *string `json:"processDefinitionName,omitempty"`
}

// ProcessInstanceResult Base properties for ProcessInstanceItem
type ProcessInstanceResult = ProcessInstanceItemBase

// ProcessInstanceSearchQuery defines model for ProcessInstanceSearchQuery.
type ProcessInstanceSearchQuery = SearchQueryRequest

// ProcessInstanceSearchQueryRequest defines model for ProcessInstanceSearchQueryRequest.
type ProcessInstanceSearchQueryRequest = SearchQueryRequest

// ProcessInstanceSearchQueryResponse defines model for ProcessInstanceSearchQueryResponse.
type ProcessInstanceSearchQueryResponse = SearchQueryResponse

// ProcessInstanceSearchQueryResult defines model for ProcessInstanceSearchQueryResult.
type ProcessInstanceSearchQueryResult = SearchQueryResponse

// ProcessInstanceVariableFilterRequest defines model for ProcessInstanceVariableFilterRequest.
type ProcessInstanceVariableFilterRequest struct {
	Name   *string   `json:"name,omitempty"`
	Values *[]string `json:"values,omitempty"`
}

// ResourceResult defines model for ResourceResult.
type ResourceResult struct {
	// ResourceId The resource ID of this resource.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceKey The unique key of this resource.
	ResourceKey *string `json:"resourceKey,omitempty"`

	// ResourceName The resource name from which this resource was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The tenant ID of this resource.
	TenantId *string `json:"tenantId,omitempty"`

	// Version The assigned resource version.
	Version *int32 `json:"version,omitempty"`

	// VersionTag The version tag of this resource.
	VersionTag *string `json:"versionTag,omitempty"`
}

// SearchQueryPageRequest defines model for SearchQueryPageRequest.
type SearchQueryPageRequest struct {
	From         *int32                    `json:"from,omitempty"`
	Limit        *int32                    `json:"limit,omitempty"`
	SearchAfter  *[]map[string]interface{} `json:"searchAfter,omitempty"`
	SearchBefore *[]map[string]interface{} `json:"searchBefore,omitempty"`
}

// SearchQueryPageResponse defines model for SearchQueryPageResponse.
type SearchQueryPageResponse struct {
	FirstSortValues *[]map[string]interface{} `json:"firstSortValues,omitempty"`
	LastSortValues  *[]map[string]interface{} `json:"lastSortValues,omitempty"`
	TotalItems      *int64                    `json:"totalItems,omitempty"`
}

// SearchQueryRequest defines model for SearchQueryRequest.
type SearchQueryRequest struct {
	Page *SearchQueryPageRequest   `json:"page,omitempty"`
	Sort *[]SearchQuerySortRequest `json:"sort,omitempty"`
}

// SearchQueryResponse defines model for SearchQueryResponse.
type SearchQueryResponse struct {
	Page *SearchQueryPageResponse `json:"page,omitempty"`
}

// SearchQuerySortRequest defines model for SearchQuerySortRequest.
type SearchQuerySortRequest struct {
	Field string  `json:"field"`
	Order *string `json:"order,omitempty"`
}

// SetVariableRequest defines model for SetVariableRequest.
type SetVariableRequest struct {
	// Local If set to true, the variables are merged strictly into the local scope (as specified by the `elementInstanceKey`).
	// Otherwise, the variables are propagated to upper scopes and set at the outermost one.
	//
	// Letâ€™s consider the following example:
	//
	// There are two scopes '1' and '2'.
	// Scope '1' is the parent scope of '2'. The effective variables of the scopes are:
	// 1 => { "foo" : 2 }
	// 2 => { "bar" : 1 }
	//
	// An update request with elementInstanceKey as '2', variables { "foo" : 5 }, and local set
	// to true leaves scope '1' unchanged and adjusts scope '2' to { "bar" : 1, "foo" 5 }.
	//
	// By default, with local set to false, scope '1' will be { "foo": 5 }
	// and scope '2' will be { "bar" : 1 }.
	Local *bool `json:"local,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation. Must be > 0 if provided.
	OperationReference *int64 `json:"operationReference,omitempty"`

	// Variables JSON object representing the variables to set in the elementâ€™s scope.
	Variables map[string]interface{} `json:"variables"`
}

// SignalBroadcastRequest defines model for SignalBroadcastRequest.
type SignalBroadcastRequest struct {
	// SignalName The name of the signal to broadcast.
	SignalName string `json:"signalName"`

	// TenantId The ID of the tenant that owns the signal.
	TenantId *string `json:"tenantId,omitempty"`

	// Variables The signal variables as a JSON object.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// SignalBroadcastResponse Base properties for SignalBroadcastResponse
type SignalBroadcastResponse = SignalBroadcastResponseBase

// SignalBroadcastResponseBase Base properties for SignalBroadcastResponse
type SignalBroadcastResponseBase struct {
	// TenantId The tenant ID of the signal that was broadcast.
	TenantId *string `json:"tenantId,omitempty"`
}

// SignalBroadcastResult Base properties for SignalBroadcastResponse
type SignalBroadcastResult = SignalBroadcastResponseBase

// TopologyResponse The response of a topology request.
type TopologyResponse struct {
	// Brokers A list of brokers that are part of this cluster.
	Brokers nullable.Nullable[[]BrokerInfo] `json:"brokers,omitempty"`

	// ClusterSize The number of brokers in the cluster.
	ClusterSize nullable.Nullable[int32] `json:"clusterSize,omitempty"`

	// GatewayVersion The version of the Zeebe Gateway.
	GatewayVersion nullable.Nullable[string] `json:"gatewayVersion,omitempty"`

	// PartitionsCount The number of partitions are spread across the cluster.
	PartitionsCount nullable.Nullable[int32] `json:"partitionsCount,omitempty"`

	// ReplicationFactor The configured replication factor for this cluster.
	ReplicationFactor nullable.Nullable[int32] `json:"replicationFactor,omitempty"`
}

// UserCreateResponse defines model for UserCreateResponse.
type UserCreateResponse struct {
	// UserKey The key of the created user
	UserKey *int64 `json:"userKey,omitempty"`
}

// UserFilterRequest defines model for UserFilterRequest.
type UserFilterRequest struct {
	Email    *string `json:"email,omitempty"`
	Name     *string `json:"name,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserRequest defines model for UserRequest.
type UserRequest struct {
	Email    *string `json:"email,omitempty"`
	Name     *string `json:"name,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserResponse Base properties for UserResponse
type UserResponse = UserResponseBase

// UserResponseBase Base properties for UserResponse
type UserResponseBase struct {
	Email    *string `json:"email,omitempty"`
	Id       *int64  `json:"id,omitempty"`
	Name     *string `json:"name,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserResult Base properties for UserResponse
type UserResult = UserResponseBase

// UserSearchQueryRequest defines model for UserSearchQueryRequest.
type UserSearchQueryRequest = SearchQueryRequest

// UserSearchResponse defines model for UserSearchResponse.
type UserSearchResponse = SearchQueryResponse

// UserSearchResult defines model for UserSearchResult.
type UserSearchResult = SearchQueryResponse

// UserTaskAssignmentRequest defines model for UserTaskAssignmentRequest.
type UserTaskAssignmentRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "assign".
	Action nullable.Nullable[string] `json:"action,omitempty"`

	// AllowOverride By default, the task is reassigned if it was already assigned. Set this to `false` to return an error in such cases. The task must then first be unassigned to be assigned again. Use this when you have users picking from group task queues to prevent race conditions.
	AllowOverride nullable.Nullable[bool] `json:"allowOverride,omitempty"`

	// Assignee The assignee for the user task. The assignee must not be empty or `null`.
	Assignee *string `json:"assignee,omitempty"`
}

// UserTaskCompletionRequest defines model for UserTaskCompletionRequest.
type UserTaskCompletionRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "complete".
	Action nullable.Nullable[string] `json:"action,omitempty"`

	// Variables The variables to complete the user task with.
	Variables nullable.Nullable[map[string]interface{}] `json:"variables,omitempty"`
}

// UserTaskFilter Base properties for ProcessInstanceFilterRequest
type UserTaskFilter = UserTaskFilterRequestBase

// UserTaskFilterRequest Base properties for ProcessInstanceFilterRequest
type UserTaskFilterRequest = UserTaskFilterRequestBase

// UserTaskFilterRequestBase Base properties for ProcessInstanceFilterRequest
type UserTaskFilterRequestBase struct {
	Assignee            *string `json:"assignee,omitempty"`
	CandidateGroup      *string `json:"candidateGroup,omitempty"`
	CandidateUser       *string `json:"candidateUser,omitempty"`
	ElementId           *string `json:"elementId,omitempty"`
	ProcessDefinitionId *string `json:"processDefinitionId,omitempty"`
	State               *string `json:"state,omitempty"`
	TenantIds           *string `json:"tenantIds,omitempty"`
}

// UserTaskItem Base properties for UserTaskItem
type UserTaskItem = UserTaskItemBase

// UserTaskItemBase Base properties for UserTaskItem
type UserTaskItemBase struct {
	Assignee              *string            `json:"assignee,omitempty"`
	CandidateGroup        *[]string          `json:"candidateGroup,omitempty"`
	CandidateUser         *[]string          `json:"candidateUser,omitempty"`
	CompletionDate        *time.Time         `json:"completionDate,omitempty"`
	CreationDate          *time.Time         `json:"creationDate,omitempty"`
	CustomHeaders         *map[string]string `json:"customHeaders,omitempty"`
	DueDate               *time.Time         `json:"dueDate,omitempty"`
	ElementId             *string            `json:"elementId,omitempty"`
	ExternalFormReference *string            `json:"externalFormReference,omitempty"`
	FollowUpDate          *time.Time         `json:"followUpDate,omitempty"`

	// Priority The priority of a user task. The higher the value the higher the priority.
	Priority                 *int    `json:"priority,omitempty"`
	ProcessDefinitionId      *string `json:"processDefinitionId,omitempty"`
	ProcessDefinitionVersion *int32  `json:"processDefinitionVersion,omitempty"`
	State                    *string `json:"state,omitempty"`
	TenantIds                *string `json:"tenantIds,omitempty"`
}

// UserTaskResult Base properties for UserTaskItem
type UserTaskResult = UserTaskItemBase

// UserTaskSearchQuery defines model for UserTaskSearchQuery.
type UserTaskSearchQuery = SearchQueryRequest

// UserTaskSearchQueryRequest defines model for UserTaskSearchQueryRequest.
type UserTaskSearchQueryRequest = SearchQueryRequest

// UserTaskSearchQueryResponse defines model for UserTaskSearchQueryResponse.
type UserTaskSearchQueryResponse = SearchQueryResponse

// UserTaskSearchQueryResult defines model for UserTaskSearchQueryResult.
type UserTaskSearchQueryResult = SearchQueryResponse

// UserTaskUpdateRequest defines model for UserTaskUpdateRequest.
type UserTaskUpdateRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "update".
	Action nullable.Nullable[string] `json:"action,omitempty"`

	// Changeset JSON object with changed task attribute values.
	//
	// The following attributes can be adjusted with this endpoint, additional attributes
	// will be ignored:
	//
	// * `candidateGroups` - reset by providing an empty list
	// * `candidateUsers` - reset by providing an empty list
	// * `dueDate` - reset by providing an empty String
	// * `followUpDate` - reset by providing an empty String
	// * `priority` - minimum 0, maximum 100, default 50
	//
	// Providing any of those attributes with a `null` value or omitting it preserves
	// the persisted attribute's value.
	//
	// The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
	// This ensures correct event emission for assignee changes.
	Changeset nullable.Nullable[Changeset] `json:"changeset,omitempty"`
}

// VariableValueFilterRequest defines model for VariableValueFilterRequest.
type VariableValueFilterRequest struct {
	Eq   *map[string]interface{} `json:"eq,omitempty"`
	Gt   *map[string]interface{} `json:"gt,omitempty"`
	Gte  *map[string]interface{} `json:"gte,omitempty"`
	Lt   *map[string]interface{} `json:"lt,omitempty"`
	Lte  *map[string]interface{} `json:"lte,omitempty"`
	Name *string                 `json:"name,omitempty"`
	Neq  *map[string]interface{} `json:"neq,omitempty"`
}

// InternalServerError A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type InternalServerError = ProblemDetail

// DeployResourcesMultipartBody defines parameters for DeployResources.
type DeployResourcesMultipartBody struct {
	// Resources The binary data to create the deployment resources. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
	Resources *[]openapi_types.File `json:"resources,omitempty"`

	// TenantId The tenant to deploy the resources to.
	TenantId *string `json:"tenantId,omitempty"`
}

// UploadDocumentMultipartBody defines parameters for UploadDocument.
type UploadDocumentMultipartBody struct {
	File openapi_types.File `json:"file"`

	// Metadata Information about the document.
	Metadata *DocumentMetadata `json:"metadata,omitempty"`
}

// UploadDocumentParams defines parameters for UploadDocument.
type UploadDocumentParams struct {
	// StoreId The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`

	// DocumentId The ID of the document to upload. If not provided, a new ID will be generated. Specifying an existing ID will result in an error if the document already exists.
	DocumentId *string `form:"documentId,omitempty" json:"documentId,omitempty"`
}

// UploadMultipleDocumentsMultipartBody defines parameters for UploadMultipleDocuments.
type UploadMultipleDocumentsMultipartBody struct {
	// Files The documents to upload.
	Files []openapi_types.File `json:"files"`
}

// UploadMultipleDocumentsParams defines parameters for UploadMultipleDocuments.
type UploadMultipleDocumentsParams struct {
	// StoreId The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// DeleteDocumentParams defines parameters for DeleteDocument.
type DeleteDocumentParams struct {
	// StoreId The ID of the document store to delete the document from.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// DownloadDocumentParams defines parameters for DownloadDocument.
type DownloadDocumentParams struct {
	// StoreId The ID of the document store to download the document from.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`

	// ContentHash The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.
	ContentHash *string `form:"contentHash,omitempty" json:"contentHash,omitempty"`
}

// CreateDocumentLinkParams defines parameters for CreateDocumentLink.
type CreateDocumentLinkParams struct {
	// StoreId The ID of the document store to link the document from.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`

	// ContentHash The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.
	ContentHash *string `form:"contentHash,omitempty" json:"contentHash,omitempty"`
}

// PinInternalClockAlphaJSONRequestBody defines body for PinInternalClockAlpha for application/json ContentType.
type PinInternalClockAlphaJSONRequestBody = ClockPinRequest

// EvaluateDecisionJSONRequestBody defines body for EvaluateDecision for application/json ContentType.
type EvaluateDecisionJSONRequestBody = DecisionEvaluationInstruction

// EvaluateDecisionApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for EvaluateDecision for application/vnd.camunda.api.keys.number+json ContentType.
type EvaluateDecisionApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = EvaluateDecisionRequest

// EvaluateDecisionApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for EvaluateDecision for application/vnd.camunda.api.keys.string+json ContentType.
type EvaluateDecisionApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = DecisionEvaluationInstruction

// QueryDecisionDefinitionsAlphaJSONRequestBody defines body for QueryDecisionDefinitionsAlpha for application/json ContentType.
type QueryDecisionDefinitionsAlphaJSONRequestBody = DecisionDefinitionSearchQuery

// QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for QueryDecisionDefinitionsAlpha for application/vnd.camunda.api.keys.number+json ContentType.
type QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = DecisionDefinitionSearchQueryRequest

// QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for QueryDecisionDefinitionsAlpha for application/vnd.camunda.api.keys.string+json ContentType.
type QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = DecisionDefinitionSearchQuery

// QueryDecisionInstancesAlphaJSONRequestBody defines body for QueryDecisionInstancesAlpha for application/json ContentType.
type QueryDecisionInstancesAlphaJSONRequestBody = DecisionInstanceSearchQuery

// QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for QueryDecisionInstancesAlpha for application/vnd.camunda.api.keys.number+json ContentType.
type QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = DecisionInstanceSearchQueryRequest

// QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for QueryDecisionInstancesAlpha for application/vnd.camunda.api.keys.string+json ContentType.
type QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = DecisionInstanceSearchQuery

// QueryDecisionRequirementsAlphaJSONRequestBody defines body for QueryDecisionRequirementsAlpha for application/json ContentType.
type QueryDecisionRequirementsAlphaJSONRequestBody = DecisionRequirementsSearchQuery

// QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for QueryDecisionRequirementsAlpha for application/vnd.camunda.api.keys.number+json ContentType.
type QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = DecisionRequirementsSearchQueryRequest

// QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for QueryDecisionRequirementsAlpha for application/vnd.camunda.api.keys.string+json ContentType.
type QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = DecisionRequirementsSearchQuery

// DeployResourcesMultipartRequestBody defines body for DeployResources for multipart/form-data ContentType.
type DeployResourcesMultipartRequestBody DeployResourcesMultipartBody

// UploadDocumentMultipartRequestBody defines body for UploadDocument for multipart/form-data ContentType.
type UploadDocumentMultipartRequestBody UploadDocumentMultipartBody

// UploadMultipleDocumentsMultipartRequestBody defines body for UploadMultipleDocuments for multipart/form-data ContentType.
type UploadMultipleDocumentsMultipartRequestBody UploadMultipleDocumentsMultipartBody

// CreateDocumentLinkJSONRequestBody defines body for CreateDocumentLink for application/json ContentType.
type CreateDocumentLinkJSONRequestBody = DocumentLinkRequest

// UpdateElementInstanceVariablesJSONRequestBody defines body for UpdateElementInstanceVariables for application/json ContentType.
type UpdateElementInstanceVariablesJSONRequestBody = SetVariableRequest

// QueryFlowNodeInstancesAlphaJSONRequestBody defines body for QueryFlowNodeInstancesAlpha for application/json ContentType.
type QueryFlowNodeInstancesAlphaJSONRequestBody = FlowNodeInstanceSearchQuery

// QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for QueryFlowNodeInstancesAlpha for application/vnd.camunda.api.keys.number+json ContentType.
type QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = FlowNodeInstanceSearchQueryRequest

// QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for QueryFlowNodeInstancesAlpha for application/vnd.camunda.api.keys.string+json ContentType.
type QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = FlowNodeInstanceSearchQuery

// QueryIncidentsAlphaJSONRequestBody defines body for QueryIncidentsAlpha for application/json ContentType.
type QueryIncidentsAlphaJSONRequestBody = IncidentSearchQuery

// QueryIncidentsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for QueryIncidentsAlpha for application/vnd.camunda.api.keys.number+json ContentType.
type QueryIncidentsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = IncidentSearchQueryRequest

// QueryIncidentsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for QueryIncidentsAlpha for application/vnd.camunda.api.keys.string+json ContentType.
type QueryIncidentsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = IncidentSearchQuery

// ActivateJobsJSONRequestBody defines body for ActivateJobs for application/json ContentType.
type ActivateJobsJSONRequestBody = JobActivationRequest

// UpdateAJobJSONRequestBody defines body for UpdateAJob for application/json ContentType.
type UpdateAJobJSONRequestBody = JobUpdateRequest

// CompleteJobJSONRequestBody defines body for CompleteJob for application/json ContentType.
type CompleteJobJSONRequestBody = JobCompletionRequest

// ThrowErrorForJobJSONRequestBody defines body for ThrowErrorForJob for application/json ContentType.
type ThrowErrorForJobJSONRequestBody = JobErrorRequest

// FailJobJSONRequestBody defines body for FailJob for application/json ContentType.
type FailJobJSONRequestBody = JobFailRequest

// CorrelateAMessageJSONRequestBody defines body for CorrelateAMessage for application/json ContentType.
type CorrelateAMessageJSONRequestBody = MessageCorrelationRequest

// PublishAMessageJSONRequestBody defines body for PublishAMessage for application/json ContentType.
type PublishAMessageJSONRequestBody = MessagePublicationRequest

// CreateProcessInstanceJSONRequestBody defines body for CreateProcessInstance for application/json ContentType.
type CreateProcessInstanceJSONRequestBody = ProcessInstanceCreationInstruction

// CreateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for CreateProcessInstance for application/vnd.camunda.api.keys.number+json ContentType.
type CreateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = CreateProcessInstanceRequest

// CreateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for CreateProcessInstance for application/vnd.camunda.api.keys.string+json ContentType.
type CreateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = ProcessInstanceCreationInstruction

// QueryProcessInstancesAlphaJSONRequestBody defines body for QueryProcessInstancesAlpha for application/json ContentType.
type QueryProcessInstancesAlphaJSONRequestBody = ProcessInstanceSearchQuery

// QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for QueryProcessInstancesAlpha for application/vnd.camunda.api.keys.number+json ContentType.
type QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = ProcessInstanceSearchQueryRequest

// QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for QueryProcessInstancesAlpha for application/vnd.camunda.api.keys.string+json ContentType.
type QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = ProcessInstanceSearchQuery

// CancelProcessInstanceJSONRequestBody defines body for CancelProcessInstance for application/json ContentType.
type CancelProcessInstanceJSONRequestBody = CancelProcessInstanceRequest

// MigrateProcessInstanceJSONRequestBody defines body for MigrateProcessInstance for application/json ContentType.
type MigrateProcessInstanceJSONRequestBody = ProcessInstanceMigrationInstruction

// MigrateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for MigrateProcessInstance for application/vnd.camunda.api.keys.number+json ContentType.
type MigrateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = MigrateProcessInstanceRequest

// MigrateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for MigrateProcessInstance for application/vnd.camunda.api.keys.string+json ContentType.
type MigrateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = ProcessInstanceMigrationInstruction

// ModifyProcessInstanceJSONRequestBody defines body for ModifyProcessInstance for application/json ContentType.
type ModifyProcessInstanceJSONRequestBody = ProcessInstanceModificationInstruction

// ModifyProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for ModifyProcessInstance for application/vnd.camunda.api.keys.number+json ContentType.
type ModifyProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = ModifyProcessInstanceRequest

// ModifyProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for ModifyProcessInstance for application/vnd.camunda.api.keys.string+json ContentType.
type ModifyProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = ProcessInstanceModificationInstruction

// DeleteResourceJSONRequestBody defines body for DeleteResource for application/json ContentType.
type DeleteResourceJSONRequestBody = DeleteResourceRequest

// BroadcastSignalJSONRequestBody defines body for BroadcastSignal for application/json ContentType.
type BroadcastSignalJSONRequestBody = SignalBroadcastRequest

// QueryUserTasksAlphaJSONRequestBody defines body for QueryUserTasksAlpha for application/json ContentType.
type QueryUserTasksAlphaJSONRequestBody = UserTaskSearchQuery

// QueryUserTasksAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody defines body for QueryUserTasksAlpha for application/vnd.camunda.api.keys.number+json ContentType.
type QueryUserTasksAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody = UserTaskSearchQueryRequest

// QueryUserTasksAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody defines body for QueryUserTasksAlpha for application/vnd.camunda.api.keys.string+json ContentType.
type QueryUserTasksAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody = UserTaskSearchQuery

// UpdateUserTaskJSONRequestBody defines body for UpdateUserTask for application/json ContentType.
type UpdateUserTaskJSONRequestBody = UserTaskUpdateRequest

// AssignUserTaskJSONRequestBody defines body for AssignUserTask for application/json ContentType.
type AssignUserTaskJSONRequestBody = UserTaskAssignmentRequest

// CompleteUserTaskJSONRequestBody defines body for CompleteUserTask for application/json ContentType.
type CompleteUserTaskJSONRequestBody = UserTaskCompletionRequest

// Getter for additional properties for Changeset. Returns the specified
// element and whether it was found
func (a Changeset) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Changeset
func (a *Changeset) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Changeset to handle AdditionalProperties
func (a *Changeset) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["candidateGroups"]; found {
		err = json.Unmarshal(raw, &a.CandidateGroups)
		if err != nil {
			return fmt.Errorf("error reading 'candidateGroups': %w", err)
		}
		delete(object, "candidateGroups")
	}

	if raw, found := object["candidateUsers"]; found {
		err = json.Unmarshal(raw, &a.CandidateUsers)
		if err != nil {
			return fmt.Errorf("error reading 'candidateUsers': %w", err)
		}
		delete(object, "candidateUsers")
	}

	if raw, found := object["dueDate"]; found {
		err = json.Unmarshal(raw, &a.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'dueDate': %w", err)
		}
		delete(object, "dueDate")
	}

	if raw, found := object["followUpDate"]; found {
		err = json.Unmarshal(raw, &a.FollowUpDate)
		if err != nil {
			return fmt.Errorf("error reading 'followUpDate': %w", err)
		}
		delete(object, "followUpDate")
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &a.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
		delete(object, "priority")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Changeset to handle AdditionalProperties
func (a Changeset) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CandidateGroups != nil {
		object["candidateGroups"], err = json.Marshal(a.CandidateGroups)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'candidateGroups': %w", err)
		}
	}

	if a.CandidateUsers != nil {
		object["candidateUsers"], err = json.Marshal(a.CandidateUsers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'candidateUsers': %w", err)
		}
	}

	if a.DueDate != nil {
		object["dueDate"], err = json.Marshal(a.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dueDate': %w", err)
		}
	}

	if a.FollowUpDate != nil {
		object["followUpDate"], err = json.Marshal(a.FollowUpDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'followUpDate': %w", err)
		}
	}

	if a.Priority != nil {
		object["priority"], err = json.Marshal(a.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PinInternalClockAlphaWithBody request with any body
	PinInternalClockAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PinInternalClockAlpha(ctx context.Context, body PinInternalClockAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetInternalClockAlpha request
	ResetInternalClockAlpha(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EvaluateDecisionWithBody request with any body
	EvaluateDecisionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EvaluateDecision(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	EvaluateDecisionWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body EvaluateDecisionApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	EvaluateDecisionWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body EvaluateDecisionApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryDecisionDefinitionsAlphaWithBody request with any body
	QueryDecisionDefinitionsAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryDecisionDefinitionsAlpha(ctx context.Context, body QueryDecisionDefinitionsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryDecisionDefinitionsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryDecisionDefinitionsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionDefinitionXmlAlpha request
	GetDecisionDefinitionXmlAlpha(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryDecisionInstancesAlphaWithBody request with any body
	QueryDecisionInstancesAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryDecisionInstancesAlpha(ctx context.Context, body QueryDecisionInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryDecisionInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryDecisionInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryDecisionRequirementsAlphaWithBody request with any body
	QueryDecisionRequirementsAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryDecisionRequirementsAlpha(ctx context.Context, body QueryDecisionRequirementsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryDecisionRequirementsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryDecisionRequirementsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeployResourcesWithBody request with any body
	DeployResourcesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadDocumentWithBody request with any body
	UploadDocumentWithBody(ctx context.Context, params *UploadDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadMultipleDocumentsWithBody request with any body
	UploadMultipleDocumentsWithBody(ctx context.Context, params *UploadMultipleDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDocument request
	DeleteDocument(ctx context.Context, documentId string, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadDocument request
	DownloadDocument(ctx context.Context, documentId string, params *DownloadDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDocumentLinkWithBody request with any body
	CreateDocumentLinkWithBody(ctx context.Context, documentId string, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDocumentLink(ctx context.Context, documentId string, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateElementInstanceVariablesWithBody request with any body
	UpdateElementInstanceVariablesWithBody(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateElementInstanceVariables(ctx context.Context, elementInstanceKey string, body UpdateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryFlowNodeInstancesAlphaWithBody request with any body
	QueryFlowNodeInstancesAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryFlowNodeInstancesAlpha(ctx context.Context, body QueryFlowNodeInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryFlowNodeInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryFlowNodeInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryIncidentsAlphaWithBody request with any body
	QueryIncidentsAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryIncidentsAlpha(ctx context.Context, body QueryIncidentsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryIncidentsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryIncidentsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryIncidentsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryIncidentsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncidentByKeyAlpha request
	GetIncidentByKeyAlpha(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolveIncident request
	ResolveIncident(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateJobsWithBody request with any body
	ActivateJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateJobs(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAJobWithBody request with any body
	UpdateAJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAJob(ctx context.Context, jobKey string, body UpdateAJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteJobWithBody request with any body
	CompleteJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompleteJob(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThrowErrorForJobWithBody request with any body
	ThrowErrorForJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ThrowErrorForJob(ctx context.Context, jobKey string, body ThrowErrorForJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FailJobWithBody request with any body
	FailJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FailJob(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatusOfCamundaLicense request
	GetStatusOfCamundaLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CorrelateAMessageWithBody request with any body
	CorrelateAMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CorrelateAMessage(ctx context.Context, body CorrelateAMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishAMessageWithBody request with any body
	PublishAMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublishAMessage(ctx context.Context, body PublishAMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProcessInstanceWithBody request with any body
	CreateProcessInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProcessInstance(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body CreateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body CreateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryProcessInstancesAlphaWithBody request with any body
	QueryProcessInstancesAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryProcessInstancesAlpha(ctx context.Context, body QueryProcessInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryProcessInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryProcessInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelProcessInstanceWithBody request with any body
	CancelProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelProcessInstance(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateProcessInstanceWithBody request with any body
	MigrateProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateProcessInstance(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyProcessInstanceWithBody request with any body
	ModifyProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyProcessInstance(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, resourceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceContent request
	GetResourceContent(ctx context.Context, resourceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResourceWithBody request with any body
	DeleteResourceWithBody(ctx context.Context, resourceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteResource(ctx context.Context, resourceKey string, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BroadcastSignalWithBody request with any body
	BroadcastSignalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BroadcastSignal(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterTopology request
	GetClusterTopology(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryUserTasksAlphaWithBody request with any body
	QueryUserTasksAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryUserTasksAlpha(ctx context.Context, body QueryUserTasksAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryUserTasksAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryUserTasksAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryUserTasksAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryUserTasksAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserTaskWithBody request with any body
	UpdateUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserTask(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignUserTask request
	UnassignUserTask(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignUserTaskWithBody request with any body
	AssignUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignUserTask(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteUserTaskWithBody request with any body
	CompleteUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompleteUserTask(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PinInternalClockAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPinInternalClockAlphaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PinInternalClockAlpha(ctx context.Context, body PinInternalClockAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPinInternalClockAlphaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetInternalClockAlpha(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetInternalClockAlphaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EvaluateDecisionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateDecisionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EvaluateDecision(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateDecisionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EvaluateDecisionWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body EvaluateDecisionApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateDecisionRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EvaluateDecisionWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body EvaluateDecisionApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateDecisionRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionDefinitionsAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionDefinitionsAlphaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionDefinitionsAlpha(ctx context.Context, body QueryDecisionDefinitionsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionDefinitionsAlphaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionDefinitionsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionDefinitionsAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionDefinitionsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionDefinitionsAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionDefinitionXmlAlpha(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionDefinitionXmlAlphaRequest(c.Server, decisionDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionInstancesAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionInstancesAlphaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionInstancesAlpha(ctx context.Context, body QueryDecisionInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionInstancesAlphaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionInstancesAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionInstancesAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionRequirementsAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionRequirementsAlphaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionRequirementsAlpha(ctx context.Context, body QueryDecisionRequirementsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionRequirementsAlphaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionRequirementsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionRequirementsAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDecisionRequirementsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDecisionRequirementsAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployResourcesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployResourcesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadDocumentWithBody(ctx context.Context, params *UploadDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadDocumentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadMultipleDocumentsWithBody(ctx context.Context, params *UploadMultipleDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadMultipleDocumentsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDocument(ctx context.Context, documentId string, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDocumentRequest(c.Server, documentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadDocument(ctx context.Context, documentId string, params *DownloadDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadDocumentRequest(c.Server, documentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocumentLinkWithBody(ctx context.Context, documentId string, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDocumentLinkRequestWithBody(c.Server, documentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocumentLink(ctx context.Context, documentId string, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDocumentLinkRequest(c.Server, documentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateElementInstanceVariablesWithBody(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateElementInstanceVariablesRequestWithBody(c.Server, elementInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateElementInstanceVariables(ctx context.Context, elementInstanceKey string, body UpdateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateElementInstanceVariablesRequest(c.Server, elementInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryFlowNodeInstancesAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryFlowNodeInstancesAlphaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryFlowNodeInstancesAlpha(ctx context.Context, body QueryFlowNodeInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryFlowNodeInstancesAlphaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryFlowNodeInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryFlowNodeInstancesAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryFlowNodeInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryFlowNodeInstancesAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryIncidentsAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryIncidentsAlphaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryIncidentsAlpha(ctx context.Context, body QueryIncidentsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryIncidentsAlphaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryIncidentsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryIncidentsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryIncidentsAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryIncidentsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryIncidentsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryIncidentsAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncidentByKeyAlpha(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncidentByKeyAlphaRequest(c.Server, incidentKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveIncident(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveIncidentRequest(c.Server, incidentKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateJobs(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAJob(ctx context.Context, jobKey string, body UpdateAJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteJob(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThrowErrorForJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThrowErrorForJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThrowErrorForJob(ctx context.Context, jobKey string, body ThrowErrorForJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThrowErrorForJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FailJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFailJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FailJob(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFailJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatusOfCamundaLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusOfCamundaLicenseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CorrelateAMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCorrelateAMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CorrelateAMessage(ctx context.Context, body CorrelateAMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCorrelateAMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishAMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishAMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishAMessage(ctx context.Context, body PublishAMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishAMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProcessInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProcessInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProcessInstance(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProcessInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body CreateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProcessInstanceRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body CreateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProcessInstanceRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryProcessInstancesAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryProcessInstancesAlphaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryProcessInstancesAlpha(ctx context.Context, body QueryProcessInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryProcessInstancesAlphaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryProcessInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryProcessInstancesAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryProcessInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryProcessInstancesAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelProcessInstanceRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelProcessInstance(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelProcessInstanceRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateProcessInstanceRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateProcessInstance(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateProcessInstanceRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateProcessInstanceRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateProcessInstanceRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProcessInstanceRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProcessInstance(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProcessInstanceRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProcessInstanceRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProcessInstanceRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, resourceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, resourceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceContent(ctx context.Context, resourceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceContentRequest(c.Server, resourceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourceWithBody(ctx context.Context, resourceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequestWithBody(c.Server, resourceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResource(ctx context.Context, resourceKey string, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequest(c.Server, resourceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BroadcastSignalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBroadcastSignalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BroadcastSignal(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBroadcastSignalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterTopology(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterTopologyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryUserTasksAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryUserTasksAlphaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryUserTasksAlpha(ctx context.Context, body QueryUserTasksAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryUserTasksAlphaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryUserTasksAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx context.Context, body QueryUserTasksAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryUserTasksAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryUserTasksAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx context.Context, body QueryUserTasksAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryUserTasksAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserTaskRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserTask(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserTaskRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignUserTask(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignUserTaskRequest(c.Server, userTaskKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserTaskRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserTask(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserTaskRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteUserTaskRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteUserTask(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteUserTaskRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPinInternalClockAlphaRequest calls the generic PinInternalClockAlpha builder with application/json body
func NewPinInternalClockAlphaRequest(server string, body PinInternalClockAlphaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPinInternalClockAlphaRequestWithBody(server, "application/json", bodyReader)
}

// NewPinInternalClockAlphaRequestWithBody generates requests for PinInternalClockAlpha with any type of body
func NewPinInternalClockAlphaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clock")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetInternalClockAlphaRequest generates requests for ResetInternalClockAlpha
func NewResetInternalClockAlphaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clock/reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEvaluateDecisionRequest calls the generic EvaluateDecision builder with application/json body
func NewEvaluateDecisionRequest(server string, body EvaluateDecisionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEvaluateDecisionRequestWithBody(server, "application/json", bodyReader)
}

// NewEvaluateDecisionRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic EvaluateDecision builder with application/vnd.camunda.api.keys.number+json body
func NewEvaluateDecisionRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, body EvaluateDecisionApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEvaluateDecisionRequestWithBody(server, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewEvaluateDecisionRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic EvaluateDecision builder with application/vnd.camunda.api.keys.string+json body
func NewEvaluateDecisionRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, body EvaluateDecisionApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEvaluateDecisionRequestWithBody(server, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewEvaluateDecisionRequestWithBody generates requests for EvaluateDecision with any type of body
func NewEvaluateDecisionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/evaluation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryDecisionDefinitionsAlphaRequest calls the generic QueryDecisionDefinitionsAlpha builder with application/json body
func NewQueryDecisionDefinitionsAlphaRequest(server string, body QueryDecisionDefinitionsAlphaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryDecisionDefinitionsAlphaRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryDecisionDefinitionsAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic QueryDecisionDefinitionsAlpha builder with application/vnd.camunda.api.keys.number+json body
func NewQueryDecisionDefinitionsAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, body QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryDecisionDefinitionsAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewQueryDecisionDefinitionsAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic QueryDecisionDefinitionsAlpha builder with application/vnd.camunda.api.keys.string+json body
func NewQueryDecisionDefinitionsAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, body QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryDecisionDefinitionsAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewQueryDecisionDefinitionsAlphaRequestWithBody generates requests for QueryDecisionDefinitionsAlpha with any type of body
func NewQueryDecisionDefinitionsAlphaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionDefinitionXmlAlphaRequest generates requests for GetDecisionDefinitionXmlAlpha
func NewGetDecisionDefinitionXmlAlphaRequest(server string, decisionDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionDefinitionKey", runtime.ParamLocationPath, decisionDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryDecisionInstancesAlphaRequest calls the generic QueryDecisionInstancesAlpha builder with application/json body
func NewQueryDecisionInstancesAlphaRequest(server string, body QueryDecisionInstancesAlphaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryDecisionInstancesAlphaRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryDecisionInstancesAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic QueryDecisionInstancesAlpha builder with application/vnd.camunda.api.keys.number+json body
func NewQueryDecisionInstancesAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, body QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryDecisionInstancesAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewQueryDecisionInstancesAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic QueryDecisionInstancesAlpha builder with application/vnd.camunda.api.keys.string+json body
func NewQueryDecisionInstancesAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, body QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryDecisionInstancesAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewQueryDecisionInstancesAlphaRequestWithBody generates requests for QueryDecisionInstancesAlpha with any type of body
func NewQueryDecisionInstancesAlphaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryDecisionRequirementsAlphaRequest calls the generic QueryDecisionRequirementsAlpha builder with application/json body
func NewQueryDecisionRequirementsAlphaRequest(server string, body QueryDecisionRequirementsAlphaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryDecisionRequirementsAlphaRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryDecisionRequirementsAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic QueryDecisionRequirementsAlpha builder with application/vnd.camunda.api.keys.number+json body
func NewQueryDecisionRequirementsAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, body QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryDecisionRequirementsAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewQueryDecisionRequirementsAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic QueryDecisionRequirementsAlpha builder with application/vnd.camunda.api.keys.string+json body
func NewQueryDecisionRequirementsAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, body QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryDecisionRequirementsAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewQueryDecisionRequirementsAlphaRequestWithBody generates requests for QueryDecisionRequirementsAlpha with any type of body
func NewQueryDecisionRequirementsAlphaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-requirements/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeployResourcesRequestWithBody generates requests for DeployResources with any type of body
func NewDeployResourcesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadDocumentRequestWithBody generates requests for UploadDocument with any type of body
func NewUploadDocumentRequestWithBody(server string, params *UploadDocumentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DocumentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "documentId", runtime.ParamLocationQuery, *params.DocumentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadMultipleDocumentsRequestWithBody generates requests for UploadMultipleDocuments with any type of body
func NewUploadMultipleDocumentsRequestWithBody(server string, params *UploadMultipleDocumentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/batch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDocumentRequest generates requests for DeleteDocument
func NewDeleteDocumentRequest(server string, documentId string, params *DeleteDocumentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "documentId", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadDocumentRequest generates requests for DownloadDocument
func NewDownloadDocumentRequest(server string, documentId string, params *DownloadDocumentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "documentId", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentHash", runtime.ParamLocationQuery, *params.ContentHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDocumentLinkRequest calls the generic CreateDocumentLink builder with application/json body
func NewCreateDocumentLinkRequest(server string, documentId string, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDocumentLinkRequestWithBody(server, documentId, params, "application/json", bodyReader)
}

// NewCreateDocumentLinkRequestWithBody generates requests for CreateDocumentLink with any type of body
func NewCreateDocumentLinkRequestWithBody(server string, documentId string, params *CreateDocumentLinkParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "documentId", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/%s/links", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentHash", runtime.ParamLocationQuery, *params.ContentHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateElementInstanceVariablesRequest calls the generic UpdateElementInstanceVariables builder with application/json body
func NewUpdateElementInstanceVariablesRequest(server string, elementInstanceKey string, body UpdateElementInstanceVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateElementInstanceVariablesRequestWithBody(server, elementInstanceKey, "application/json", bodyReader)
}

// NewUpdateElementInstanceVariablesRequestWithBody generates requests for UpdateElementInstanceVariables with any type of body
func NewUpdateElementInstanceVariablesRequestWithBody(server string, elementInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elementInstanceKey", runtime.ParamLocationPath, elementInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/element-instances/%s/variables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryFlowNodeInstancesAlphaRequest calls the generic QueryFlowNodeInstancesAlpha builder with application/json body
func NewQueryFlowNodeInstancesAlphaRequest(server string, body QueryFlowNodeInstancesAlphaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryFlowNodeInstancesAlphaRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryFlowNodeInstancesAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic QueryFlowNodeInstancesAlpha builder with application/vnd.camunda.api.keys.number+json body
func NewQueryFlowNodeInstancesAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, body QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryFlowNodeInstancesAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewQueryFlowNodeInstancesAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic QueryFlowNodeInstancesAlpha builder with application/vnd.camunda.api.keys.string+json body
func NewQueryFlowNodeInstancesAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, body QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryFlowNodeInstancesAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewQueryFlowNodeInstancesAlphaRequestWithBody generates requests for QueryFlowNodeInstancesAlpha with any type of body
func NewQueryFlowNodeInstancesAlphaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flownode-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryIncidentsAlphaRequest calls the generic QueryIncidentsAlpha builder with application/json body
func NewQueryIncidentsAlphaRequest(server string, body QueryIncidentsAlphaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryIncidentsAlphaRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryIncidentsAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic QueryIncidentsAlpha builder with application/vnd.camunda.api.keys.number+json body
func NewQueryIncidentsAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, body QueryIncidentsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryIncidentsAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewQueryIncidentsAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic QueryIncidentsAlpha builder with application/vnd.camunda.api.keys.string+json body
func NewQueryIncidentsAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, body QueryIncidentsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryIncidentsAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewQueryIncidentsAlphaRequestWithBody generates requests for QueryIncidentsAlpha with any type of body
func NewQueryIncidentsAlphaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIncidentByKeyAlphaRequest generates requests for GetIncidentByKeyAlpha
func NewGetIncidentByKeyAlphaRequest(server string, incidentKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "incidentKey", runtime.ParamLocationPath, incidentKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResolveIncidentRequest generates requests for ResolveIncident
func NewResolveIncidentRequest(server string, incidentKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "incidentKey", runtime.ParamLocationPath, incidentKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/%s/resolution", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivateJobsRequest calls the generic ActivateJobs builder with application/json body
func NewActivateJobsRequest(server string, body ActivateJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewActivateJobsRequestWithBody generates requests for ActivateJobs with any type of body
func NewActivateJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/activation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAJobRequest calls the generic UpdateAJob builder with application/json body
func NewUpdateAJobRequest(server string, jobKey string, body UpdateAJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewUpdateAJobRequestWithBody generates requests for UpdateAJob with any type of body
func NewUpdateAJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompleteJobRequest calls the generic CompleteJob builder with application/json body
func NewCompleteJobRequest(server string, jobKey string, body CompleteJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompleteJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewCompleteJobRequestWithBody generates requests for CompleteJob with any type of body
func NewCompleteJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/completion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewThrowErrorForJobRequest calls the generic ThrowErrorForJob builder with application/json body
func NewThrowErrorForJobRequest(server string, jobKey string, body ThrowErrorForJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewThrowErrorForJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewThrowErrorForJobRequestWithBody generates requests for ThrowErrorForJob with any type of body
func NewThrowErrorForJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/error", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFailJobRequest calls the generic FailJob builder with application/json body
func NewFailJobRequest(server string, jobKey string, body FailJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFailJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewFailJobRequestWithBody generates requests for FailJob with any type of body
func NewFailJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/failure", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStatusOfCamundaLicenseRequest generates requests for GetStatusOfCamundaLicense
func NewGetStatusOfCamundaLicenseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCorrelateAMessageRequest calls the generic CorrelateAMessage builder with application/json body
func NewCorrelateAMessageRequest(server string, body CorrelateAMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCorrelateAMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewCorrelateAMessageRequestWithBody generates requests for CorrelateAMessage with any type of body
func NewCorrelateAMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/correlation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPublishAMessageRequest calls the generic PublishAMessage builder with application/json body
func NewPublishAMessageRequest(server string, body PublishAMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishAMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewPublishAMessageRequestWithBody generates requests for PublishAMessage with any type of body
func NewPublishAMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/publication")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateProcessInstanceRequest calls the generic CreateProcessInstance builder with application/json body
func NewCreateProcessInstanceRequest(server string, body CreateProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProcessInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProcessInstanceRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic CreateProcessInstance builder with application/vnd.camunda.api.keys.number+json body
func NewCreateProcessInstanceRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, body CreateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProcessInstanceRequestWithBody(server, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewCreateProcessInstanceRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic CreateProcessInstance builder with application/vnd.camunda.api.keys.string+json body
func NewCreateProcessInstanceRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, body CreateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProcessInstanceRequestWithBody(server, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewCreateProcessInstanceRequestWithBody generates requests for CreateProcessInstance with any type of body
func NewCreateProcessInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryProcessInstancesAlphaRequest calls the generic QueryProcessInstancesAlpha builder with application/json body
func NewQueryProcessInstancesAlphaRequest(server string, body QueryProcessInstancesAlphaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryProcessInstancesAlphaRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryProcessInstancesAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic QueryProcessInstancesAlpha builder with application/vnd.camunda.api.keys.number+json body
func NewQueryProcessInstancesAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, body QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryProcessInstancesAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewQueryProcessInstancesAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic QueryProcessInstancesAlpha builder with application/vnd.camunda.api.keys.string+json body
func NewQueryProcessInstancesAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, body QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryProcessInstancesAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewQueryProcessInstancesAlphaRequestWithBody generates requests for QueryProcessInstancesAlpha with any type of body
func NewQueryProcessInstancesAlphaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelProcessInstanceRequest calls the generic CancelProcessInstance builder with application/json body
func NewCancelProcessInstanceRequest(server string, processInstanceKey string, body CancelProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelProcessInstanceRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewCancelProcessInstanceRequestWithBody generates requests for CancelProcessInstance with any type of body
func NewCancelProcessInstanceRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/cancellation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrateProcessInstanceRequest calls the generic MigrateProcessInstance builder with application/json body
func NewMigrateProcessInstanceRequest(server string, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateProcessInstanceRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewMigrateProcessInstanceRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic MigrateProcessInstance builder with application/vnd.camunda.api.keys.number+json body
func NewMigrateProcessInstanceRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, processInstanceKey string, body MigrateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateProcessInstanceRequestWithBody(server, processInstanceKey, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewMigrateProcessInstanceRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic MigrateProcessInstance builder with application/vnd.camunda.api.keys.string+json body
func NewMigrateProcessInstanceRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, processInstanceKey string, body MigrateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateProcessInstanceRequestWithBody(server, processInstanceKey, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewMigrateProcessInstanceRequestWithBody generates requests for MigrateProcessInstance with any type of body
func NewMigrateProcessInstanceRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/migration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModifyProcessInstanceRequest calls the generic ModifyProcessInstance builder with application/json body
func NewModifyProcessInstanceRequest(server string, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyProcessInstanceRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewModifyProcessInstanceRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic ModifyProcessInstance builder with application/vnd.camunda.api.keys.number+json body
func NewModifyProcessInstanceRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, processInstanceKey string, body ModifyProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyProcessInstanceRequestWithBody(server, processInstanceKey, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewModifyProcessInstanceRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic ModifyProcessInstance builder with application/vnd.camunda.api.keys.string+json body
func NewModifyProcessInstanceRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, processInstanceKey string, body ModifyProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyProcessInstanceRequestWithBody(server, processInstanceKey, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewModifyProcessInstanceRequestWithBody generates requests for ModifyProcessInstance with any type of body
func NewModifyProcessInstanceRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/modification", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, resourceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceKey", runtime.ParamLocationPath, resourceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceContentRequest generates requests for GetResourceContent
func NewGetResourceContentRequest(server string, resourceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceKey", runtime.ParamLocationPath, resourceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteResourceRequest calls the generic DeleteResource builder with application/json body
func NewDeleteResourceRequest(server string, resourceKey string, body DeleteResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteResourceRequestWithBody(server, resourceKey, "application/json", bodyReader)
}

// NewDeleteResourceRequestWithBody generates requests for DeleteResource with any type of body
func NewDeleteResourceRequestWithBody(server string, resourceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceKey", runtime.ParamLocationPath, resourceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s/deletion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBroadcastSignalRequest calls the generic BroadcastSignal builder with application/json body
func NewBroadcastSignalRequest(server string, body BroadcastSignalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBroadcastSignalRequestWithBody(server, "application/json", bodyReader)
}

// NewBroadcastSignalRequestWithBody generates requests for BroadcastSignal with any type of body
func NewBroadcastSignalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/signals/broadcast")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterTopologyRequest generates requests for GetClusterTopology
func NewGetClusterTopologyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/topology")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryUserTasksAlphaRequest calls the generic QueryUserTasksAlpha builder with application/json body
func NewQueryUserTasksAlphaRequest(server string, body QueryUserTasksAlphaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryUserTasksAlphaRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryUserTasksAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody calls the generic QueryUserTasksAlpha builder with application/vnd.camunda.api.keys.number+json body
func NewQueryUserTasksAlphaRequestWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(server string, body QueryUserTasksAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryUserTasksAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.number+json", bodyReader)
}

// NewQueryUserTasksAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody calls the generic QueryUserTasksAlpha builder with application/vnd.camunda.api.keys.string+json body
func NewQueryUserTasksAlphaRequestWithApplicationVndCamundaAPIKeysStringPlusJSONBody(server string, body QueryUserTasksAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryUserTasksAlphaRequestWithBody(server, "application/vnd.camunda.api.keys.string+json", bodyReader)
}

// NewQueryUserTasksAlphaRequestWithBody generates requests for QueryUserTasksAlpha with any type of body
func NewQueryUserTasksAlphaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateUserTaskRequest calls the generic UpdateUserTask builder with application/json body
func NewUpdateUserTaskRequest(server string, userTaskKey string, body UpdateUserTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserTaskRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewUpdateUserTaskRequestWithBody generates requests for UpdateUserTask with any type of body
func NewUpdateUserTaskRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignUserTaskRequest generates requests for UnassignUserTask
func NewUnassignUserTaskRequest(server string, userTaskKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/assignee", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignUserTaskRequest calls the generic AssignUserTask builder with application/json body
func NewAssignUserTaskRequest(server string, userTaskKey string, body AssignUserTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignUserTaskRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewAssignUserTaskRequestWithBody generates requests for AssignUserTask with any type of body
func NewAssignUserTaskRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/assignment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompleteUserTaskRequest calls the generic CompleteUserTask builder with application/json body
func NewCompleteUserTaskRequest(server string, userTaskKey string, body CompleteUserTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompleteUserTaskRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewCompleteUserTaskRequestWithBody generates requests for CompleteUserTask with any type of body
func NewCompleteUserTaskRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/completion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PinInternalClockAlphaWithBodyWithResponse request with any body
	PinInternalClockAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PinInternalClockAlphaResponse, error)

	PinInternalClockAlphaWithResponse(ctx context.Context, body PinInternalClockAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*PinInternalClockAlphaResponse, error)

	// ResetInternalClockAlphaWithResponse request
	ResetInternalClockAlphaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetInternalClockAlphaResponse, error)

	// EvaluateDecisionWithBodyWithResponse request with any body
	EvaluateDecisionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error)

	EvaluateDecisionWithResponse(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error)

	EvaluateDecisionWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body EvaluateDecisionApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error)

	EvaluateDecisionWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body EvaluateDecisionApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error)

	// QueryDecisionDefinitionsAlphaWithBodyWithResponse request with any body
	QueryDecisionDefinitionsAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryDecisionDefinitionsAlphaResponse, error)

	QueryDecisionDefinitionsAlphaWithResponse(ctx context.Context, body QueryDecisionDefinitionsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionDefinitionsAlphaResponse, error)

	QueryDecisionDefinitionsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionDefinitionsAlphaResponse, error)

	QueryDecisionDefinitionsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionDefinitionsAlphaResponse, error)

	// GetDecisionDefinitionXmlAlphaWithResponse request
	GetDecisionDefinitionXmlAlphaWithResponse(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionXmlAlphaResponse, error)

	// QueryDecisionInstancesAlphaWithBodyWithResponse request with any body
	QueryDecisionInstancesAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryDecisionInstancesAlphaResponse, error)

	QueryDecisionInstancesAlphaWithResponse(ctx context.Context, body QueryDecisionInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionInstancesAlphaResponse, error)

	QueryDecisionInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionInstancesAlphaResponse, error)

	QueryDecisionInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionInstancesAlphaResponse, error)

	// QueryDecisionRequirementsAlphaWithBodyWithResponse request with any body
	QueryDecisionRequirementsAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryDecisionRequirementsAlphaResponse, error)

	QueryDecisionRequirementsAlphaWithResponse(ctx context.Context, body QueryDecisionRequirementsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionRequirementsAlphaResponse, error)

	QueryDecisionRequirementsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionRequirementsAlphaResponse, error)

	QueryDecisionRequirementsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionRequirementsAlphaResponse, error)

	// DeployResourcesWithBodyWithResponse request with any body
	DeployResourcesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployResourcesResponse, error)

	// UploadDocumentWithBodyWithResponse request with any body
	UploadDocumentWithBodyWithResponse(ctx context.Context, params *UploadDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadDocumentResponse, error)

	// UploadMultipleDocumentsWithBodyWithResponse request with any body
	UploadMultipleDocumentsWithBodyWithResponse(ctx context.Context, params *UploadMultipleDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadMultipleDocumentsResponse, error)

	// DeleteDocumentWithResponse request
	DeleteDocumentWithResponse(ctx context.Context, documentId string, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*DeleteDocumentResponse, error)

	// DownloadDocumentWithResponse request
	DownloadDocumentWithResponse(ctx context.Context, documentId string, params *DownloadDocumentParams, reqEditors ...RequestEditorFn) (*DownloadDocumentResponse, error)

	// CreateDocumentLinkWithBodyWithResponse request with any body
	CreateDocumentLinkWithBodyWithResponse(ctx context.Context, documentId string, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error)

	CreateDocumentLinkWithResponse(ctx context.Context, documentId string, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error)

	// UpdateElementInstanceVariablesWithBodyWithResponse request with any body
	UpdateElementInstanceVariablesWithBodyWithResponse(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateElementInstanceVariablesResponse, error)

	UpdateElementInstanceVariablesWithResponse(ctx context.Context, elementInstanceKey string, body UpdateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateElementInstanceVariablesResponse, error)

	// QueryFlowNodeInstancesAlphaWithBodyWithResponse request with any body
	QueryFlowNodeInstancesAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryFlowNodeInstancesAlphaResponse, error)

	QueryFlowNodeInstancesAlphaWithResponse(ctx context.Context, body QueryFlowNodeInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryFlowNodeInstancesAlphaResponse, error)

	QueryFlowNodeInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryFlowNodeInstancesAlphaResponse, error)

	QueryFlowNodeInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryFlowNodeInstancesAlphaResponse, error)

	// QueryIncidentsAlphaWithBodyWithResponse request with any body
	QueryIncidentsAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryIncidentsAlphaResponse, error)

	QueryIncidentsAlphaWithResponse(ctx context.Context, body QueryIncidentsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryIncidentsAlphaResponse, error)

	QueryIncidentsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryIncidentsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryIncidentsAlphaResponse, error)

	QueryIncidentsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryIncidentsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryIncidentsAlphaResponse, error)

	// GetIncidentByKeyAlphaWithResponse request
	GetIncidentByKeyAlphaWithResponse(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*GetIncidentByKeyAlphaResponse, error)

	// ResolveIncidentWithResponse request
	ResolveIncidentWithResponse(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*ResolveIncidentResponse, error)

	// ActivateJobsWithBodyWithResponse request with any body
	ActivateJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error)

	ActivateJobsWithResponse(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error)

	// UpdateAJobWithBodyWithResponse request with any body
	UpdateAJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAJobResponse, error)

	UpdateAJobWithResponse(ctx context.Context, jobKey string, body UpdateAJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAJobResponse, error)

	// CompleteJobWithBodyWithResponse request with any body
	CompleteJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error)

	CompleteJobWithResponse(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error)

	// ThrowErrorForJobWithBodyWithResponse request with any body
	ThrowErrorForJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ThrowErrorForJobResponse, error)

	ThrowErrorForJobWithResponse(ctx context.Context, jobKey string, body ThrowErrorForJobJSONRequestBody, reqEditors ...RequestEditorFn) (*ThrowErrorForJobResponse, error)

	// FailJobWithBodyWithResponse request with any body
	FailJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FailJobResponse, error)

	FailJobWithResponse(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*FailJobResponse, error)

	// GetStatusOfCamundaLicenseWithResponse request
	GetStatusOfCamundaLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusOfCamundaLicenseResponse, error)

	// CorrelateAMessageWithBodyWithResponse request with any body
	CorrelateAMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CorrelateAMessageResponse, error)

	CorrelateAMessageWithResponse(ctx context.Context, body CorrelateAMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CorrelateAMessageResponse, error)

	// PublishAMessageWithBodyWithResponse request with any body
	PublishAMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishAMessageResponse, error)

	PublishAMessageWithResponse(ctx context.Context, body PublishAMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishAMessageResponse, error)

	// CreateProcessInstanceWithBodyWithResponse request with any body
	CreateProcessInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error)

	CreateProcessInstanceWithResponse(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error)

	CreateProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body CreateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error)

	CreateProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body CreateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error)

	// QueryProcessInstancesAlphaWithBodyWithResponse request with any body
	QueryProcessInstancesAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryProcessInstancesAlphaResponse, error)

	QueryProcessInstancesAlphaWithResponse(ctx context.Context, body QueryProcessInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryProcessInstancesAlphaResponse, error)

	QueryProcessInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryProcessInstancesAlphaResponse, error)

	QueryProcessInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryProcessInstancesAlphaResponse, error)

	// CancelProcessInstanceWithBodyWithResponse request with any body
	CancelProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error)

	CancelProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error)

	// MigrateProcessInstanceWithBodyWithResponse request with any body
	MigrateProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error)

	MigrateProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error)

	MigrateProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error)

	MigrateProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error)

	// ModifyProcessInstanceWithBodyWithResponse request with any body
	ModifyProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error)

	ModifyProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error)

	ModifyProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error)

	ModifyProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, resourceKey string, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetResourceContentWithResponse request
	GetResourceContentWithResponse(ctx context.Context, resourceKey string, reqEditors ...RequestEditorFn) (*GetResourceContentResponse, error)

	// DeleteResourceWithBodyWithResponse request with any body
	DeleteResourceWithBodyWithResponse(ctx context.Context, resourceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	DeleteResourceWithResponse(ctx context.Context, resourceKey string, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	// BroadcastSignalWithBodyWithResponse request with any body
	BroadcastSignalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error)

	BroadcastSignalWithResponse(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error)

	// GetClusterTopologyWithResponse request
	GetClusterTopologyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterTopologyResponse, error)

	// QueryUserTasksAlphaWithBodyWithResponse request with any body
	QueryUserTasksAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryUserTasksAlphaResponse, error)

	QueryUserTasksAlphaWithResponse(ctx context.Context, body QueryUserTasksAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryUserTasksAlphaResponse, error)

	QueryUserTasksAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryUserTasksAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryUserTasksAlphaResponse, error)

	QueryUserTasksAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryUserTasksAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryUserTasksAlphaResponse, error)

	// UpdateUserTaskWithBodyWithResponse request with any body
	UpdateUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error)

	UpdateUserTaskWithResponse(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error)

	// UnassignUserTaskWithResponse request
	UnassignUserTaskWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*UnassignUserTaskResponse, error)

	// AssignUserTaskWithBodyWithResponse request with any body
	AssignUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error)

	AssignUserTaskWithResponse(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error)

	// CompleteUserTaskWithBodyWithResponse request with any body
	CompleteUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error)

	CompleteUserTaskWithResponse(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error)
}

type PinInternalClockAlphaResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r PinInternalClockAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PinInternalClockAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetInternalClockAlphaResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ResetInternalClockAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetInternalClockAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EvaluateDecisionResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *EvaluateDecisionResult
	ApplicationvndCamundaApiKeysNumberJSON200 *EvaluateDecisionResponse
	ApplicationvndCamundaApiKeysStringJSON200 *EvaluateDecisionResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON404                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r EvaluateDecisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EvaluateDecisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryDecisionDefinitionsAlphaResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *DecisionDefinitionSearchQueryResult
	ApplicationvndCamundaApiKeysNumberJSON200 *DecisionDefinitionSearchQueryResponse
	ApplicationvndCamundaApiKeysStringJSON200 *DecisionDefinitionSearchQueryResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r QueryDecisionDefinitionsAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryDecisionDefinitionsAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionDefinitionXmlAlphaResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r GetDecisionDefinitionXmlAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionDefinitionXmlAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryDecisionInstancesAlphaResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *DecisionInstanceSearchQueryResult
	ApplicationvndCamundaApiKeysNumberJSON200 *DecisionInstanceSearchQueryResponse
	ApplicationvndCamundaApiKeysStringJSON200 *DecisionInstanceSearchQueryResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r QueryDecisionInstancesAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryDecisionInstancesAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryDecisionRequirementsAlphaResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *DecisionRequirementsSearchQueryResult
	ApplicationvndCamundaApiKeysNumberJSON200 *DecisionRequirementsSearchQueryResponse
	ApplicationvndCamundaApiKeysStringJSON200 *DecisionRequirementsSearchQueryResult
}

// Status returns HTTPResponse.Status
func (r QueryDecisionRequirementsAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryDecisionRequirementsAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeployResourcesResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *DeploymentResult
	ApplicationvndCamundaApiKeysNumberJSON200 *DeploymentResponse
	ApplicationvndCamundaApiKeysStringJSON200 *DeploymentResult
	ApplicationproblemJSON400                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r DeployResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeployResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadDocumentResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON201                                   *DocumentReference
	ApplicationvndCamundaApiKeysNumberJSON201 *DocumentReferenceResult
	ApplicationvndCamundaApiKeysStringJSON201 *DocumentReference
	ApplicationproblemJSON400                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r UploadDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadMultipleDocumentsResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON201                                   *DocumentCreationBatchResponse
	ApplicationvndCamundaApiKeysNumberJSON201 *DocumentCreationBatchResult
	ApplicationvndCamundaApiKeysStringJSON201 *DocumentCreationBatchResponse
	JSON207                                   *DocumentCreationBatchResponse
	ApplicationvndCamundaApiKeysNumberJSON207 *DocumentCreationBatchResult
	ApplicationvndCamundaApiKeysStringJSON207 *DocumentCreationBatchResponse
	ApplicationproblemJSON400                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r UploadMultipleDocumentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadMultipleDocumentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDocumentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadDocumentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DownloadDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDocumentLinkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *DocumentLink
	ApplicationproblemJSON400 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CreateDocumentLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDocumentLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateElementInstanceVariablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r UpdateElementInstanceVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateElementInstanceVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryFlowNodeInstancesAlphaResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *FlowNodeInstanceSearchQueryResult
	ApplicationvndCamundaApiKeysNumberJSON200 *FlowNodeInstanceSearchQueryResponse
	ApplicationvndCamundaApiKeysStringJSON200 *FlowNodeInstanceSearchQueryResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r QueryFlowNodeInstancesAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryFlowNodeInstancesAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryIncidentsAlphaResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *IncidentSearchQueryResult
	ApplicationvndCamundaApiKeysNumberJSON200 *IncidentSearchQueryResponse
	ApplicationvndCamundaApiKeysStringJSON200 *IncidentSearchQueryResult
	ApplicationproblemJSON401                 *ProblemDetail
	ApplicationproblemJSON403                 *ProblemDetail
	ApplicationproblemJSON404                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r QueryIncidentsAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryIncidentsAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncidentByKeyAlphaResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *IncidentResult
	ApplicationvndCamundaApiKeysNumberJSON200 *IncidentItem
	ApplicationvndCamundaApiKeysStringJSON200 *IncidentResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON404                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r GetIncidentByKeyAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncidentByKeyAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveIncidentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ResolveIncidentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveIncidentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateJobsResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *JobActivationResult
	ApplicationvndCamundaApiKeysNumberJSON200 *JobActivationResponse
	ApplicationvndCamundaApiKeysStringJSON200 *JobActivationResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ActivateJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r UpdateAJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CompleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThrowErrorForJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ThrowErrorForJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThrowErrorForJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FailJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r FailJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FailJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusOfCamundaLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LicenseResponse
}

// Status returns HTTPResponse.Status
func (r GetStatusOfCamundaLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusOfCamundaLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CorrelateAMessageResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *MessageCorrelationResult
	ApplicationvndCamundaApiKeysNumberJSON200 *MessageCorrelationResponse
	ApplicationvndCamundaApiKeysStringJSON200 *MessageCorrelationResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON403                 *ProblemDetail
	ApplicationproblemJSON404                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CorrelateAMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CorrelateAMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishAMessageResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *MessagePublicationResult
	ApplicationvndCamundaApiKeysNumberJSON200 *MessagePublicationResponse
	ApplicationvndCamundaApiKeysStringJSON200 *MessagePublicationResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r PublishAMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishAMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProcessInstanceResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *CreateProcessInstanceResult
	ApplicationvndCamundaApiKeysNumberJSON200 *CreateProcessInstanceResponse
	ApplicationvndCamundaApiKeysStringJSON200 *CreateProcessInstanceResult
	ApplicationproblemJSON500                 *ProblemDetail
	ApplicationproblemJSON504                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CreateProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryProcessInstancesAlphaResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *ProcessInstanceSearchQueryResult
	ApplicationvndCamundaApiKeysNumberJSON200 *ProcessInstanceSearchQueryResponse
	ApplicationvndCamundaApiKeysStringJSON200 *ProcessInstanceSearchQueryResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r QueryProcessInstancesAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryProcessInstancesAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CancelProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r MigrateProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ModifyProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourceResult
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceContentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *string
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r GetResourceContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r DeleteResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BroadcastSignalResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *SignalBroadcastResult
	ApplicationvndCamundaApiKeysNumberJSON200 *SignalBroadcastResponse
	ApplicationvndCamundaApiKeysStringJSON200 *SignalBroadcastResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON404                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r BroadcastSignalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BroadcastSignalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterTopologyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TopologyResponse
}

// Status returns HTTPResponse.Status
func (r GetClusterTopologyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterTopologyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryUserTasksAlphaResponse struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *UserTaskSearchQueryResult
	ApplicationvndCamundaApiKeysNumberJSON200 *UserTaskSearchQueryResponse
	ApplicationvndCamundaApiKeysStringJSON200 *UserTaskSearchQueryResult
	ApplicationproblemJSON400                 *ProblemDetail
	ApplicationproblemJSON500                 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r QueryUserTasksAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryUserTasksAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r UpdateUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r UnassignUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r AssignUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CompleteUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PinInternalClockAlphaWithBodyWithResponse request with arbitrary body returning *PinInternalClockAlphaResponse
func (c *ClientWithResponses) PinInternalClockAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PinInternalClockAlphaResponse, error) {
	rsp, err := c.PinInternalClockAlphaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePinInternalClockAlphaResponse(rsp)
}

func (c *ClientWithResponses) PinInternalClockAlphaWithResponse(ctx context.Context, body PinInternalClockAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*PinInternalClockAlphaResponse, error) {
	rsp, err := c.PinInternalClockAlpha(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePinInternalClockAlphaResponse(rsp)
}

// ResetInternalClockAlphaWithResponse request returning *ResetInternalClockAlphaResponse
func (c *ClientWithResponses) ResetInternalClockAlphaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetInternalClockAlphaResponse, error) {
	rsp, err := c.ResetInternalClockAlpha(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetInternalClockAlphaResponse(rsp)
}

// EvaluateDecisionWithBodyWithResponse request with arbitrary body returning *EvaluateDecisionResponse
func (c *ClientWithResponses) EvaluateDecisionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error) {
	rsp, err := c.EvaluateDecisionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateDecisionResponse(rsp)
}

func (c *ClientWithResponses) EvaluateDecisionWithResponse(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error) {
	rsp, err := c.EvaluateDecision(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateDecisionResponse(rsp)
}

func (c *ClientWithResponses) EvaluateDecisionWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body EvaluateDecisionApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error) {
	rsp, err := c.EvaluateDecisionWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateDecisionResponse(rsp)
}

func (c *ClientWithResponses) EvaluateDecisionWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body EvaluateDecisionApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error) {
	rsp, err := c.EvaluateDecisionWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateDecisionResponse(rsp)
}

// QueryDecisionDefinitionsAlphaWithBodyWithResponse request with arbitrary body returning *QueryDecisionDefinitionsAlphaResponse
func (c *ClientWithResponses) QueryDecisionDefinitionsAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryDecisionDefinitionsAlphaResponse, error) {
	rsp, err := c.QueryDecisionDefinitionsAlphaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionDefinitionsAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryDecisionDefinitionsAlphaWithResponse(ctx context.Context, body QueryDecisionDefinitionsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionDefinitionsAlphaResponse, error) {
	rsp, err := c.QueryDecisionDefinitionsAlpha(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionDefinitionsAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryDecisionDefinitionsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionDefinitionsAlphaResponse, error) {
	rsp, err := c.QueryDecisionDefinitionsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionDefinitionsAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryDecisionDefinitionsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionDefinitionsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionDefinitionsAlphaResponse, error) {
	rsp, err := c.QueryDecisionDefinitionsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionDefinitionsAlphaResponse(rsp)
}

// GetDecisionDefinitionXmlAlphaWithResponse request returning *GetDecisionDefinitionXmlAlphaResponse
func (c *ClientWithResponses) GetDecisionDefinitionXmlAlphaWithResponse(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionXmlAlphaResponse, error) {
	rsp, err := c.GetDecisionDefinitionXmlAlpha(ctx, decisionDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionDefinitionXmlAlphaResponse(rsp)
}

// QueryDecisionInstancesAlphaWithBodyWithResponse request with arbitrary body returning *QueryDecisionInstancesAlphaResponse
func (c *ClientWithResponses) QueryDecisionInstancesAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryDecisionInstancesAlphaResponse, error) {
	rsp, err := c.QueryDecisionInstancesAlphaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionInstancesAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryDecisionInstancesAlphaWithResponse(ctx context.Context, body QueryDecisionInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionInstancesAlphaResponse, error) {
	rsp, err := c.QueryDecisionInstancesAlpha(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionInstancesAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryDecisionInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionInstancesAlphaResponse, error) {
	rsp, err := c.QueryDecisionInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionInstancesAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryDecisionInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionInstancesAlphaResponse, error) {
	rsp, err := c.QueryDecisionInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionInstancesAlphaResponse(rsp)
}

// QueryDecisionRequirementsAlphaWithBodyWithResponse request with arbitrary body returning *QueryDecisionRequirementsAlphaResponse
func (c *ClientWithResponses) QueryDecisionRequirementsAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryDecisionRequirementsAlphaResponse, error) {
	rsp, err := c.QueryDecisionRequirementsAlphaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionRequirementsAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryDecisionRequirementsAlphaWithResponse(ctx context.Context, body QueryDecisionRequirementsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionRequirementsAlphaResponse, error) {
	rsp, err := c.QueryDecisionRequirementsAlpha(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionRequirementsAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryDecisionRequirementsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionRequirementsAlphaResponse, error) {
	rsp, err := c.QueryDecisionRequirementsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionRequirementsAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryDecisionRequirementsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryDecisionRequirementsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryDecisionRequirementsAlphaResponse, error) {
	rsp, err := c.QueryDecisionRequirementsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDecisionRequirementsAlphaResponse(rsp)
}

// DeployResourcesWithBodyWithResponse request with arbitrary body returning *DeployResourcesResponse
func (c *ClientWithResponses) DeployResourcesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployResourcesResponse, error) {
	rsp, err := c.DeployResourcesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployResourcesResponse(rsp)
}

// UploadDocumentWithBodyWithResponse request with arbitrary body returning *UploadDocumentResponse
func (c *ClientWithResponses) UploadDocumentWithBodyWithResponse(ctx context.Context, params *UploadDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadDocumentResponse, error) {
	rsp, err := c.UploadDocumentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadDocumentResponse(rsp)
}

// UploadMultipleDocumentsWithBodyWithResponse request with arbitrary body returning *UploadMultipleDocumentsResponse
func (c *ClientWithResponses) UploadMultipleDocumentsWithBodyWithResponse(ctx context.Context, params *UploadMultipleDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadMultipleDocumentsResponse, error) {
	rsp, err := c.UploadMultipleDocumentsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadMultipleDocumentsResponse(rsp)
}

// DeleteDocumentWithResponse request returning *DeleteDocumentResponse
func (c *ClientWithResponses) DeleteDocumentWithResponse(ctx context.Context, documentId string, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*DeleteDocumentResponse, error) {
	rsp, err := c.DeleteDocument(ctx, documentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDocumentResponse(rsp)
}

// DownloadDocumentWithResponse request returning *DownloadDocumentResponse
func (c *ClientWithResponses) DownloadDocumentWithResponse(ctx context.Context, documentId string, params *DownloadDocumentParams, reqEditors ...RequestEditorFn) (*DownloadDocumentResponse, error) {
	rsp, err := c.DownloadDocument(ctx, documentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadDocumentResponse(rsp)
}

// CreateDocumentLinkWithBodyWithResponse request with arbitrary body returning *CreateDocumentLinkResponse
func (c *ClientWithResponses) CreateDocumentLinkWithBodyWithResponse(ctx context.Context, documentId string, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error) {
	rsp, err := c.CreateDocumentLinkWithBody(ctx, documentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocumentLinkResponse(rsp)
}

func (c *ClientWithResponses) CreateDocumentLinkWithResponse(ctx context.Context, documentId string, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error) {
	rsp, err := c.CreateDocumentLink(ctx, documentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocumentLinkResponse(rsp)
}

// UpdateElementInstanceVariablesWithBodyWithResponse request with arbitrary body returning *UpdateElementInstanceVariablesResponse
func (c *ClientWithResponses) UpdateElementInstanceVariablesWithBodyWithResponse(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateElementInstanceVariablesResponse, error) {
	rsp, err := c.UpdateElementInstanceVariablesWithBody(ctx, elementInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateElementInstanceVariablesResponse(rsp)
}

func (c *ClientWithResponses) UpdateElementInstanceVariablesWithResponse(ctx context.Context, elementInstanceKey string, body UpdateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateElementInstanceVariablesResponse, error) {
	rsp, err := c.UpdateElementInstanceVariables(ctx, elementInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateElementInstanceVariablesResponse(rsp)
}

// QueryFlowNodeInstancesAlphaWithBodyWithResponse request with arbitrary body returning *QueryFlowNodeInstancesAlphaResponse
func (c *ClientWithResponses) QueryFlowNodeInstancesAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryFlowNodeInstancesAlphaResponse, error) {
	rsp, err := c.QueryFlowNodeInstancesAlphaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryFlowNodeInstancesAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryFlowNodeInstancesAlphaWithResponse(ctx context.Context, body QueryFlowNodeInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryFlowNodeInstancesAlphaResponse, error) {
	rsp, err := c.QueryFlowNodeInstancesAlpha(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryFlowNodeInstancesAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryFlowNodeInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryFlowNodeInstancesAlphaResponse, error) {
	rsp, err := c.QueryFlowNodeInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryFlowNodeInstancesAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryFlowNodeInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryFlowNodeInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryFlowNodeInstancesAlphaResponse, error) {
	rsp, err := c.QueryFlowNodeInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryFlowNodeInstancesAlphaResponse(rsp)
}

// QueryIncidentsAlphaWithBodyWithResponse request with arbitrary body returning *QueryIncidentsAlphaResponse
func (c *ClientWithResponses) QueryIncidentsAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryIncidentsAlphaResponse, error) {
	rsp, err := c.QueryIncidentsAlphaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryIncidentsAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryIncidentsAlphaWithResponse(ctx context.Context, body QueryIncidentsAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryIncidentsAlphaResponse, error) {
	rsp, err := c.QueryIncidentsAlpha(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryIncidentsAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryIncidentsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryIncidentsAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryIncidentsAlphaResponse, error) {
	rsp, err := c.QueryIncidentsAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryIncidentsAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryIncidentsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryIncidentsAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryIncidentsAlphaResponse, error) {
	rsp, err := c.QueryIncidentsAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryIncidentsAlphaResponse(rsp)
}

// GetIncidentByKeyAlphaWithResponse request returning *GetIncidentByKeyAlphaResponse
func (c *ClientWithResponses) GetIncidentByKeyAlphaWithResponse(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*GetIncidentByKeyAlphaResponse, error) {
	rsp, err := c.GetIncidentByKeyAlpha(ctx, incidentKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncidentByKeyAlphaResponse(rsp)
}

// ResolveIncidentWithResponse request returning *ResolveIncidentResponse
func (c *ClientWithResponses) ResolveIncidentWithResponse(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*ResolveIncidentResponse, error) {
	rsp, err := c.ResolveIncident(ctx, incidentKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveIncidentResponse(rsp)
}

// ActivateJobsWithBodyWithResponse request with arbitrary body returning *ActivateJobsResponse
func (c *ClientWithResponses) ActivateJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error) {
	rsp, err := c.ActivateJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateJobsResponse(rsp)
}

func (c *ClientWithResponses) ActivateJobsWithResponse(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error) {
	rsp, err := c.ActivateJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateJobsResponse(rsp)
}

// UpdateAJobWithBodyWithResponse request with arbitrary body returning *UpdateAJobResponse
func (c *ClientWithResponses) UpdateAJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAJobResponse, error) {
	rsp, err := c.UpdateAJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAJobResponse(rsp)
}

func (c *ClientWithResponses) UpdateAJobWithResponse(ctx context.Context, jobKey string, body UpdateAJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAJobResponse, error) {
	rsp, err := c.UpdateAJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAJobResponse(rsp)
}

// CompleteJobWithBodyWithResponse request with arbitrary body returning *CompleteJobResponse
func (c *ClientWithResponses) CompleteJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error) {
	rsp, err := c.CompleteJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteJobResponse(rsp)
}

func (c *ClientWithResponses) CompleteJobWithResponse(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error) {
	rsp, err := c.CompleteJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteJobResponse(rsp)
}

// ThrowErrorForJobWithBodyWithResponse request with arbitrary body returning *ThrowErrorForJobResponse
func (c *ClientWithResponses) ThrowErrorForJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ThrowErrorForJobResponse, error) {
	rsp, err := c.ThrowErrorForJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThrowErrorForJobResponse(rsp)
}

func (c *ClientWithResponses) ThrowErrorForJobWithResponse(ctx context.Context, jobKey string, body ThrowErrorForJobJSONRequestBody, reqEditors ...RequestEditorFn) (*ThrowErrorForJobResponse, error) {
	rsp, err := c.ThrowErrorForJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThrowErrorForJobResponse(rsp)
}

// FailJobWithBodyWithResponse request with arbitrary body returning *FailJobResponse
func (c *ClientWithResponses) FailJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FailJobResponse, error) {
	rsp, err := c.FailJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFailJobResponse(rsp)
}

func (c *ClientWithResponses) FailJobWithResponse(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*FailJobResponse, error) {
	rsp, err := c.FailJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFailJobResponse(rsp)
}

// GetStatusOfCamundaLicenseWithResponse request returning *GetStatusOfCamundaLicenseResponse
func (c *ClientWithResponses) GetStatusOfCamundaLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusOfCamundaLicenseResponse, error) {
	rsp, err := c.GetStatusOfCamundaLicense(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusOfCamundaLicenseResponse(rsp)
}

// CorrelateAMessageWithBodyWithResponse request with arbitrary body returning *CorrelateAMessageResponse
func (c *ClientWithResponses) CorrelateAMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CorrelateAMessageResponse, error) {
	rsp, err := c.CorrelateAMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCorrelateAMessageResponse(rsp)
}

func (c *ClientWithResponses) CorrelateAMessageWithResponse(ctx context.Context, body CorrelateAMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CorrelateAMessageResponse, error) {
	rsp, err := c.CorrelateAMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCorrelateAMessageResponse(rsp)
}

// PublishAMessageWithBodyWithResponse request with arbitrary body returning *PublishAMessageResponse
func (c *ClientWithResponses) PublishAMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishAMessageResponse, error) {
	rsp, err := c.PublishAMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishAMessageResponse(rsp)
}

func (c *ClientWithResponses) PublishAMessageWithResponse(ctx context.Context, body PublishAMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishAMessageResponse, error) {
	rsp, err := c.PublishAMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishAMessageResponse(rsp)
}

// CreateProcessInstanceWithBodyWithResponse request with arbitrary body returning *CreateProcessInstanceResponse
func (c *ClientWithResponses) CreateProcessInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error) {
	rsp, err := c.CreateProcessInstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) CreateProcessInstanceWithResponse(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error) {
	rsp, err := c.CreateProcessInstance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) CreateProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body CreateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error) {
	rsp, err := c.CreateProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) CreateProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body CreateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error) {
	rsp, err := c.CreateProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProcessInstanceResponse(rsp)
}

// QueryProcessInstancesAlphaWithBodyWithResponse request with arbitrary body returning *QueryProcessInstancesAlphaResponse
func (c *ClientWithResponses) QueryProcessInstancesAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryProcessInstancesAlphaResponse, error) {
	rsp, err := c.QueryProcessInstancesAlphaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryProcessInstancesAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryProcessInstancesAlphaWithResponse(ctx context.Context, body QueryProcessInstancesAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryProcessInstancesAlphaResponse, error) {
	rsp, err := c.QueryProcessInstancesAlpha(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryProcessInstancesAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryProcessInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryProcessInstancesAlphaResponse, error) {
	rsp, err := c.QueryProcessInstancesAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryProcessInstancesAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryProcessInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryProcessInstancesAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryProcessInstancesAlphaResponse, error) {
	rsp, err := c.QueryProcessInstancesAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryProcessInstancesAlphaResponse(rsp)
}

// CancelProcessInstanceWithBodyWithResponse request with arbitrary body returning *CancelProcessInstanceResponse
func (c *ClientWithResponses) CancelProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error) {
	rsp, err := c.CancelProcessInstanceWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) CancelProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error) {
	rsp, err := c.CancelProcessInstance(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelProcessInstanceResponse(rsp)
}

// MigrateProcessInstanceWithBodyWithResponse request with arbitrary body returning *MigrateProcessInstanceResponse
func (c *ClientWithResponses) MigrateProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error) {
	rsp, err := c.MigrateProcessInstanceWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) MigrateProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error) {
	rsp, err := c.MigrateProcessInstance(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) MigrateProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error) {
	rsp, err := c.MigrateProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) MigrateProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error) {
	rsp, err := c.MigrateProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateProcessInstanceResponse(rsp)
}

// ModifyProcessInstanceWithBodyWithResponse request with arbitrary body returning *ModifyProcessInstanceResponse
func (c *ClientWithResponses) ModifyProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error) {
	rsp, err := c.ModifyProcessInstanceWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) ModifyProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error) {
	rsp, err := c.ModifyProcessInstance(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) ModifyProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error) {
	rsp, err := c.ModifyProcessInstanceWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) ModifyProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error) {
	rsp, err := c.ModifyProcessInstanceWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProcessInstanceResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, resourceKey string, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, resourceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetResourceContentWithResponse request returning *GetResourceContentResponse
func (c *ClientWithResponses) GetResourceContentWithResponse(ctx context.Context, resourceKey string, reqEditors ...RequestEditorFn) (*GetResourceContentResponse, error) {
	rsp, err := c.GetResourceContent(ctx, resourceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceContentResponse(rsp)
}

// DeleteResourceWithBodyWithResponse request with arbitrary body returning *DeleteResourceResponse
func (c *ClientWithResponses) DeleteResourceWithBodyWithResponse(ctx context.Context, resourceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResourceWithBody(ctx, resourceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

func (c *ClientWithResponses) DeleteResourceWithResponse(ctx context.Context, resourceKey string, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResource(ctx, resourceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

// BroadcastSignalWithBodyWithResponse request with arbitrary body returning *BroadcastSignalResponse
func (c *ClientWithResponses) BroadcastSignalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error) {
	rsp, err := c.BroadcastSignalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBroadcastSignalResponse(rsp)
}

func (c *ClientWithResponses) BroadcastSignalWithResponse(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error) {
	rsp, err := c.BroadcastSignal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBroadcastSignalResponse(rsp)
}

// GetClusterTopologyWithResponse request returning *GetClusterTopologyResponse
func (c *ClientWithResponses) GetClusterTopologyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterTopologyResponse, error) {
	rsp, err := c.GetClusterTopology(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterTopologyResponse(rsp)
}

// QueryUserTasksAlphaWithBodyWithResponse request with arbitrary body returning *QueryUserTasksAlphaResponse
func (c *ClientWithResponses) QueryUserTasksAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryUserTasksAlphaResponse, error) {
	rsp, err := c.QueryUserTasksAlphaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryUserTasksAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryUserTasksAlphaWithResponse(ctx context.Context, body QueryUserTasksAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryUserTasksAlphaResponse, error) {
	rsp, err := c.QueryUserTasksAlpha(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryUserTasksAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryUserTasksAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBodyWithResponse(ctx context.Context, body QueryUserTasksAlphaApplicationVndCamundaAPIKeysNumberPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryUserTasksAlphaResponse, error) {
	rsp, err := c.QueryUserTasksAlphaWithApplicationVndCamundaAPIKeysNumberPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryUserTasksAlphaResponse(rsp)
}

func (c *ClientWithResponses) QueryUserTasksAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBodyWithResponse(ctx context.Context, body QueryUserTasksAlphaApplicationVndCamundaAPIKeysStringPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryUserTasksAlphaResponse, error) {
	rsp, err := c.QueryUserTasksAlphaWithApplicationVndCamundaAPIKeysStringPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryUserTasksAlphaResponse(rsp)
}

// UpdateUserTaskWithBodyWithResponse request with arbitrary body returning *UpdateUserTaskResponse
func (c *ClientWithResponses) UpdateUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error) {
	rsp, err := c.UpdateUserTaskWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserTaskWithResponse(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error) {
	rsp, err := c.UpdateUserTask(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserTaskResponse(rsp)
}

// UnassignUserTaskWithResponse request returning *UnassignUserTaskResponse
func (c *ClientWithResponses) UnassignUserTaskWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*UnassignUserTaskResponse, error) {
	rsp, err := c.UnassignUserTask(ctx, userTaskKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignUserTaskResponse(rsp)
}

// AssignUserTaskWithBodyWithResponse request with arbitrary body returning *AssignUserTaskResponse
func (c *ClientWithResponses) AssignUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error) {
	rsp, err := c.AssignUserTaskWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserTaskResponse(rsp)
}

func (c *ClientWithResponses) AssignUserTaskWithResponse(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error) {
	rsp, err := c.AssignUserTask(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserTaskResponse(rsp)
}

// CompleteUserTaskWithBodyWithResponse request with arbitrary body returning *CompleteUserTaskResponse
func (c *ClientWithResponses) CompleteUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error) {
	rsp, err := c.CompleteUserTaskWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteUserTaskResponse(rsp)
}

func (c *ClientWithResponses) CompleteUserTaskWithResponse(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error) {
	rsp, err := c.CompleteUserTask(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteUserTaskResponse(rsp)
}

// ParsePinInternalClockAlphaResponse parses an HTTP response from a PinInternalClockAlphaWithResponse call
func ParsePinInternalClockAlphaResponse(rsp *http.Response) (*PinInternalClockAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PinInternalClockAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseResetInternalClockAlphaResponse parses an HTTP response from a ResetInternalClockAlphaWithResponse call
func ParseResetInternalClockAlphaResponse(rsp *http.Response) (*ResetInternalClockAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetInternalClockAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseEvaluateDecisionResponse parses an HTTP response from a EvaluateDecisionWithResponse call
func ParseEvaluateDecisionResponse(rsp *http.Response) (*EvaluateDecisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EvaluateDecisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest EvaluateDecisionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest EvaluateDecisionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest EvaluateDecisionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseQueryDecisionDefinitionsAlphaResponse parses an HTTP response from a QueryDecisionDefinitionsAlphaWithResponse call
func ParseQueryDecisionDefinitionsAlphaResponse(rsp *http.Response) (*QueryDecisionDefinitionsAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryDecisionDefinitionsAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest DecisionDefinitionSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest DecisionDefinitionSearchQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest DecisionDefinitionSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionDefinitionXmlAlphaResponse parses an HTTP response from a GetDecisionDefinitionXmlAlphaWithResponse call
func ParseGetDecisionDefinitionXmlAlphaResponse(rsp *http.Response) (*GetDecisionDefinitionXmlAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionDefinitionXmlAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseQueryDecisionInstancesAlphaResponse parses an HTTP response from a QueryDecisionInstancesAlphaWithResponse call
func ParseQueryDecisionInstancesAlphaResponse(rsp *http.Response) (*QueryDecisionInstancesAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryDecisionInstancesAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest DecisionInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest DecisionInstanceSearchQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest DecisionInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseQueryDecisionRequirementsAlphaResponse parses an HTTP response from a QueryDecisionRequirementsAlphaWithResponse call
func ParseQueryDecisionRequirementsAlphaResponse(rsp *http.Response) (*QueryDecisionRequirementsAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryDecisionRequirementsAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest DecisionRequirementsSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest DecisionRequirementsSearchQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest DecisionRequirementsSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	}

	return response, nil
}

// ParseDeployResourcesResponse parses an HTTP response from a DeployResourcesWithResponse call
func ParseDeployResourcesResponse(rsp *http.Response) (*DeployResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeployResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest DeploymentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest DeploymentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest DeploymentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseUploadDocumentResponse parses an HTTP response from a UploadDocumentWithResponse call
func ParseUploadDocumentResponse(rsp *http.Response) (*UploadDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 201:
		var dest DocumentReference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 201:
		var dest DocumentReferenceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 201:
		var dest DocumentReference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseUploadMultipleDocumentsResponse parses an HTTP response from a UploadMultipleDocumentsWithResponse call
func ParseUploadMultipleDocumentsResponse(rsp *http.Response) (*UploadMultipleDocumentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadMultipleDocumentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 201:
		var dest DocumentCreationBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 207:
		var dest DocumentCreationBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 201:
		var dest DocumentCreationBatchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 207:
		var dest DocumentCreationBatchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON207 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 201:
		var dest DocumentCreationBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 207:
		var dest DocumentCreationBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseDeleteDocumentResponse parses an HTTP response from a DeleteDocumentWithResponse call
func ParseDeleteDocumentResponse(rsp *http.Response) (*DeleteDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDownloadDocumentResponse parses an HTTP response from a DownloadDocumentWithResponse call
func ParseDownloadDocumentResponse(rsp *http.Response) (*DownloadDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDocumentLinkResponse parses an HTTP response from a CreateDocumentLinkWithResponse call
func ParseCreateDocumentLinkResponse(rsp *http.Response) (*CreateDocumentLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDocumentLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DocumentLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseUpdateElementInstanceVariablesResponse parses an HTTP response from a UpdateElementInstanceVariablesWithResponse call
func ParseUpdateElementInstanceVariablesResponse(rsp *http.Response) (*UpdateElementInstanceVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateElementInstanceVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseQueryFlowNodeInstancesAlphaResponse parses an HTTP response from a QueryFlowNodeInstancesAlphaWithResponse call
func ParseQueryFlowNodeInstancesAlphaResponse(rsp *http.Response) (*QueryFlowNodeInstancesAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryFlowNodeInstancesAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest FlowNodeInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest FlowNodeInstanceSearchQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest FlowNodeInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseQueryIncidentsAlphaResponse parses an HTTP response from a QueryIncidentsAlphaWithResponse call
func ParseQueryIncidentsAlphaResponse(rsp *http.Response) (*QueryIncidentsAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryIncidentsAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest IncidentSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest IncidentSearchQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest IncidentSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIncidentByKeyAlphaResponse parses an HTTP response from a GetIncidentByKeyAlphaWithResponse call
func ParseGetIncidentByKeyAlphaResponse(rsp *http.Response) (*GetIncidentByKeyAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncidentByKeyAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest IncidentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest IncidentItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest IncidentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseResolveIncidentResponse parses an HTTP response from a ResolveIncidentWithResponse call
func ParseResolveIncidentResponse(rsp *http.Response) (*ResolveIncidentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolveIncidentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseActivateJobsResponse parses an HTTP response from a ActivateJobsWithResponse call
func ParseActivateJobsResponse(rsp *http.Response) (*ActivateJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest JobActivationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest JobActivationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest JobActivationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAJobResponse parses an HTTP response from a UpdateAJobWithResponse call
func ParseUpdateAJobResponse(rsp *http.Response) (*UpdateAJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCompleteJobResponse parses an HTTP response from a CompleteJobWithResponse call
func ParseCompleteJobResponse(rsp *http.Response) (*CompleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseThrowErrorForJobResponse parses an HTTP response from a ThrowErrorForJobWithResponse call
func ParseThrowErrorForJobResponse(rsp *http.Response) (*ThrowErrorForJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThrowErrorForJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseFailJobResponse parses an HTTP response from a FailJobWithResponse call
func ParseFailJobResponse(rsp *http.Response) (*FailJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FailJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetStatusOfCamundaLicenseResponse parses an HTTP response from a GetStatusOfCamundaLicenseWithResponse call
func ParseGetStatusOfCamundaLicenseResponse(rsp *http.Response) (*GetStatusOfCamundaLicenseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusOfCamundaLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LicenseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCorrelateAMessageResponse parses an HTTP response from a CorrelateAMessageWithResponse call
func ParseCorrelateAMessageResponse(rsp *http.Response) (*CorrelateAMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CorrelateAMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest MessageCorrelationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest MessageCorrelationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest MessageCorrelationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePublishAMessageResponse parses an HTTP response from a PublishAMessageWithResponse call
func ParsePublishAMessageResponse(rsp *http.Response) (*PublishAMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishAMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest MessagePublicationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest MessagePublicationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest MessagePublicationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateProcessInstanceResponse parses an HTTP response from a CreateProcessInstanceWithResponse call
func ParseCreateProcessInstanceResponse(rsp *http.Response) (*CreateProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest CreateProcessInstanceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest CreateProcessInstanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest CreateProcessInstanceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON504 = &dest

	}

	return response, nil
}

// ParseQueryProcessInstancesAlphaResponse parses an HTTP response from a QueryProcessInstancesAlphaWithResponse call
func ParseQueryProcessInstancesAlphaResponse(rsp *http.Response) (*QueryProcessInstancesAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryProcessInstancesAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest ProcessInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest ProcessInstanceSearchQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest ProcessInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCancelProcessInstanceResponse parses an HTTP response from a CancelProcessInstanceWithResponse call
func ParseCancelProcessInstanceResponse(rsp *http.Response) (*CancelProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseMigrateProcessInstanceResponse parses an HTTP response from a MigrateProcessInstanceWithResponse call
func ParseMigrateProcessInstanceResponse(rsp *http.Response) (*MigrateProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrateProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseModifyProcessInstanceResponse parses an HTTP response from a ModifyProcessInstanceWithResponse call
func ParseModifyProcessInstanceResponse(rsp *http.Response) (*ModifyProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceContentResponse parses an HTTP response from a GetResourceContentWithResponse call
func ParseGetResourceContentResponse(rsp *http.Response) (*GetResourceContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteResourceResponse parses an HTTP response from a DeleteResourceWithResponse call
func ParseDeleteResourceResponse(rsp *http.Response) (*DeleteResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseBroadcastSignalResponse parses an HTTP response from a BroadcastSignalWithResponse call
func ParseBroadcastSignalResponse(rsp *http.Response) (*BroadcastSignalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BroadcastSignalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest SignalBroadcastResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest SignalBroadcastResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest SignalBroadcastResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterTopologyResponse parses an HTTP response from a GetClusterTopologyWithResponse call
func ParseGetClusterTopologyResponse(rsp *http.Response) (*GetClusterTopologyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterTopologyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopologyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseQueryUserTasksAlphaResponse parses an HTTP response from a QueryUserTasksAlphaWithResponse call
func ParseQueryUserTasksAlphaResponse(rsp *http.Response) (*QueryUserTasksAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryUserTasksAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest UserTaskSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.number+json" && rsp.StatusCode == 200:
		var dest UserTaskSearchQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysNumberJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.camunda.api.keys.string+json" && rsp.StatusCode == 200:
		var dest UserTaskSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCamundaApiKeysStringJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserTaskResponse parses an HTTP response from a UpdateUserTaskWithResponse call
func ParseUpdateUserTaskResponse(rsp *http.Response) (*UpdateUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignUserTaskResponse parses an HTTP response from a UnassignUserTaskWithResponse call
func ParseUnassignUserTaskResponse(rsp *http.Response) (*UnassignUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAssignUserTaskResponse parses an HTTP response from a AssignUserTaskWithResponse call
func ParseAssignUserTaskResponse(rsp *http.Response) (*AssignUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCompleteUserTaskResponse parses an HTTP response from a CompleteUserTaskWithResponse call
func ParseCompleteUserTaskResponse(rsp *http.Response) (*CompleteUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
