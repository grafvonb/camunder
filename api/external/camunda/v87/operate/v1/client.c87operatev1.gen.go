// Package c87operatev1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package c87operatev1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ProcessInstanceFilterState.
const (
	ProcessInstanceFilterStateACTIVE    ProcessInstanceFilterState = "ACTIVE"
	ProcessInstanceFilterStateCANCELED  ProcessInstanceFilterState = "CANCELED"
	ProcessInstanceFilterStateCOMPLETED ProcessInstanceFilterState = "COMPLETED"
)

// Defines values for ProcessInstanceItemState.
const (
	ProcessInstanceItemStateACTIVE    ProcessInstanceItemState = "ACTIVE"
	ProcessInstanceItemStateCANCELED  ProcessInstanceItemState = "CANCELED"
	ProcessInstanceItemStateCOMPLETED ProcessInstanceItemState = "COMPLETED"
)

// Defines values for SortOrder.
const (
	ASC  SortOrder = "ASC"
	DESC SortOrder = "DESC"
)

// Problem defines model for Problem.
type Problem struct {
	Instance *string `json:"instance,omitempty"`
	Message  *string `json:"message,omitempty"`
	Status   *int32  `json:"status,omitempty"`
	Type     *string `json:"type,omitempty"`
}

// ProcessDefinitionFilter defines model for ProcessDefinitionFilter.
type ProcessDefinitionFilter struct {
	BpmnProcessId *string `json:"bpmnProcessId,omitempty"`
	Key           *int64  `json:"key,omitempty"`
	Name          *string `json:"name,omitempty"`
	TenantId      *string `json:"tenantId,omitempty"`
	Version       *int32  `json:"version,omitempty"`
	VersionTag    *string `json:"versionTag,omitempty"`
}

// ProcessDefinitionItem defines model for ProcessDefinitionItem.
type ProcessDefinitionItem struct {
	BpmnProcessId *string `json:"bpmnProcessId,omitempty"`
	Key           *int64  `json:"key,omitempty"`
	Name          *string `json:"name,omitempty"`
	TenantId      *string `json:"tenantId,omitempty"`
	Version       *int32  `json:"version,omitempty"`
	VersionTag    *string `json:"versionTag,omitempty"`
}

// ProcessDefinitionSearchRequest defines model for ProcessDefinitionSearchRequest.
type ProcessDefinitionSearchRequest struct {
	Filter      *ProcessDefinitionFilter `json:"filter,omitempty"`
	SearchAfter *[]interface{}           `json:"searchAfter,omitempty"`
	Size        *int32                   `json:"size,omitempty"`
	Sort        *[]SortInstruction       `json:"sort,omitempty"`
}

// ProcessDefinitionSearchResponse defines model for ProcessDefinitionSearchResponse.
type ProcessDefinitionSearchResponse struct {
	Items      *[]ProcessDefinitionItem `json:"items,omitempty"`
	SortValues *[]interface{}           `json:"sortValues,omitempty"`
	Total      *int64                   `json:"total,omitempty"`
}

// ProcessInstanceDeleteResponse defines model for ProcessInstanceDeleteResponse.
type ProcessInstanceDeleteResponse struct {
	Deleted int64  `json:"deleted"`
	Message string `json:"message"`
}

// ProcessInstanceFilter defines model for ProcessInstanceFilter.
type ProcessInstanceFilter struct {
	BpmnProcessId             *string                     `json:"bpmnProcessId,omitempty"`
	EndDate                   *string                     `json:"endDate,omitempty"`
	Incident                  *bool                       `json:"incident,omitempty"`
	Key                       *int64                      `json:"key,omitempty"`
	ParentFlowNodeInstanceKey *int64                      `json:"parentFlowNodeInstanceKey,omitempty"`
	ParentKey                 *int64                      `json:"parentKey,omitempty"`
	ParentProcessInstanceKey  *int64                      `json:"parentProcessInstanceKey,omitempty"`
	ProcessDefinitionKey      *int64                      `json:"processDefinitionKey,omitempty"`
	ProcessVersion            *int32                      `json:"processVersion,omitempty"`
	ProcessVersionTag         *string                     `json:"processVersionTag,omitempty"`
	StartDate                 *string                     `json:"startDate,omitempty"`
	State                     *ProcessInstanceFilterState `json:"state,omitempty"`
	TenantId                  *string                     `json:"tenantId,omitempty"`
}

// ProcessInstanceFilterState defines model for ProcessInstanceFilter.State.
type ProcessInstanceFilterState string

// ProcessInstanceItem defines model for ProcessInstanceItem.
type ProcessInstanceItem struct {
	BpmnProcessId             *string                   `json:"bpmnProcessId,omitempty"`
	EndDate                   *string                   `json:"endDate,omitempty"`
	Incident                  *bool                     `json:"incident,omitempty"`
	Key                       *int64                    `json:"key,omitempty"`
	ParentFlowNodeInstanceKey *int64                    `json:"parentFlowNodeInstanceKey,omitempty"`
	ParentKey                 *int64                    `json:"parentKey,omitempty"`
	ParentProcessInstanceKey  *int64                    `json:"parentProcessInstanceKey,omitempty"`
	ProcessDefinitionKey      *int64                    `json:"processDefinitionKey,omitempty"`
	ProcessVersion            *int32                    `json:"processVersion,omitempty"`
	ProcessVersionTag         *string                   `json:"processVersionTag,omitempty"`
	StartDate                 *string                   `json:"startDate,omitempty"`
	State                     *ProcessInstanceItemState `json:"state,omitempty"`
	TenantId                  *string                   `json:"tenantId,omitempty"`
}

// ProcessInstanceItemState defines model for ProcessInstanceItem.State.
type ProcessInstanceItemState string

// ProcessInstanceSearchRequest defines model for ProcessInstanceSearchRequest.
type ProcessInstanceSearchRequest struct {
	Filter      *ProcessInstanceFilter `json:"filter,omitempty"`
	SearchAfter *[]interface{}         `json:"searchAfter,omitempty"`
	Size        *int32                 `json:"size,omitempty"`
	Sort        *[]SortInstruction     `json:"sort,omitempty"`
}

// ProcessInstanceSearchResponse defines model for ProcessInstanceSearchResponse.
type ProcessInstanceSearchResponse struct {
	Items      *[]ProcessInstanceItem `json:"items,omitempty"`
	SortValues *[]interface{}         `json:"sortValues,omitempty"`
	Total      *int64                 `json:"total,omitempty"`
}

// SortInstruction defines model for SortInstruction.
type SortInstruction struct {
	Field *string    `json:"field,omitempty"`
	Order *SortOrder `json:"order,omitempty"`
}

// SortOrder defines model for SortOrder.
type SortOrder string

// SearchForDecisionDefinitionsJSONBody defines parameters for SearchForDecisionDefinitions.
type SearchForDecisionDefinitionsJSONBody = map[string]interface{}

// SearchForDecisionInstancesJSONBody defines parameters for SearchForDecisionInstances.
type SearchForDecisionInstancesJSONBody = map[string]interface{}

// SearchForDecisionRequirementsJSONBody defines parameters for SearchForDecisionRequirements.
type SearchForDecisionRequirementsJSONBody = map[string]interface{}

// SearchForFlowNodeInstancesJSONBody defines parameters for SearchForFlowNodeInstances.
type SearchForFlowNodeInstancesJSONBody = map[string]interface{}

// SearchForVariablesJSONBody defines parameters for SearchForVariables.
type SearchForVariablesJSONBody = map[string]interface{}

// SearchForDecisionDefinitionsJSONRequestBody defines body for SearchForDecisionDefinitions for application/json ContentType.
type SearchForDecisionDefinitionsJSONRequestBody = SearchForDecisionDefinitionsJSONBody

// SearchForDecisionInstancesJSONRequestBody defines body for SearchForDecisionInstances for application/json ContentType.
type SearchForDecisionInstancesJSONRequestBody = SearchForDecisionInstancesJSONBody

// SearchForDecisionRequirementsJSONRequestBody defines body for SearchForDecisionRequirements for application/json ContentType.
type SearchForDecisionRequirementsJSONRequestBody = SearchForDecisionRequirementsJSONBody

// SearchForFlowNodeInstancesJSONRequestBody defines body for SearchForFlowNodeInstances for application/json ContentType.
type SearchForFlowNodeInstancesJSONRequestBody = SearchForFlowNodeInstancesJSONBody

// SearchForProcessDefinitionsJSONRequestBody defines body for SearchForProcessDefinitions for application/json ContentType.
type SearchForProcessDefinitionsJSONRequestBody = ProcessDefinitionSearchRequest

// SearchForProcessInstancesJSONRequestBody defines body for SearchForProcessInstances for application/json ContentType.
type SearchForProcessInstancesJSONRequestBody = ProcessInstanceSearchRequest

// SearchForVariablesJSONRequestBody defines body for SearchForVariables for application/json ContentType.
type SearchForVariablesJSONRequestBody = SearchForVariablesJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SearchForDecisionDefinitionsWithBody request with any body
	SearchForDecisionDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForDecisionDefinitions(ctx context.Context, body SearchForDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionDefinitionByKey request
	GetDecisionDefinitionByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForDecisionInstancesWithBody request with any body
	SearchForDecisionInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForDecisionInstances(ctx context.Context, body SearchForDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionInstanceByKey request
	GetDecisionInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForDecisionRequirementsWithBody request with any body
	SearchForDecisionRequirementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForDecisionRequirements(ctx context.Context, body SearchForDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionRequirementsByKey request
	GetDecisionRequirementsByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionRequirementsByKeyAsXml request
	GetDecisionRequirementsByKeyAsXml(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForFlowNodeInstancesWithBody request with any body
	SearchForFlowNodeInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForFlowNodeInstances(ctx context.Context, body SearchForFlowNodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowNodeInstanceByKey request
	GetFlowNodeInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForIncidents request
	SearchForIncidents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncidentByKey request
	GetIncidentByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForProcessDefinitionsWithBody request with any body
	SearchForProcessDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForProcessDefinitions(ctx context.Context, body SearchForProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefinitionByKey request
	GetProcessDefinitionByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefintionByKeyAsXml request
	GetProcessDefintionByKeyAsXml(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForProcessInstancesWithBody request with any body
	SearchForProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForProcessInstances(ctx context.Context, body SearchForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProcessInstanceAndDependantDataByKey request
	DeleteProcessInstanceAndDependantDataByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessInstanceByKey request
	GetProcessInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForVariablesWithBody request with any body
	SearchForVariablesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForVariables(ctx context.Context, body SearchForVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariableByKey request
	GetVariableByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SearchForDecisionDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionDefinitionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForDecisionDefinitions(ctx context.Context, body SearchForDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionDefinitionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionDefinitionByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionDefinitionByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForDecisionInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForDecisionInstances(ctx context.Context, body SearchForDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionInstanceByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForDecisionRequirementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionRequirementsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForDecisionRequirements(ctx context.Context, body SearchForDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionRequirementsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionRequirementsByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionRequirementsByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionRequirementsByKeyAsXml(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionRequirementsByKeyAsXmlRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForFlowNodeInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForFlowNodeInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForFlowNodeInstances(ctx context.Context, body SearchForFlowNodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForFlowNodeInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowNodeInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowNodeInstanceByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForIncidents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForIncidentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncidentByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncidentByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForProcessDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForProcessDefinitionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForProcessDefinitions(ctx context.Context, body SearchForProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForProcessDefinitionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinitionByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefintionByKeyAsXml(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefintionByKeyAsXmlRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForProcessInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForProcessInstances(ctx context.Context, body SearchForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForProcessInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProcessInstanceAndDependantDataByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProcessInstanceAndDependantDataByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessInstanceByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForVariablesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForVariablesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForVariables(ctx context.Context, body SearchForVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForVariablesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariableByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSearchForDecisionDefinitionsRequest calls the generic SearchForDecisionDefinitions builder with application/json body
func NewSearchForDecisionDefinitionsRequest(server string, body SearchForDecisionDefinitionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForDecisionDefinitionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForDecisionDefinitionsRequestWithBody generates requests for SearchForDecisionDefinitions with any type of body
func NewSearchForDecisionDefinitionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionDefinitionByKeyRequest generates requests for GetDecisionDefinitionByKey
func NewGetDecisionDefinitionByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForDecisionInstancesRequest calls the generic SearchForDecisionInstances builder with application/json body
func NewSearchForDecisionInstancesRequest(server string, body SearchForDecisionInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForDecisionInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForDecisionInstancesRequestWithBody generates requests for SearchForDecisionInstances with any type of body
func NewSearchForDecisionInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionInstanceByKeyRequest generates requests for GetDecisionInstanceByKey
func NewGetDecisionInstanceByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForDecisionRequirementsRequest calls the generic SearchForDecisionRequirements builder with application/json body
func NewSearchForDecisionRequirementsRequest(server string, body SearchForDecisionRequirementsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForDecisionRequirementsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForDecisionRequirementsRequestWithBody generates requests for SearchForDecisionRequirements with any type of body
func NewSearchForDecisionRequirementsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/drd/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionRequirementsByKeyRequest generates requests for GetDecisionRequirementsByKey
func NewGetDecisionRequirementsByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/drd/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDecisionRequirementsByKeyAsXmlRequest generates requests for GetDecisionRequirementsByKeyAsXml
func NewGetDecisionRequirementsByKeyAsXmlRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/drd/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForFlowNodeInstancesRequest calls the generic SearchForFlowNodeInstances builder with application/json body
func NewSearchForFlowNodeInstancesRequest(server string, body SearchForFlowNodeInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForFlowNodeInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForFlowNodeInstancesRequestWithBody generates requests for SearchForFlowNodeInstances with any type of body
func NewSearchForFlowNodeInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flownode-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFlowNodeInstanceByKeyRequest generates requests for GetFlowNodeInstanceByKey
func NewGetFlowNodeInstanceByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flownode-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForIncidentsRequest generates requests for SearchForIncidents
func NewSearchForIncidentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIncidentByKeyRequest generates requests for GetIncidentByKey
func NewGetIncidentByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForProcessDefinitionsRequest calls the generic SearchForProcessDefinitions builder with application/json body
func NewSearchForProcessDefinitionsRequest(server string, body SearchForProcessDefinitionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForProcessDefinitionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForProcessDefinitionsRequestWithBody generates requests for SearchForProcessDefinitions with any type of body
func NewSearchForProcessDefinitionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessDefinitionByKeyRequest generates requests for GetProcessDefinitionByKey
func NewGetProcessDefinitionByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessDefintionByKeyAsXmlRequest generates requests for GetProcessDefintionByKeyAsXml
func NewGetProcessDefintionByKeyAsXmlRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForProcessInstancesRequest calls the generic SearchForProcessInstances builder with application/json body
func NewSearchForProcessInstancesRequest(server string, body SearchForProcessInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForProcessInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForProcessInstancesRequestWithBody generates requests for SearchForProcessInstances with any type of body
func NewSearchForProcessInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProcessInstanceAndDependantDataByKeyRequest generates requests for DeleteProcessInstanceAndDependantDataByKey
func NewDeleteProcessInstanceAndDependantDataByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessInstanceByKeyRequest generates requests for GetProcessInstanceByKey
func NewGetProcessInstanceByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForVariablesRequest calls the generic SearchForVariables builder with application/json body
func NewSearchForVariablesRequest(server string, body SearchForVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForVariablesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForVariablesRequestWithBody generates requests for SearchForVariables with any type of body
func NewSearchForVariablesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVariableByKeyRequest generates requests for GetVariableByKey
func NewGetVariableByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SearchForDecisionDefinitionsWithBodyWithResponse request with any body
	SearchForDecisionDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionDefinitionsResponse, error)

	SearchForDecisionDefinitionsWithResponse(ctx context.Context, body SearchForDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionDefinitionsResponse, error)

	// GetDecisionDefinitionByKeyWithResponse request
	GetDecisionDefinitionByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionByKeyResponse, error)

	// SearchForDecisionInstancesWithBodyWithResponse request with any body
	SearchForDecisionInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionInstancesResponse, error)

	SearchForDecisionInstancesWithResponse(ctx context.Context, body SearchForDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionInstancesResponse, error)

	// GetDecisionInstanceByKeyWithResponse request
	GetDecisionInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionInstanceByKeyResponse, error)

	// SearchForDecisionRequirementsWithBodyWithResponse request with any body
	SearchForDecisionRequirementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionRequirementsResponse, error)

	SearchForDecisionRequirementsWithResponse(ctx context.Context, body SearchForDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionRequirementsResponse, error)

	// GetDecisionRequirementsByKeyWithResponse request
	GetDecisionRequirementsByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsByKeyResponse, error)

	// GetDecisionRequirementsByKeyAsXmlWithResponse request
	GetDecisionRequirementsByKeyAsXmlWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsByKeyAsXmlResponse, error)

	// SearchForFlowNodeInstancesWithBodyWithResponse request with any body
	SearchForFlowNodeInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForFlowNodeInstancesResponse, error)

	SearchForFlowNodeInstancesWithResponse(ctx context.Context, body SearchForFlowNodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForFlowNodeInstancesResponse, error)

	// GetFlowNodeInstanceByKeyWithResponse request
	GetFlowNodeInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetFlowNodeInstanceByKeyResponse, error)

	// SearchForIncidentsWithResponse request
	SearchForIncidentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchForIncidentsResponse, error)

	// GetIncidentByKeyWithResponse request
	GetIncidentByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetIncidentByKeyResponse, error)

	// SearchForProcessDefinitionsWithBodyWithResponse request with any body
	SearchForProcessDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForProcessDefinitionsResponse, error)

	SearchForProcessDefinitionsWithResponse(ctx context.Context, body SearchForProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForProcessDefinitionsResponse, error)

	// GetProcessDefinitionByKeyWithResponse request
	GetProcessDefinitionByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionByKeyResponse, error)

	// GetProcessDefintionByKeyAsXmlWithResponse request
	GetProcessDefintionByKeyAsXmlWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessDefintionByKeyAsXmlResponse, error)

	// SearchForProcessInstancesWithBodyWithResponse request with any body
	SearchForProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForProcessInstancesResponse, error)

	SearchForProcessInstancesWithResponse(ctx context.Context, body SearchForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForProcessInstancesResponse, error)

	// DeleteProcessInstanceAndDependantDataByKeyWithResponse request
	DeleteProcessInstanceAndDependantDataByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*DeleteProcessInstanceAndDependantDataByKeyResponse, error)

	// GetProcessInstanceByKeyWithResponse request
	GetProcessInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessInstanceByKeyResponse, error)

	// SearchForVariablesWithBodyWithResponse request with any body
	SearchForVariablesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForVariablesResponse, error)

	SearchForVariablesWithResponse(ctx context.Context, body SearchForVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForVariablesResponse, error)

	// GetVariableByKeyWithResponse request
	GetVariableByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetVariableByKeyResponse, error)
}

type SearchForDecisionDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForDecisionDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForDecisionDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionDefinitionByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDecisionDefinitionByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionDefinitionByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForDecisionInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForDecisionInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForDecisionInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionInstanceByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDecisionInstanceByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionInstanceByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForDecisionRequirementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForDecisionRequirementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForDecisionRequirementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionRequirementsByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDecisionRequirementsByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionRequirementsByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionRequirementsByKeyAsXmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDecisionRequirementsByKeyAsXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionRequirementsByKeyAsXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForFlowNodeInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForFlowNodeInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForFlowNodeInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowNodeInstanceByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFlowNodeInstanceByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowNodeInstanceByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForIncidentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForIncidentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForIncidentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncidentByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIncidentByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncidentByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForProcessDefinitionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessDefinitionSearchResponse
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r SearchForProcessDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForProcessDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefinitionByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProcessDefinitionByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefinitionByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefintionByKeyAsXmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProcessDefintionByKeyAsXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefintionByKeyAsXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForProcessInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceSearchResponse
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r SearchForProcessInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForProcessInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProcessInstanceAndDependantDataByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceDeleteResponse
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteProcessInstanceAndDependantDataByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProcessInstanceAndDependantDataByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessInstanceByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProcessInstanceByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessInstanceByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForVariablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetVariableByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SearchForDecisionDefinitionsWithBodyWithResponse request with arbitrary body returning *SearchForDecisionDefinitionsResponse
func (c *ClientWithResponses) SearchForDecisionDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionDefinitionsResponse, error) {
	rsp, err := c.SearchForDecisionDefinitionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionDefinitionsResponse(rsp)
}

func (c *ClientWithResponses) SearchForDecisionDefinitionsWithResponse(ctx context.Context, body SearchForDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionDefinitionsResponse, error) {
	rsp, err := c.SearchForDecisionDefinitions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionDefinitionsResponse(rsp)
}

// GetDecisionDefinitionByKeyWithResponse request returning *GetDecisionDefinitionByKeyResponse
func (c *ClientWithResponses) GetDecisionDefinitionByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionByKeyResponse, error) {
	rsp, err := c.GetDecisionDefinitionByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionDefinitionByKeyResponse(rsp)
}

// SearchForDecisionInstancesWithBodyWithResponse request with arbitrary body returning *SearchForDecisionInstancesResponse
func (c *ClientWithResponses) SearchForDecisionInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionInstancesResponse, error) {
	rsp, err := c.SearchForDecisionInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchForDecisionInstancesWithResponse(ctx context.Context, body SearchForDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionInstancesResponse, error) {
	rsp, err := c.SearchForDecisionInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionInstancesResponse(rsp)
}

// GetDecisionInstanceByKeyWithResponse request returning *GetDecisionInstanceByKeyResponse
func (c *ClientWithResponses) GetDecisionInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionInstanceByKeyResponse, error) {
	rsp, err := c.GetDecisionInstanceByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionInstanceByKeyResponse(rsp)
}

// SearchForDecisionRequirementsWithBodyWithResponse request with arbitrary body returning *SearchForDecisionRequirementsResponse
func (c *ClientWithResponses) SearchForDecisionRequirementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionRequirementsResponse, error) {
	rsp, err := c.SearchForDecisionRequirementsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionRequirementsResponse(rsp)
}

func (c *ClientWithResponses) SearchForDecisionRequirementsWithResponse(ctx context.Context, body SearchForDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionRequirementsResponse, error) {
	rsp, err := c.SearchForDecisionRequirements(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionRequirementsResponse(rsp)
}

// GetDecisionRequirementsByKeyWithResponse request returning *GetDecisionRequirementsByKeyResponse
func (c *ClientWithResponses) GetDecisionRequirementsByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsByKeyResponse, error) {
	rsp, err := c.GetDecisionRequirementsByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionRequirementsByKeyResponse(rsp)
}

// GetDecisionRequirementsByKeyAsXmlWithResponse request returning *GetDecisionRequirementsByKeyAsXmlResponse
func (c *ClientWithResponses) GetDecisionRequirementsByKeyAsXmlWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsByKeyAsXmlResponse, error) {
	rsp, err := c.GetDecisionRequirementsByKeyAsXml(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionRequirementsByKeyAsXmlResponse(rsp)
}

// SearchForFlowNodeInstancesWithBodyWithResponse request with arbitrary body returning *SearchForFlowNodeInstancesResponse
func (c *ClientWithResponses) SearchForFlowNodeInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForFlowNodeInstancesResponse, error) {
	rsp, err := c.SearchForFlowNodeInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForFlowNodeInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchForFlowNodeInstancesWithResponse(ctx context.Context, body SearchForFlowNodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForFlowNodeInstancesResponse, error) {
	rsp, err := c.SearchForFlowNodeInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForFlowNodeInstancesResponse(rsp)
}

// GetFlowNodeInstanceByKeyWithResponse request returning *GetFlowNodeInstanceByKeyResponse
func (c *ClientWithResponses) GetFlowNodeInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetFlowNodeInstanceByKeyResponse, error) {
	rsp, err := c.GetFlowNodeInstanceByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowNodeInstanceByKeyResponse(rsp)
}

// SearchForIncidentsWithResponse request returning *SearchForIncidentsResponse
func (c *ClientWithResponses) SearchForIncidentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchForIncidentsResponse, error) {
	rsp, err := c.SearchForIncidents(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForIncidentsResponse(rsp)
}

// GetIncidentByKeyWithResponse request returning *GetIncidentByKeyResponse
func (c *ClientWithResponses) GetIncidentByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetIncidentByKeyResponse, error) {
	rsp, err := c.GetIncidentByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncidentByKeyResponse(rsp)
}

// SearchForProcessDefinitionsWithBodyWithResponse request with arbitrary body returning *SearchForProcessDefinitionsResponse
func (c *ClientWithResponses) SearchForProcessDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForProcessDefinitionsResponse, error) {
	rsp, err := c.SearchForProcessDefinitionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForProcessDefinitionsResponse(rsp)
}

func (c *ClientWithResponses) SearchForProcessDefinitionsWithResponse(ctx context.Context, body SearchForProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForProcessDefinitionsResponse, error) {
	rsp, err := c.SearchForProcessDefinitions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForProcessDefinitionsResponse(rsp)
}

// GetProcessDefinitionByKeyWithResponse request returning *GetProcessDefinitionByKeyResponse
func (c *ClientWithResponses) GetProcessDefinitionByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionByKeyResponse, error) {
	rsp, err := c.GetProcessDefinitionByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionByKeyResponse(rsp)
}

// GetProcessDefintionByKeyAsXmlWithResponse request returning *GetProcessDefintionByKeyAsXmlResponse
func (c *ClientWithResponses) GetProcessDefintionByKeyAsXmlWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessDefintionByKeyAsXmlResponse, error) {
	rsp, err := c.GetProcessDefintionByKeyAsXml(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefintionByKeyAsXmlResponse(rsp)
}

// SearchForProcessInstancesWithBodyWithResponse request with arbitrary body returning *SearchForProcessInstancesResponse
func (c *ClientWithResponses) SearchForProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForProcessInstancesResponse, error) {
	rsp, err := c.SearchForProcessInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForProcessInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchForProcessInstancesWithResponse(ctx context.Context, body SearchForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForProcessInstancesResponse, error) {
	rsp, err := c.SearchForProcessInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForProcessInstancesResponse(rsp)
}

// DeleteProcessInstanceAndDependantDataByKeyWithResponse request returning *DeleteProcessInstanceAndDependantDataByKeyResponse
func (c *ClientWithResponses) DeleteProcessInstanceAndDependantDataByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*DeleteProcessInstanceAndDependantDataByKeyResponse, error) {
	rsp, err := c.DeleteProcessInstanceAndDependantDataByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProcessInstanceAndDependantDataByKeyResponse(rsp)
}

// GetProcessInstanceByKeyWithResponse request returning *GetProcessInstanceByKeyResponse
func (c *ClientWithResponses) GetProcessInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessInstanceByKeyResponse, error) {
	rsp, err := c.GetProcessInstanceByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessInstanceByKeyResponse(rsp)
}

// SearchForVariablesWithBodyWithResponse request with arbitrary body returning *SearchForVariablesResponse
func (c *ClientWithResponses) SearchForVariablesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForVariablesResponse, error) {
	rsp, err := c.SearchForVariablesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForVariablesResponse(rsp)
}

func (c *ClientWithResponses) SearchForVariablesWithResponse(ctx context.Context, body SearchForVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForVariablesResponse, error) {
	rsp, err := c.SearchForVariables(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForVariablesResponse(rsp)
}

// GetVariableByKeyWithResponse request returning *GetVariableByKeyResponse
func (c *ClientWithResponses) GetVariableByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetVariableByKeyResponse, error) {
	rsp, err := c.GetVariableByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableByKeyResponse(rsp)
}

// ParseSearchForDecisionDefinitionsResponse parses an HTTP response from a SearchForDecisionDefinitionsWithResponse call
func ParseSearchForDecisionDefinitionsResponse(rsp *http.Response) (*SearchForDecisionDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForDecisionDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDecisionDefinitionByKeyResponse parses an HTTP response from a GetDecisionDefinitionByKeyWithResponse call
func ParseGetDecisionDefinitionByKeyResponse(rsp *http.Response) (*GetDecisionDefinitionByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionDefinitionByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForDecisionInstancesResponse parses an HTTP response from a SearchForDecisionInstancesWithResponse call
func ParseSearchForDecisionInstancesResponse(rsp *http.Response) (*SearchForDecisionInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForDecisionInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDecisionInstanceByKeyResponse parses an HTTP response from a GetDecisionInstanceByKeyWithResponse call
func ParseGetDecisionInstanceByKeyResponse(rsp *http.Response) (*GetDecisionInstanceByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionInstanceByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForDecisionRequirementsResponse parses an HTTP response from a SearchForDecisionRequirementsWithResponse call
func ParseSearchForDecisionRequirementsResponse(rsp *http.Response) (*SearchForDecisionRequirementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForDecisionRequirementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDecisionRequirementsByKeyResponse parses an HTTP response from a GetDecisionRequirementsByKeyWithResponse call
func ParseGetDecisionRequirementsByKeyResponse(rsp *http.Response) (*GetDecisionRequirementsByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionRequirementsByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDecisionRequirementsByKeyAsXmlResponse parses an HTTP response from a GetDecisionRequirementsByKeyAsXmlWithResponse call
func ParseGetDecisionRequirementsByKeyAsXmlResponse(rsp *http.Response) (*GetDecisionRequirementsByKeyAsXmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionRequirementsByKeyAsXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForFlowNodeInstancesResponse parses an HTTP response from a SearchForFlowNodeInstancesWithResponse call
func ParseSearchForFlowNodeInstancesResponse(rsp *http.Response) (*SearchForFlowNodeInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForFlowNodeInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFlowNodeInstanceByKeyResponse parses an HTTP response from a GetFlowNodeInstanceByKeyWithResponse call
func ParseGetFlowNodeInstanceByKeyResponse(rsp *http.Response) (*GetFlowNodeInstanceByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowNodeInstanceByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForIncidentsResponse parses an HTTP response from a SearchForIncidentsWithResponse call
func ParseSearchForIncidentsResponse(rsp *http.Response) (*SearchForIncidentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForIncidentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIncidentByKeyResponse parses an HTTP response from a GetIncidentByKeyWithResponse call
func ParseGetIncidentByKeyResponse(rsp *http.Response) (*GetIncidentByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncidentByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForProcessDefinitionsResponse parses an HTTP response from a SearchForProcessDefinitionsWithResponse call
func ParseSearchForProcessDefinitionsResponse(rsp *http.Response) (*SearchForProcessDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForProcessDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessDefinitionSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.StatusCode == 200:
	// Content-type (text/plain) unsupported

	case rsp.StatusCode == 403:
	// Content-type (*/*) unsupported

	case rsp.StatusCode == 404:
		// Content-type (*/*) unsupported

	}

	return response, nil
}

// ParseGetProcessDefinitionByKeyResponse parses an HTTP response from a GetProcessDefinitionByKeyWithResponse call
func ParseGetProcessDefinitionByKeyResponse(rsp *http.Response) (*GetProcessDefinitionByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefinitionByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProcessDefintionByKeyAsXmlResponse parses an HTTP response from a GetProcessDefintionByKeyAsXmlWithResponse call
func ParseGetProcessDefintionByKeyAsXmlResponse(rsp *http.Response) (*GetProcessDefintionByKeyAsXmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefintionByKeyAsXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForProcessInstancesResponse parses an HTTP response from a SearchForProcessInstancesWithResponse call
func ParseSearchForProcessInstancesResponse(rsp *http.Response) (*SearchForProcessInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForProcessInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProcessInstanceAndDependantDataByKeyResponse parses an HTTP response from a DeleteProcessInstanceAndDependantDataByKeyWithResponse call
func ParseDeleteProcessInstanceAndDependantDataByKeyResponse(rsp *http.Response) (*DeleteProcessInstanceAndDependantDataByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProcessInstanceAndDependantDataByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessInstanceByKeyResponse parses an HTTP response from a GetProcessInstanceByKeyWithResponse call
func ParseGetProcessInstanceByKeyResponse(rsp *http.Response) (*GetProcessInstanceByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessInstanceByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForVariablesResponse parses an HTTP response from a SearchForVariablesWithResponse call
func ParseSearchForVariablesResponse(rsp *http.Response) (*SearchForVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVariableByKeyResponse parses an HTTP response from a GetVariableByKeyWithResponse call
func ParseGetVariableByKeyResponse(rsp *http.Response) (*GetVariableByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"//9THNeamzwAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
