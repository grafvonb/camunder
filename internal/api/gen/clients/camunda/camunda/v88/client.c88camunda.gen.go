// Package c88camunda provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package v88

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AuthorizationSearchQuerySortRequestField.
const (
	OwnerId      AuthorizationSearchQuerySortRequestField = "ownerId"
	OwnerType    AuthorizationSearchQuerySortRequestField = "ownerType"
	ResourceId   AuthorizationSearchQuerySortRequestField = "resourceId"
	ResourceType AuthorizationSearchQuerySortRequestField = "resourceType"
)

// Defines values for BatchCommandOperationKind.
const (
	BatchCommand BatchCommandOperationKind = "batch-command"
)

// Defines values for BatchOperationErrorType.
const (
	QUERYFAILED              BatchOperationErrorType = "QUERY_FAILED"
	RESULTBUFFERSIZEEXCEEDED BatchOperationErrorType = "RESULT_BUFFER_SIZE_EXCEEDED"
)

// Defines values for BatchOperationItemResponseState.
const (
	BatchOperationItemResponseStateACTIVE    BatchOperationItemResponseState = "ACTIVE"
	BatchOperationItemResponseStateCANCELED  BatchOperationItemResponseState = "CANCELED"
	BatchOperationItemResponseStateCOMPLETED BatchOperationItemResponseState = "COMPLETED"
	BatchOperationItemResponseStateFAILED    BatchOperationItemResponseState = "FAILED"
	BatchOperationItemResponseStateSKIPPED   BatchOperationItemResponseState = "SKIPPED"
)

// Defines values for BatchOperationItemSearchQuerySortRequestField.
const (
	BatchOperationItemSearchQuerySortRequestFieldBatchOperationKey  BatchOperationItemSearchQuerySortRequestField = "batchOperationKey"
	BatchOperationItemSearchQuerySortRequestFieldItemKey            BatchOperationItemSearchQuerySortRequestField = "itemKey"
	BatchOperationItemSearchQuerySortRequestFieldProcessInstanceKey BatchOperationItemSearchQuerySortRequestField = "processInstanceKey"
	BatchOperationItemSearchQuerySortRequestFieldState              BatchOperationItemSearchQuerySortRequestField = "state"
)

// Defines values for BatchOperationResponseState.
const (
	BatchOperationResponseStateACTIVE             BatchOperationResponseState = "ACTIVE"
	BatchOperationResponseStateCANCELED           BatchOperationResponseState = "CANCELED"
	BatchOperationResponseStateCOMPLETED          BatchOperationResponseState = "COMPLETED"
	BatchOperationResponseStateCREATED            BatchOperationResponseState = "CREATED"
	BatchOperationResponseStateINCOMPLETED        BatchOperationResponseState = "INCOMPLETED"
	BatchOperationResponseStatePARTIALLYCOMPLETED BatchOperationResponseState = "PARTIALLY_COMPLETED"
	BatchOperationResponseStateSUSPENDED          BatchOperationResponseState = "SUSPENDED"
)

// Defines values for BatchOperationSearchQuerySortRequestField.
const (
	BatchOperationSearchQuerySortRequestFieldBatchOperationKey BatchOperationSearchQuerySortRequestField = "batchOperationKey"
	BatchOperationSearchQuerySortRequestFieldEndDate           BatchOperationSearchQuerySortRequestField = "endDate"
	BatchOperationSearchQuerySortRequestFieldOperationType     BatchOperationSearchQuerySortRequestField = "operationType"
	BatchOperationSearchQuerySortRequestFieldStartDate         BatchOperationSearchQuerySortRequestField = "startDate"
	BatchOperationSearchQuerySortRequestFieldState             BatchOperationSearchQuerySortRequestField = "state"
)

// Defines values for BatchOperationTypeEnum.
const (
	ADDVARIABLE              BatchOperationTypeEnum = "ADD_VARIABLE"
	CANCELPROCESSINSTANCE    BatchOperationTypeEnum = "CANCEL_PROCESS_INSTANCE"
	DELETEDECISIONDEFINITION BatchOperationTypeEnum = "DELETE_DECISION_DEFINITION"
	DELETEPROCESSDEFINITION  BatchOperationTypeEnum = "DELETE_PROCESS_DEFINITION"
	DELETEPROCESSINSTANCE    BatchOperationTypeEnum = "DELETE_PROCESS_INSTANCE"
	MIGRATEPROCESSINSTANCE   BatchOperationTypeEnum = "MIGRATE_PROCESS_INSTANCE"
	MODIFYPROCESSINSTANCE    BatchOperationTypeEnum = "MODIFY_PROCESS_INSTANCE"
	RESOLVEINCIDENT          BatchOperationTypeEnum = "RESOLVE_INCIDENT"
	UPDATEVARIABLE           BatchOperationTypeEnum = "UPDATE_VARIABLE"
)

// Defines values for CommandOperationKind.
const (
	Command CommandOperationKind = "command"
)

// Defines values for CreateOperationDuplicatePolicy.
const (
	BatchPartial   CreateOperationDuplicatePolicy = "batch-partial"
	Conflict       CreateOperationDuplicatePolicy = "conflict"
	Ignore         CreateOperationDuplicatePolicy = "ignore"
	Merge          CreateOperationDuplicatePolicy = "merge"
	ReturnExisting CreateOperationDuplicatePolicy = "return-existing"
	Upsert         CreateOperationDuplicatePolicy = "upsert"
)

// Defines values for CreateOperationIdempotencyMechanism.
const (
	BodyHash       CreateOperationIdempotencyMechanism = "body-hash"
	IdempotencyKey CreateOperationIdempotencyMechanism = "idempotency-key"
	NaturalKey     CreateOperationIdempotencyMechanism = "natural-key"
	None           CreateOperationIdempotencyMechanism = "none"
	ServerToken    CreateOperationIdempotencyMechanism = "server-token"
)

// Defines values for CreateOperationIdempotencyScope.
const (
	KeyPayload CreateOperationIdempotencyScope = "key+payload"
	Request    CreateOperationIdempotencyScope = "request"
	Resource   CreateOperationIdempotencyScope = "resource"
)

// Defines values for CreateOperationKind.
const (
	Create CreateOperationKind = "create"
)

// Defines values for DecisionDefinitionSearchQuerySortRequestField.
const (
	DecisionDefinitionSearchQuerySortRequestFieldDecisionDefinitionId    DecisionDefinitionSearchQuerySortRequestField = "decisionDefinitionId"
	DecisionDefinitionSearchQuerySortRequestFieldDecisionDefinitionKey   DecisionDefinitionSearchQuerySortRequestField = "decisionDefinitionKey"
	DecisionDefinitionSearchQuerySortRequestFieldDecisionRequirementsId  DecisionDefinitionSearchQuerySortRequestField = "decisionRequirementsId"
	DecisionDefinitionSearchQuerySortRequestFieldDecisionRequirementsKey DecisionDefinitionSearchQuerySortRequestField = "decisionRequirementsKey"
	DecisionDefinitionSearchQuerySortRequestFieldName                    DecisionDefinitionSearchQuerySortRequestField = "name"
	DecisionDefinitionSearchQuerySortRequestFieldTenantId                DecisionDefinitionSearchQuerySortRequestField = "tenantId"
	DecisionDefinitionSearchQuerySortRequestFieldVersion                 DecisionDefinitionSearchQuerySortRequestField = "version"
)

// Defines values for DecisionInstanceSearchQuerySortRequestField.
const (
	DecisionInstanceSearchQuerySortRequestFieldDecisionDefinitionId          DecisionInstanceSearchQuerySortRequestField = "decisionDefinitionId"
	DecisionInstanceSearchQuerySortRequestFieldDecisionDefinitionKey         DecisionInstanceSearchQuerySortRequestField = "decisionDefinitionKey"
	DecisionInstanceSearchQuerySortRequestFieldDecisionDefinitionName        DecisionInstanceSearchQuerySortRequestField = "decisionDefinitionName"
	DecisionInstanceSearchQuerySortRequestFieldDecisionDefinitionType        DecisionInstanceSearchQuerySortRequestField = "decisionDefinitionType"
	DecisionInstanceSearchQuerySortRequestFieldDecisionDefinitionVersion     DecisionInstanceSearchQuerySortRequestField = "decisionDefinitionVersion"
	DecisionInstanceSearchQuerySortRequestFieldDecisionEvaluationInstanceKey DecisionInstanceSearchQuerySortRequestField = "decisionEvaluationInstanceKey"
	DecisionInstanceSearchQuerySortRequestFieldDecisionEvaluationKey         DecisionInstanceSearchQuerySortRequestField = "decisionEvaluationKey"
	DecisionInstanceSearchQuerySortRequestFieldElementInstanceKey            DecisionInstanceSearchQuerySortRequestField = "elementInstanceKey"
	DecisionInstanceSearchQuerySortRequestFieldEvaluationDate                DecisionInstanceSearchQuerySortRequestField = "evaluationDate"
	DecisionInstanceSearchQuerySortRequestFieldEvaluationFailure             DecisionInstanceSearchQuerySortRequestField = "evaluationFailure"
	DecisionInstanceSearchQuerySortRequestFieldProcessDefinitionKey          DecisionInstanceSearchQuerySortRequestField = "processDefinitionKey"
	DecisionInstanceSearchQuerySortRequestFieldProcessInstanceKey            DecisionInstanceSearchQuerySortRequestField = "processInstanceKey"
	DecisionInstanceSearchQuerySortRequestFieldState                         DecisionInstanceSearchQuerySortRequestField = "state"
	DecisionInstanceSearchQuerySortRequestFieldTenantId                      DecisionInstanceSearchQuerySortRequestField = "tenantId"
)

// Defines values for DecisionRequirementsSearchQuerySortRequestField.
const (
	DecisionRequirementsSearchQuerySortRequestFieldDecisionRequirementsId   DecisionRequirementsSearchQuerySortRequestField = "decisionRequirementsId"
	DecisionRequirementsSearchQuerySortRequestFieldDecisionRequirementsKey  DecisionRequirementsSearchQuerySortRequestField = "decisionRequirementsKey"
	DecisionRequirementsSearchQuerySortRequestFieldDecisionRequirementsName DecisionRequirementsSearchQuerySortRequestField = "decisionRequirementsName"
	DecisionRequirementsSearchQuerySortRequestFieldTenantId                 DecisionRequirementsSearchQuerySortRequestField = "tenantId"
	DecisionRequirementsSearchQuerySortRequestFieldVersion                  DecisionRequirementsSearchQuerySortRequestField = "version"
)

// Defines values for DeleteOperationKind.
const (
	Delete DeleteOperationKind = "delete"
)

// Defines values for DocumentReferenceCamundaDocumentType.
const (
	Camunda DocumentReferenceCamundaDocumentType = "camunda"
)

// Defines values for ElementInstanceFilterType.
const (
	ElementInstanceFilterTypeADHOCSUBPROCESS              ElementInstanceFilterType = "AD_HOC_SUB_PROCESS"
	ElementInstanceFilterTypeADHOCSUBPROCESSINNERINSTANCE ElementInstanceFilterType = "AD_HOC_SUB_PROCESS_INNER_INSTANCE"
	ElementInstanceFilterTypeBOUNDARYEVENT                ElementInstanceFilterType = "BOUNDARY_EVENT"
	ElementInstanceFilterTypeBUSINESSRULETASK             ElementInstanceFilterType = "BUSINESS_RULE_TASK"
	ElementInstanceFilterTypeCALLACTIVITY                 ElementInstanceFilterType = "CALL_ACTIVITY"
	ElementInstanceFilterTypeENDEVENT                     ElementInstanceFilterType = "END_EVENT"
	ElementInstanceFilterTypeEVENTBASEDGATEWAY            ElementInstanceFilterType = "EVENT_BASED_GATEWAY"
	ElementInstanceFilterTypeEVENTSUBPROCESS              ElementInstanceFilterType = "EVENT_SUB_PROCESS"
	ElementInstanceFilterTypeEXCLUSIVEGATEWAY             ElementInstanceFilterType = "EXCLUSIVE_GATEWAY"
	ElementInstanceFilterTypeINCLUSIVEGATEWAY             ElementInstanceFilterType = "INCLUSIVE_GATEWAY"
	ElementInstanceFilterTypeINTERMEDIATECATCHEVENT       ElementInstanceFilterType = "INTERMEDIATE_CATCH_EVENT"
	ElementInstanceFilterTypeINTERMEDIATETHROWEVENT       ElementInstanceFilterType = "INTERMEDIATE_THROW_EVENT"
	ElementInstanceFilterTypeMANUALTASK                   ElementInstanceFilterType = "MANUAL_TASK"
	ElementInstanceFilterTypeMULTIINSTANCEBODY            ElementInstanceFilterType = "MULTI_INSTANCE_BODY"
	ElementInstanceFilterTypePARALLELGATEWAY              ElementInstanceFilterType = "PARALLEL_GATEWAY"
	ElementInstanceFilterTypePROCESS                      ElementInstanceFilterType = "PROCESS"
	ElementInstanceFilterTypeRECEIVETASK                  ElementInstanceFilterType = "RECEIVE_TASK"
	ElementInstanceFilterTypeSCRIPTTASK                   ElementInstanceFilterType = "SCRIPT_TASK"
	ElementInstanceFilterTypeSENDTASK                     ElementInstanceFilterType = "SEND_TASK"
	ElementInstanceFilterTypeSEQUENCEFLOW                 ElementInstanceFilterType = "SEQUENCE_FLOW"
	ElementInstanceFilterTypeSERVICETASK                  ElementInstanceFilterType = "SERVICE_TASK"
	ElementInstanceFilterTypeSTARTEVENT                   ElementInstanceFilterType = "START_EVENT"
	ElementInstanceFilterTypeSUBPROCESS                   ElementInstanceFilterType = "SUB_PROCESS"
	ElementInstanceFilterTypeTASK                         ElementInstanceFilterType = "TASK"
	ElementInstanceFilterTypeUNKNOWN                      ElementInstanceFilterType = "UNKNOWN"
	ElementInstanceFilterTypeUNSPECIFIED                  ElementInstanceFilterType = "UNSPECIFIED"
	ElementInstanceFilterTypeUSERTASK                     ElementInstanceFilterType = "USER_TASK"
)

// Defines values for ElementInstanceResultType.
const (
	ElementInstanceResultTypeADHOCSUBPROCESS              ElementInstanceResultType = "AD_HOC_SUB_PROCESS"
	ElementInstanceResultTypeADHOCSUBPROCESSINNERINSTANCE ElementInstanceResultType = "AD_HOC_SUB_PROCESS_INNER_INSTANCE"
	ElementInstanceResultTypeBOUNDARYEVENT                ElementInstanceResultType = "BOUNDARY_EVENT"
	ElementInstanceResultTypeBUSINESSRULETASK             ElementInstanceResultType = "BUSINESS_RULE_TASK"
	ElementInstanceResultTypeCALLACTIVITY                 ElementInstanceResultType = "CALL_ACTIVITY"
	ElementInstanceResultTypeENDEVENT                     ElementInstanceResultType = "END_EVENT"
	ElementInstanceResultTypeEVENTBASEDGATEWAY            ElementInstanceResultType = "EVENT_BASED_GATEWAY"
	ElementInstanceResultTypeEVENTSUBPROCESS              ElementInstanceResultType = "EVENT_SUB_PROCESS"
	ElementInstanceResultTypeEXCLUSIVEGATEWAY             ElementInstanceResultType = "EXCLUSIVE_GATEWAY"
	ElementInstanceResultTypeINCLUSIVEGATEWAY             ElementInstanceResultType = "INCLUSIVE_GATEWAY"
	ElementInstanceResultTypeINTERMEDIATECATCHEVENT       ElementInstanceResultType = "INTERMEDIATE_CATCH_EVENT"
	ElementInstanceResultTypeINTERMEDIATETHROWEVENT       ElementInstanceResultType = "INTERMEDIATE_THROW_EVENT"
	ElementInstanceResultTypeMANUALTASK                   ElementInstanceResultType = "MANUAL_TASK"
	ElementInstanceResultTypeMULTIINSTANCEBODY            ElementInstanceResultType = "MULTI_INSTANCE_BODY"
	ElementInstanceResultTypePARALLELGATEWAY              ElementInstanceResultType = "PARALLEL_GATEWAY"
	ElementInstanceResultTypePROCESS                      ElementInstanceResultType = "PROCESS"
	ElementInstanceResultTypeRECEIVETASK                  ElementInstanceResultType = "RECEIVE_TASK"
	ElementInstanceResultTypeSCRIPTTASK                   ElementInstanceResultType = "SCRIPT_TASK"
	ElementInstanceResultTypeSENDTASK                     ElementInstanceResultType = "SEND_TASK"
	ElementInstanceResultTypeSEQUENCEFLOW                 ElementInstanceResultType = "SEQUENCE_FLOW"
	ElementInstanceResultTypeSERVICETASK                  ElementInstanceResultType = "SERVICE_TASK"
	ElementInstanceResultTypeSTARTEVENT                   ElementInstanceResultType = "START_EVENT"
	ElementInstanceResultTypeSUBPROCESS                   ElementInstanceResultType = "SUB_PROCESS"
	ElementInstanceResultTypeTASK                         ElementInstanceResultType = "TASK"
	ElementInstanceResultTypeUNKNOWN                      ElementInstanceResultType = "UNKNOWN"
	ElementInstanceResultTypeUNSPECIFIED                  ElementInstanceResultType = "UNSPECIFIED"
	ElementInstanceResultTypeUSERTASK                     ElementInstanceResultType = "USER_TASK"
)

// Defines values for ElementInstanceSearchQuerySortRequestField.
const (
	ElementInstanceSearchQuerySortRequestFieldElementId            ElementInstanceSearchQuerySortRequestField = "elementId"
	ElementInstanceSearchQuerySortRequestFieldElementInstanceKey   ElementInstanceSearchQuerySortRequestField = "elementInstanceKey"
	ElementInstanceSearchQuerySortRequestFieldElementName          ElementInstanceSearchQuerySortRequestField = "elementName"
	ElementInstanceSearchQuerySortRequestFieldEndDate              ElementInstanceSearchQuerySortRequestField = "endDate"
	ElementInstanceSearchQuerySortRequestFieldIncidentKey          ElementInstanceSearchQuerySortRequestField = "incidentKey"
	ElementInstanceSearchQuerySortRequestFieldProcessDefinitionId  ElementInstanceSearchQuerySortRequestField = "processDefinitionId"
	ElementInstanceSearchQuerySortRequestFieldProcessDefinitionKey ElementInstanceSearchQuerySortRequestField = "processDefinitionKey"
	ElementInstanceSearchQuerySortRequestFieldProcessInstanceKey   ElementInstanceSearchQuerySortRequestField = "processInstanceKey"
	ElementInstanceSearchQuerySortRequestFieldStartDate            ElementInstanceSearchQuerySortRequestField = "startDate"
	ElementInstanceSearchQuerySortRequestFieldState                ElementInstanceSearchQuerySortRequestField = "state"
	ElementInstanceSearchQuerySortRequestFieldTenantId             ElementInstanceSearchQuerySortRequestField = "tenantId"
	ElementInstanceSearchQuerySortRequestFieldType                 ElementInstanceSearchQuerySortRequestField = "type"
)

// Defines values for EventOperationKind.
const (
	Event EventOperationKind = "event"
)

// Defines values for GroupClientSearchQuerySortRequestField.
const (
	GroupClientSearchQuerySortRequestFieldClientId GroupClientSearchQuerySortRequestField = "clientId"
)

// Defines values for GroupSearchQuerySortRequestField.
const (
	GroupSearchQuerySortRequestFieldGroupId GroupSearchQuerySortRequestField = "groupId"
	GroupSearchQuerySortRequestFieldName    GroupSearchQuerySortRequestField = "name"
)

// Defines values for GroupUserSearchQuerySortRequestField.
const (
	GroupUserSearchQuerySortRequestFieldUsername GroupUserSearchQuerySortRequestField = "username"
)

// Defines values for IncidentFilterErrorType.
const (
	IncidentFilterErrorTypeADHOCSUBPROCESSNORETRIES   IncidentFilterErrorType = "AD_HOC_SUB_PROCESS_NO_RETRIES"
	IncidentFilterErrorTypeCALLEDDECISIONERROR        IncidentFilterErrorType = "CALLED_DECISION_ERROR"
	IncidentFilterErrorTypeCALLEDELEMENTERROR         IncidentFilterErrorType = "CALLED_ELEMENT_ERROR"
	IncidentFilterErrorTypeCONDITIONERROR             IncidentFilterErrorType = "CONDITION_ERROR"
	IncidentFilterErrorTypeDECISIONEVALUATIONERROR    IncidentFilterErrorType = "DECISION_EVALUATION_ERROR"
	IncidentFilterErrorTypeEXECUTIONLISTENERNORETRIES IncidentFilterErrorType = "EXECUTION_LISTENER_NO_RETRIES"
	IncidentFilterErrorTypeEXTRACTVALUEERROR          IncidentFilterErrorType = "EXTRACT_VALUE_ERROR"
	IncidentFilterErrorTypeFORMNOTFOUND               IncidentFilterErrorType = "FORM_NOT_FOUND"
	IncidentFilterErrorTypeIOMAPPINGERROR             IncidentFilterErrorType = "IO_MAPPING_ERROR"
	IncidentFilterErrorTypeJOBNORETRIES               IncidentFilterErrorType = "JOB_NO_RETRIES"
	IncidentFilterErrorTypeMESSAGESIZEEXCEEDED        IncidentFilterErrorType = "MESSAGE_SIZE_EXCEEDED"
	IncidentFilterErrorTypeRESOURCENOTFOUND           IncidentFilterErrorType = "RESOURCE_NOT_FOUND"
	IncidentFilterErrorTypeTASKLISTENERNORETRIES      IncidentFilterErrorType = "TASK_LISTENER_NO_RETRIES"
	IncidentFilterErrorTypeUNHANDLEDERROREVENT        IncidentFilterErrorType = "UNHANDLED_ERROR_EVENT"
	IncidentFilterErrorTypeUNKNOWN                    IncidentFilterErrorType = "UNKNOWN"
	IncidentFilterErrorTypeUNSPECIFIED                IncidentFilterErrorType = "UNSPECIFIED"
)

// Defines values for IncidentFilterState.
const (
	IncidentFilterStateACTIVE   IncidentFilterState = "ACTIVE"
	IncidentFilterStateMIGRATED IncidentFilterState = "MIGRATED"
	IncidentFilterStatePENDING  IncidentFilterState = "PENDING"
	IncidentFilterStateRESOLVED IncidentFilterState = "RESOLVED"
)

// Defines values for IncidentResultErrorType.
const (
	IncidentResultErrorTypeADHOCSUBPROCESSNORETRIES   IncidentResultErrorType = "AD_HOC_SUB_PROCESS_NO_RETRIES"
	IncidentResultErrorTypeCALLEDDECISIONERROR        IncidentResultErrorType = "CALLED_DECISION_ERROR"
	IncidentResultErrorTypeCALLEDELEMENTERROR         IncidentResultErrorType = "CALLED_ELEMENT_ERROR"
	IncidentResultErrorTypeCONDITIONERROR             IncidentResultErrorType = "CONDITION_ERROR"
	IncidentResultErrorTypeDECISIONEVALUATIONERROR    IncidentResultErrorType = "DECISION_EVALUATION_ERROR"
	IncidentResultErrorTypeEXECUTIONLISTENERNORETRIES IncidentResultErrorType = "EXECUTION_LISTENER_NO_RETRIES"
	IncidentResultErrorTypeEXTRACTVALUEERROR          IncidentResultErrorType = "EXTRACT_VALUE_ERROR"
	IncidentResultErrorTypeFORMNOTFOUND               IncidentResultErrorType = "FORM_NOT_FOUND"
	IncidentResultErrorTypeIOMAPPINGERROR             IncidentResultErrorType = "IO_MAPPING_ERROR"
	IncidentResultErrorTypeJOBNORETRIES               IncidentResultErrorType = "JOB_NO_RETRIES"
	IncidentResultErrorTypeMESSAGESIZEEXCEEDED        IncidentResultErrorType = "MESSAGE_SIZE_EXCEEDED"
	IncidentResultErrorTypeRESOURCENOTFOUND           IncidentResultErrorType = "RESOURCE_NOT_FOUND"
	IncidentResultErrorTypeTASKLISTENERNORETRIES      IncidentResultErrorType = "TASK_LISTENER_NO_RETRIES"
	IncidentResultErrorTypeUNHANDLEDERROREVENT        IncidentResultErrorType = "UNHANDLED_ERROR_EVENT"
	IncidentResultErrorTypeUNKNOWN                    IncidentResultErrorType = "UNKNOWN"
	IncidentResultErrorTypeUNSPECIFIED                IncidentResultErrorType = "UNSPECIFIED"
)

// Defines values for IncidentResultState.
const (
	IncidentResultStateACTIVE   IncidentResultState = "ACTIVE"
	IncidentResultStateMIGRATED IncidentResultState = "MIGRATED"
	IncidentResultStatePENDING  IncidentResultState = "PENDING"
	IncidentResultStateRESOLVED IncidentResultState = "RESOLVED"
)

// Defines values for IncidentSearchQuerySortRequestField.
const (
	IncidentSearchQuerySortRequestFieldCreationTime         IncidentSearchQuerySortRequestField = "creationTime"
	IncidentSearchQuerySortRequestFieldElementId            IncidentSearchQuerySortRequestField = "elementId"
	IncidentSearchQuerySortRequestFieldElementInstanceKey   IncidentSearchQuerySortRequestField = "elementInstanceKey"
	IncidentSearchQuerySortRequestFieldErrorMessage         IncidentSearchQuerySortRequestField = "errorMessage"
	IncidentSearchQuerySortRequestFieldErrorType            IncidentSearchQuerySortRequestField = "errorType"
	IncidentSearchQuerySortRequestFieldIncidentKey          IncidentSearchQuerySortRequestField = "incidentKey"
	IncidentSearchQuerySortRequestFieldJobKey               IncidentSearchQuerySortRequestField = "jobKey"
	IncidentSearchQuerySortRequestFieldProcessDefinitionId  IncidentSearchQuerySortRequestField = "processDefinitionId"
	IncidentSearchQuerySortRequestFieldProcessDefinitionKey IncidentSearchQuerySortRequestField = "processDefinitionKey"
	IncidentSearchQuerySortRequestFieldProcessInstanceKey   IncidentSearchQuerySortRequestField = "processInstanceKey"
	IncidentSearchQuerySortRequestFieldState                IncidentSearchQuerySortRequestField = "state"
	IncidentSearchQuerySortRequestFieldTenantId             IncidentSearchQuerySortRequestField = "tenantId"
)

// Defines values for JobResultType.
const (
	JobResultTypeAdHocSubProcess JobResultType = "adHocSubProcess"
	JobResultTypeUserTask        JobResultType = "userTask"
)

// Defines values for JobResultAdHocSubProcessType.
const (
	JobResultAdHocSubProcessTypeAdHocSubProcess JobResultAdHocSubProcessType = "adHocSubProcess"
	JobResultAdHocSubProcessTypeUserTask        JobResultAdHocSubProcessType = "userTask"
)

// Defines values for JobResultUserTaskType.
const (
	AdHocSubProcess JobResultUserTaskType = "adHocSubProcess"
	UserTask        JobResultUserTaskType = "userTask"
)

// Defines values for JobSearchQuerySortRequestField.
const (
	JobSearchQuerySortRequestFieldDeadline                 JobSearchQuerySortRequestField = "deadline"
	JobSearchQuerySortRequestFieldDeniedReason             JobSearchQuerySortRequestField = "deniedReason"
	JobSearchQuerySortRequestFieldElementId                JobSearchQuerySortRequestField = "elementId"
	JobSearchQuerySortRequestFieldElementInstanceKey       JobSearchQuerySortRequestField = "elementInstanceKey"
	JobSearchQuerySortRequestFieldEndTime                  JobSearchQuerySortRequestField = "endTime"
	JobSearchQuerySortRequestFieldErrorCode                JobSearchQuerySortRequestField = "errorCode"
	JobSearchQuerySortRequestFieldErrorMessage             JobSearchQuerySortRequestField = "errorMessage"
	JobSearchQuerySortRequestFieldHasFailedWithRetriesLeft JobSearchQuerySortRequestField = "hasFailedWithRetriesLeft"
	JobSearchQuerySortRequestFieldIsDenied                 JobSearchQuerySortRequestField = "isDenied"
	JobSearchQuerySortRequestFieldJobKey                   JobSearchQuerySortRequestField = "jobKey"
	JobSearchQuerySortRequestFieldKind                     JobSearchQuerySortRequestField = "kind"
	JobSearchQuerySortRequestFieldListenerEventType        JobSearchQuerySortRequestField = "listenerEventType"
	JobSearchQuerySortRequestFieldProcessDefinitionId      JobSearchQuerySortRequestField = "processDefinitionId"
	JobSearchQuerySortRequestFieldProcessDefinitionKey     JobSearchQuerySortRequestField = "processDefinitionKey"
	JobSearchQuerySortRequestFieldProcessInstanceKey       JobSearchQuerySortRequestField = "processInstanceKey"
	JobSearchQuerySortRequestFieldRetries                  JobSearchQuerySortRequestField = "retries"
	JobSearchQuerySortRequestFieldState                    JobSearchQuerySortRequestField = "state"
	JobSearchQuerySortRequestFieldTenantId                 JobSearchQuerySortRequestField = "tenantId"
	JobSearchQuerySortRequestFieldType                     JobSearchQuerySortRequestField = "type"
	JobSearchQuerySortRequestFieldWorker                   JobSearchQuerySortRequestField = "worker"
)

// Defines values for MappingRuleSearchQuerySortRequestField.
const (
	MappingRuleSearchQuerySortRequestFieldClaimName     MappingRuleSearchQuerySortRequestField = "claimName"
	MappingRuleSearchQuerySortRequestFieldClaimValue    MappingRuleSearchQuerySortRequestField = "claimValue"
	MappingRuleSearchQuerySortRequestFieldMappingRuleId MappingRuleSearchQuerySortRequestField = "mappingRuleId"
	MappingRuleSearchQuerySortRequestFieldName          MappingRuleSearchQuerySortRequestField = "name"
)

// Defines values for MessageSubscriptionSearchQuerySortRequestField.
const (
	MessageSubscriptionSearchQuerySortRequestFieldCorrelationKey          MessageSubscriptionSearchQuerySortRequestField = "correlationKey"
	MessageSubscriptionSearchQuerySortRequestFieldElementId               MessageSubscriptionSearchQuerySortRequestField = "elementId"
	MessageSubscriptionSearchQuerySortRequestFieldElementInstanceKey      MessageSubscriptionSearchQuerySortRequestField = "elementInstanceKey"
	MessageSubscriptionSearchQuerySortRequestFieldLastUpdatedDate         MessageSubscriptionSearchQuerySortRequestField = "lastUpdatedDate"
	MessageSubscriptionSearchQuerySortRequestFieldMessageName             MessageSubscriptionSearchQuerySortRequestField = "messageName"
	MessageSubscriptionSearchQuerySortRequestFieldMessageSubscriptionKey  MessageSubscriptionSearchQuerySortRequestField = "messageSubscriptionKey"
	MessageSubscriptionSearchQuerySortRequestFieldMessageSubscriptionType MessageSubscriptionSearchQuerySortRequestField = "messageSubscriptionType"
	MessageSubscriptionSearchQuerySortRequestFieldProcessDefinitionId     MessageSubscriptionSearchQuerySortRequestField = "processDefinitionId"
	MessageSubscriptionSearchQuerySortRequestFieldProcessInstanceKey      MessageSubscriptionSearchQuerySortRequestField = "processInstanceKey"
	MessageSubscriptionSearchQuerySortRequestFieldTenantId                MessageSubscriptionSearchQuerySortRequestField = "tenantId"
)

// Defines values for MessageSubscriptionTypeEnum.
const (
	MessageSubscriptionTypeEnumCREATED  MessageSubscriptionTypeEnum = "CREATED"
	MessageSubscriptionTypeEnumMIGRATED MessageSubscriptionTypeEnum = "MIGRATED"
)

// Defines values for PartitionHealth.
const (
	Dead      PartitionHealth = "dead"
	Healthy   PartitionHealth = "healthy"
	Unhealthy PartitionHealth = "unhealthy"
)

// Defines values for PartitionRole.
const (
	Follower PartitionRole = "follower"
	Inactive PartitionRole = "inactive"
	Leader   PartitionRole = "leader"
)

// Defines values for PatchOperationKind.
const (
	Patch PatchOperationKind = "patch"
)

// Defines values for ProcessDefinitionSearchQuerySortRequestField.
const (
	ProcessDefinitionSearchQuerySortRequestFieldName                 ProcessDefinitionSearchQuerySortRequestField = "name"
	ProcessDefinitionSearchQuerySortRequestFieldProcessDefinitionId  ProcessDefinitionSearchQuerySortRequestField = "processDefinitionId"
	ProcessDefinitionSearchQuerySortRequestFieldProcessDefinitionKey ProcessDefinitionSearchQuerySortRequestField = "processDefinitionKey"
	ProcessDefinitionSearchQuerySortRequestFieldResourceName         ProcessDefinitionSearchQuerySortRequestField = "resourceName"
	ProcessDefinitionSearchQuerySortRequestFieldTenantId             ProcessDefinitionSearchQuerySortRequestField = "tenantId"
	ProcessDefinitionSearchQuerySortRequestFieldVersion              ProcessDefinitionSearchQuerySortRequestField = "version"
	ProcessDefinitionSearchQuerySortRequestFieldVersionTag           ProcessDefinitionSearchQuerySortRequestField = "versionTag"
)

// Defines values for ProcessInstanceSearchQuerySortRequestField.
const (
	ProcessInstanceSearchQuerySortRequestFieldEndDate                     ProcessInstanceSearchQuerySortRequestField = "endDate"
	ProcessInstanceSearchQuerySortRequestFieldHasIncident                 ProcessInstanceSearchQuerySortRequestField = "hasIncident"
	ProcessInstanceSearchQuerySortRequestFieldParentElementInstanceKey    ProcessInstanceSearchQuerySortRequestField = "parentElementInstanceKey"
	ProcessInstanceSearchQuerySortRequestFieldParentProcessInstanceKey    ProcessInstanceSearchQuerySortRequestField = "parentProcessInstanceKey"
	ProcessInstanceSearchQuerySortRequestFieldProcessDefinitionId         ProcessInstanceSearchQuerySortRequestField = "processDefinitionId"
	ProcessInstanceSearchQuerySortRequestFieldProcessDefinitionKey        ProcessInstanceSearchQuerySortRequestField = "processDefinitionKey"
	ProcessInstanceSearchQuerySortRequestFieldProcessDefinitionName       ProcessInstanceSearchQuerySortRequestField = "processDefinitionName"
	ProcessInstanceSearchQuerySortRequestFieldProcessDefinitionVersion    ProcessInstanceSearchQuerySortRequestField = "processDefinitionVersion"
	ProcessInstanceSearchQuerySortRequestFieldProcessDefinitionVersionTag ProcessInstanceSearchQuerySortRequestField = "processDefinitionVersionTag"
	ProcessInstanceSearchQuerySortRequestFieldProcessInstanceKey          ProcessInstanceSearchQuerySortRequestField = "processInstanceKey"
	ProcessInstanceSearchQuerySortRequestFieldStartDate                   ProcessInstanceSearchQuerySortRequestField = "startDate"
	ProcessInstanceSearchQuerySortRequestFieldState                       ProcessInstanceSearchQuerySortRequestField = "state"
	ProcessInstanceSearchQuerySortRequestFieldTenantId                    ProcessInstanceSearchQuerySortRequestField = "tenantId"
)

// Defines values for QueryOperationKind.
const (
	Query QueryOperationKind = "query"
)

// Defines values for RoleClientSearchQuerySortRequestField.
const (
	RoleClientSearchQuerySortRequestFieldClientId RoleClientSearchQuerySortRequestField = "clientId"
)

// Defines values for RoleGroupSearchQuerySortRequestField.
const (
	RoleGroupSearchQuerySortRequestFieldGroupId RoleGroupSearchQuerySortRequestField = "groupId"
)

// Defines values for RoleSearchQuerySortRequestField.
const (
	RoleSearchQuerySortRequestFieldName   RoleSearchQuerySortRequestField = "name"
	RoleSearchQuerySortRequestFieldRoleId RoleSearchQuerySortRequestField = "roleId"
)

// Defines values for RoleUserSearchQuerySortRequestField.
const (
	RoleUserSearchQuerySortRequestFieldUsername RoleUserSearchQuerySortRequestField = "username"
)

// Defines values for RuntimeInstructionType.
const (
	TERMINATEPROCESSINSTANCE RuntimeInstructionType = "TERMINATE_PROCESS_INSTANCE"
)

// Defines values for SortOrderEnum.
const (
	ASC  SortOrderEnum = "ASC"
	DESC SortOrderEnum = "DESC"
)

// Defines values for TenantClientSearchQuerySortRequestField.
const (
	ClientId TenantClientSearchQuerySortRequestField = "clientId"
)

// Defines values for TenantGroupSearchQuerySortRequestField.
const (
	TenantGroupSearchQuerySortRequestFieldGroupId TenantGroupSearchQuerySortRequestField = "groupId"
)

// Defines values for TenantSearchQuerySortRequestField.
const (
	TenantSearchQuerySortRequestFieldKey      TenantSearchQuerySortRequestField = "key"
	TenantSearchQuerySortRequestFieldName     TenantSearchQuerySortRequestField = "name"
	TenantSearchQuerySortRequestFieldTenantId TenantSearchQuerySortRequestField = "tenantId"
)

// Defines values for TenantUserSearchQuerySortRequestField.
const (
	TenantUserSearchQuerySortRequestFieldUsername TenantUserSearchQuerySortRequestField = "username"
)

// Defines values for UpdateOperationKind.
const (
	Update UpdateOperationKind = "update"
)

// Defines values for UserSearchQuerySortRequestField.
const (
	UserSearchQuerySortRequestFieldEmail    UserSearchQuerySortRequestField = "email"
	UserSearchQuerySortRequestFieldName     UserSearchQuerySortRequestField = "name"
	UserSearchQuerySortRequestFieldUsername UserSearchQuerySortRequestField = "username"
)

// Defines values for UserTaskSearchQuerySortRequestField.
const (
	UserTaskSearchQuerySortRequestFieldCompletionDate UserTaskSearchQuerySortRequestField = "completionDate"
	UserTaskSearchQuerySortRequestFieldCreationDate   UserTaskSearchQuerySortRequestField = "creationDate"
	UserTaskSearchQuerySortRequestFieldDueDate        UserTaskSearchQuerySortRequestField = "dueDate"
	UserTaskSearchQuerySortRequestFieldFollowUpDate   UserTaskSearchQuerySortRequestField = "followUpDate"
	UserTaskSearchQuerySortRequestFieldName           UserTaskSearchQuerySortRequestField = "name"
	UserTaskSearchQuerySortRequestFieldPriority       UserTaskSearchQuerySortRequestField = "priority"
)

// Defines values for UserTaskStateEnum.
const (
	UserTaskStateEnumASSIGNING  UserTaskStateEnum = "ASSIGNING"
	UserTaskStateEnumCANCELED   UserTaskStateEnum = "CANCELED"
	UserTaskStateEnumCANCELING  UserTaskStateEnum = "CANCELING"
	UserTaskStateEnumCOMPLETED  UserTaskStateEnum = "COMPLETED"
	UserTaskStateEnumCOMPLETING UserTaskStateEnum = "COMPLETING"
	UserTaskStateEnumCREATED    UserTaskStateEnum = "CREATED"
	UserTaskStateEnumCREATING   UserTaskStateEnum = "CREATING"
	UserTaskStateEnumFAILED     UserTaskStateEnum = "FAILED"
	UserTaskStateEnumUPDATING   UserTaskStateEnum = "UPDATING"
)

// Defines values for UserTaskVariableSearchQuerySortRequestField.
const (
	UserTaskVariableSearchQuerySortRequestFieldName               UserTaskVariableSearchQuerySortRequestField = "name"
	UserTaskVariableSearchQuerySortRequestFieldProcessInstanceKey UserTaskVariableSearchQuerySortRequestField = "processInstanceKey"
	UserTaskVariableSearchQuerySortRequestFieldScopeKey           UserTaskVariableSearchQuerySortRequestField = "scopeKey"
	UserTaskVariableSearchQuerySortRequestFieldTenantId           UserTaskVariableSearchQuerySortRequestField = "tenantId"
	UserTaskVariableSearchQuerySortRequestFieldValue              UserTaskVariableSearchQuerySortRequestField = "value"
	UserTaskVariableSearchQuerySortRequestFieldVariableKey        UserTaskVariableSearchQuerySortRequestField = "variableKey"
)

// Defines values for VariableSearchQuerySortRequestField.
const (
	VariableSearchQuerySortRequestFieldName               VariableSearchQuerySortRequestField = "name"
	VariableSearchQuerySortRequestFieldProcessInstanceKey VariableSearchQuerySortRequestField = "processInstanceKey"
	VariableSearchQuerySortRequestFieldScopeKey           VariableSearchQuerySortRequestField = "scopeKey"
	VariableSearchQuerySortRequestFieldTenantId           VariableSearchQuerySortRequestField = "tenantId"
	VariableSearchQuerySortRequestFieldValue              VariableSearchQuerySortRequestField = "value"
	VariableSearchQuerySortRequestFieldVariableKey        VariableSearchQuerySortRequestField = "variableKey"
)

// ActivatedJobResult defines model for ActivatedJobResult.
type ActivatedJobResult struct {
	// CustomHeaders A set of custom headers defined during modelling; returned as a serialized JSON document.
	CustomHeaders map[string]interface{} `json:"customHeaders"`

	// Deadline When the job can be activated again, sent as a UNIX epoch timestamp.
	Deadline int `json:"deadline"`

	// ElementId The associated task element ID.
	ElementId ElementId `json:"elementId"`

	// ElementInstanceKey The unique key identifying the associated task, unique within the scope of the process instance.
	ElementInstanceKey ElementInstanceKey `json:"elementInstanceKey"`

	// JobKey The key, a unique identifier for the job.
	JobKey JobKey `json:"jobKey"`

	// Kind The job kind.
	Kind JobKindEnum `json:"kind"`

	// ListenerEventType The listener event type of the job.
	ListenerEventType JobListenerEventTypeEnum `json:"listenerEventType"`

	// ProcessDefinitionId The bpmn process ID of the job's process definition.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The key of the job's process definition.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessDefinitionVersion The version of the job's process definition.
	ProcessDefinitionVersion int32 `json:"processDefinitionVersion"`

	// ProcessInstanceKey The job's process instance key.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// Retries The amount of retries left to this job (should always be positive).
	Retries int32 `json:"retries"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId TenantId `json:"tenantId"`

	// Type The type of the job (should match what was requested).
	Type string `json:"type"`

	// UserTask Contains properties of a user task.
	UserTask *UserTaskProperties `json:"userTask,omitempty"`

	// Variables All variables visible to the task scope, computed at activation time.
	Variables map[string]interface{} `json:"variables"`

	// Worker The name of the worker which activated this job.
	Worker string `json:"worker"`
}

// AdHocSubProcessActivateActivitiesInstruction defines model for AdHocSubProcessActivateActivitiesInstruction.
type AdHocSubProcessActivateActivitiesInstruction struct {
	// CancelRemainingInstances Whether to cancel remaining instances of the ad-hoc sub-process.
	CancelRemainingInstances *bool `json:"cancelRemainingInstances,omitempty"`

	// Elements Activities to activate.
	Elements []AdHocSubProcessActivateActivityReference `json:"elements"`
}

// AdHocSubProcessActivateActivityReference defines model for AdHocSubProcessActivateActivityReference.
type AdHocSubProcessActivateActivityReference struct {
	// ElementId The ID of the element that should be activated.
	ElementId ElementId `json:"elementId"`

	// Variables Variables to be set when activating the element.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// AdvancedBatchOperationItemStateFilter Advanced BatchOperationItemStateEnum filter.
type AdvancedBatchOperationItemStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *BatchOperationItemStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]BatchOperationItemStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *BatchOperationItemStateEnum `json:"$neq,omitempty"`
}

// AdvancedBatchOperationStateFilter Advanced BatchOperationStateEnum filter.
type AdvancedBatchOperationStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *BatchOperationStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]BatchOperationStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *BatchOperationStateEnum `json:"$neq,omitempty"`
}

// AdvancedBatchOperationTypeFilter Advanced BatchOperationTypeEnum filter.
type AdvancedBatchOperationTypeFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *BatchOperationTypeEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]BatchOperationTypeEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *BatchOperationTypeEnum `json:"$neq,omitempty"`
}

// AdvancedDateTimeFilter Advanced date-time filter.
type AdvancedDateTimeFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *time.Time `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// Gt Greater than comparison with the provided value.
	Gt *time.Time `json:"$gt,omitempty"`

	// Gte Greater than or equal comparison with the provided value.
	Gte *time.Time `json:"$gte,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]time.Time `json:"$in,omitempty"`

	// Lt Lower than comparison with the provided value.
	Lt *time.Time `json:"$lt,omitempty"`

	// Lte Lower than or equal comparison with the provided value.
	Lte *time.Time `json:"$lte,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *time.Time `json:"$neq,omitempty"`
}

// AdvancedDecisionDefinitionKeyFilter Advanced DecisionDefinitionKey filter.
type AdvancedDecisionDefinitionKeyFilter struct {
	// Eq System-generated key for a decision definition.
	Eq *DecisionDefinitionKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]DecisionDefinitionKey `json:"$in,omitempty"`

	// Neq System-generated key for a decision definition.
	Neq *DecisionDefinitionKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]DecisionDefinitionKey `json:"$notIn,omitempty"`
}

// AdvancedElementInstanceKeyFilter Advanced ElementInstanceKey filter.
type AdvancedElementInstanceKeyFilter struct {
	// Eq System-generated key for a element instance.
	Eq *ElementInstanceKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ElementInstanceKey `json:"$in,omitempty"`

	// Neq System-generated key for a element instance.
	Neq *ElementInstanceKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]ElementInstanceKey `json:"$notIn,omitempty"`
}

// AdvancedElementInstanceStateFilter Advanced ElementInstanceStateEnum filter.
type AdvancedElementInstanceStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *ElementInstanceStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ElementInstanceStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *ElementInstanceStateEnum `json:"$neq,omitempty"`
}

// AdvancedIntegerFilter Advanced integer (int32) filter.
type AdvancedIntegerFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *int32 `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// Gt Greater than comparison with the provided value.
	Gt *int32 `json:"$gt,omitempty"`

	// Gte Greater than or equal comparison with the provided value.
	Gte *int32 `json:"$gte,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]int32 `json:"$in,omitempty"`

	// Lt Lower than comparison with the provided value.
	Lt *int32 `json:"$lt,omitempty"`

	// Lte Lower than or equal comparison with the provided value.
	Lte *int32 `json:"$lte,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *int32 `json:"$neq,omitempty"`
}

// AdvancedJobKeyFilter Advanced JobKey filter.
type AdvancedJobKeyFilter struct {
	// Eq System-generated key for a job.
	Eq *JobKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]JobKey `json:"$in,omitempty"`

	// Neq System-generated key for a job.
	Neq *JobKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]JobKey `json:"$notIn,omitempty"`
}

// AdvancedJobKindFilter Advanced JobKindEnum filter.
type AdvancedJobKindFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *JobKindEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]JobKindEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *JobKindEnum `json:"$neq,omitempty"`
}

// AdvancedJobListenerEventTypeFilter Advanced JobListenerEventTypeEnum filter.
type AdvancedJobListenerEventTypeFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *JobListenerEventTypeEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]JobListenerEventTypeEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *JobListenerEventTypeEnum `json:"$neq,omitempty"`
}

// AdvancedJobStateFilter Advanced JobStateEnum filter.
type AdvancedJobStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *JobStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]JobStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *JobStateEnum `json:"$neq,omitempty"`
}

// AdvancedMessageSubscriptionKeyFilter Advanced MessageSubscriptionKey filter.
type AdvancedMessageSubscriptionKeyFilter struct {
	// Eq System-generated key for a message subscription.
	Eq *MessageSubscriptionKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]MessageSubscriptionKey `json:"$in,omitempty"`

	// Neq System-generated key for a message subscription.
	Neq *MessageSubscriptionKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]MessageSubscriptionKey `json:"$notIn,omitempty"`
}

// AdvancedMessageSubscriptionTypeFilter Advanced MessageSubscriptionTypeEnum filter
type AdvancedMessageSubscriptionTypeFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *MessageSubscriptionTypeEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]MessageSubscriptionTypeEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *MessageSubscriptionTypeEnum `json:"$neq,omitempty"`
}

// AdvancedProcessDefinitionKeyFilter Advanced ProcessDefinitionKey filter.
type AdvancedProcessDefinitionKeyFilter struct {
	// Eq System-generated key for a deployed process definition.
	Eq *ProcessDefinitionKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool                   `json:"$exists,omitempty"`
	In     *[]ProcessDefinitionKey `json:"$in,omitempty"`

	// Neq System-generated key for a deployed process definition.
	Neq   *ProcessDefinitionKey   `json:"$neq,omitempty"`
	NotIn *[]ProcessDefinitionKey `json:"$notIn,omitempty"`
}

// AdvancedProcessInstanceKeyFilter Advanced ProcessInstanceKey filter.
type AdvancedProcessInstanceKeyFilter struct {
	// Eq System-generated key for a process instance.
	Eq *ProcessInstanceKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ProcessInstanceKey `json:"$in,omitempty"`

	// Neq System-generated key for a process instance.
	Neq *ProcessInstanceKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]ProcessInstanceKey `json:"$notIn,omitempty"`
}

// AdvancedProcessInstanceStateFilter Advanced ProcessInstanceStateEnum filter.
type AdvancedProcessInstanceStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *ProcessInstanceStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ProcessInstanceStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *ProcessInstanceStateEnum `json:"$neq,omitempty"`
}

// AdvancedScopeKeyFilter Advanced ScopeKey filter.
type AdvancedScopeKeyFilter struct {
	// Eq System-generated key for a scope.
	Eq *ScopeKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]ScopeKey `json:"$in,omitempty"`

	// Neq System-generated key for a scope.
	Neq *ScopeKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]ScopeKey `json:"$notIn,omitempty"`
}

// AdvancedStringFilter defines model for AdvancedStringFilter.
type AdvancedStringFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *string `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]string `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *string `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]string `json:"$notIn,omitempty"`
}

// AdvancedUserTaskStateFilter Advanced UserTaskStateEnum filter.
type AdvancedUserTaskStateFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *UserTaskStateEnum `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]UserTaskStateEnum `json:"$in,omitempty"`

	// Like Checks if the property matches the provided like value.
	//
	// Supported wildcard characters are:
	//
	// * `*`: matches zero, one, or multiple characters.
	// * `?`: matches one, single character.
	//
	// Wildcard characters can be escaped with backslash, for instance: `\*`.
	Like *LikeFilterProperty `json:"$like,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *UserTaskStateEnum `json:"$neq,omitempty"`
}

// AdvancedVariableKeyFilter Advanced VariableKey filter.
type AdvancedVariableKeyFilter struct {
	// Eq System-generated key for a variable.
	Eq *VariableKey `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]VariableKey `json:"$in,omitempty"`

	// Neq System-generated key for a variable.
	Neq *VariableKey `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]VariableKey `json:"$notIn,omitempty"`
}

// AuthorizationCreateResult defines model for AuthorizationCreateResult.
type AuthorizationCreateResult struct {
	// AuthorizationKey The key of the created authorization.
	AuthorizationKey *AuthorizationKey `json:"authorizationKey,omitempty"`
}

// AuthorizationFilter Authorization search filter.
type AuthorizationFilter struct {
	// OwnerId The ID of the owner of permissions.
	OwnerId *string `json:"ownerId,omitempty"`

	// OwnerType The type of the owner of permissions.
	OwnerType *OwnerTypeEnum `json:"ownerType,omitempty"`

	// ResourceIds The IDs of the resource to search permissions for.
	ResourceIds *[]string `json:"resourceIds,omitempty"`

	// ResourceType The type of resource to search permissions for.
	ResourceType *ResourceTypeEnum `json:"resourceType,omitempty"`
}

// AuthorizationKey Zeebe Engine resource key (Java long serialized as string)
type AuthorizationKey = LongKey

// AuthorizationRequest defines model for AuthorizationRequest.
type AuthorizationRequest struct {
	// OwnerId The ID of the owner of the permissions.
	OwnerId string `json:"ownerId"`

	// OwnerType The type of the owner of the permissions.
	OwnerType OwnerTypeEnum `json:"ownerType"`

	// PermissionTypes The permission types to add.
	PermissionTypes []PermissionTypeEnum `json:"permissionTypes"`

	// ResourceId The ID of the resource to add permissions to.
	ResourceId string `json:"resourceId"`

	// ResourceType The type of resource to add permissions to.
	ResourceType ResourceTypeEnum `json:"resourceType"`
}

// AuthorizationResult defines model for AuthorizationResult.
type AuthorizationResult struct {
	// AuthorizationKey The key of the authorization.
	AuthorizationKey *AuthorizationKey `json:"authorizationKey,omitempty"`

	// OwnerId The ID of the owner of permissions.
	OwnerId *string `json:"ownerId,omitempty"`

	// OwnerType The type of the owner of permissions.
	OwnerType *OwnerTypeEnum `json:"ownerType,omitempty"`

	// PermissionTypes Specifies the types of the permissions.
	PermissionTypes *[]PermissionTypeEnum `json:"permissionTypes,omitempty"`

	// ResourceId ID of the resource the permission relates to.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceType The type of resource that owner have permissions.
	ResourceType *ResourceTypeEnum `json:"resourceType,omitempty"`
}

// AuthorizationSearchQuery defines model for AuthorizationSearchQuery.
type AuthorizationSearchQuery = SearchQueryRequest

// AuthorizationSearchQuerySortRequest defines model for AuthorizationSearchQuerySortRequest.
type AuthorizationSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field AuthorizationSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// AuthorizationSearchQuerySortRequestField The field to sort by.
type AuthorizationSearchQuerySortRequestField string

// AuthorizationSearchResult defines model for AuthorizationSearchResult.
type AuthorizationSearchResult = SearchQueryResponse

// BaseProcessInstanceFilterFields Base process instance search filter.
type BaseProcessInstanceFilterFields struct {
	// BatchOperationId The batch operation ID.
	BatchOperationId *StringFilterProperty `json:"batchOperationId,omitempty"`

	// ElementId The element ID associated with the process instance.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceState The state of the element instances associated with the process instance.
	ElementInstanceState *ElementInstanceStateFilterProperty `json:"elementInstanceState,omitempty"`

	// EndDate The end date.
	EndDate *DateTimeFilterProperty `json:"endDate,omitempty"`

	// ErrorMessage The error message related to the process.
	ErrorMessage *StringFilterProperty `json:"errorMessage,omitempty"`

	// HasElementInstanceIncident Whether the element instance has an incident or not.
	HasElementInstanceIncident *bool `json:"hasElementInstanceIncident,omitempty"`

	// HasIncident Whether this process instance has a related incident or not.
	HasIncident *bool `json:"hasIncident,omitempty"`

	// HasRetriesLeft Whether the process has failed jobs with retries left.
	HasRetriesLeft *bool `json:"hasRetriesLeft,omitempty"`

	// IncidentErrorHashCode The incident error hash code, associated with this process.
	IncidentErrorHashCode *IntegerFilterProperty `json:"incidentErrorHashCode,omitempty"`

	// ParentElementInstanceKey The parent element instance key.
	ParentElementInstanceKey *BaseProcessInstanceFilterFields_ParentElementInstanceKey `json:"parentElementInstanceKey,omitempty"`

	// ParentProcessInstanceKey The parent process instance key.
	ParentProcessInstanceKey *BaseProcessInstanceFilterFields_ParentProcessInstanceKey `json:"parentProcessInstanceKey,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey *BaseProcessInstanceFilterFields_ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// StartDate The start date.
	StartDate *DateTimeFilterProperty `json:"startDate,omitempty"`

	// State The process instance state.
	State *ProcessInstanceStateFilterProperty `json:"state,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// Variables The process instance variables.
	Variables *[]VariableValueFilterProperty `json:"variables,omitempty"`
}

// BaseProcessInstanceFilterFields_ParentElementInstanceKey The parent element instance key.
type BaseProcessInstanceFilterFields_ParentElementInstanceKey struct {
	union json.RawMessage
}

// BaseProcessInstanceFilterFields_ParentProcessInstanceKey The parent process instance key.
type BaseProcessInstanceFilterFields_ParentProcessInstanceKey struct {
	union json.RawMessage
}

// BaseProcessInstanceFilterFields_ProcessInstanceKey The key of this process instance.
type BaseProcessInstanceFilterFields_ProcessInstanceKey struct {
	union json.RawMessage
}

// BasicStringFilter Basic advanced string filter.
type BasicStringFilter struct {
	// Eq Checks for equality with the provided value.
	Eq *string `json:"$eq,omitempty"`

	// Exists Checks if the current property exists.
	Exists *bool `json:"$exists,omitempty"`

	// In Checks if the property matches any of the provided values.
	In *[]string `json:"$in,omitempty"`

	// Neq Checks for inequality with the provided value.
	Neq *string `json:"$neq,omitempty"`

	// NotIn Checks if the property matches none of the provided values.
	NotIn *[]string `json:"$notIn,omitempty"`
}

// BasicStringFilterProperty String property with basic advanced search capabilities.
type BasicStringFilterProperty struct {
	union json.RawMessage
}

// BasicStringFilterProperty0 Matches the value exactly.
type BasicStringFilterProperty0 = string

// BatchCommandOperation Updates a resource.
type BatchCommandOperation struct {
	// Idempotent Idempotent operations cause at-most one effect regardless of how many times that are called.
	Idempotent *bool                     `json:"idempotent,omitempty"`
	Kind       BatchCommandOperationKind `json:"kind"`

	// Safe Safe operations do not mutate the state of the Camunda engine.
	Safe *bool `json:"safe,omitempty"`
}

// BatchCommandOperationKind defines model for BatchCommandOperation.Kind.
type BatchCommandOperationKind string

// BatchOperationCreatedResult The created batch operation.
type BatchOperationCreatedResult struct {
	// BatchOperationKey Key of the batch operation.
	BatchOperationKey *BatchOperationKey `json:"batchOperationKey,omitempty"`

	// BatchOperationType The type of the batch operation.
	BatchOperationType *BatchOperationTypeEnum `json:"batchOperationType,omitempty"`
}

// BatchOperationError defines model for BatchOperationError.
type BatchOperationError struct {
	// Message The error message that occurred during the batch operation.
	Message *string `json:"message,omitempty"`

	// PartitionId The partition ID where the error occurred.
	PartitionId *int32 `json:"partitionId,omitempty"`

	// Type The type of the error that occurred during the batch operation.
	Type *BatchOperationErrorType `json:"type,omitempty"`
}

// BatchOperationErrorType The type of the error that occurred during the batch operation.
type BatchOperationErrorType string

// BatchOperationFilter Batch operation filter request.
type BatchOperationFilter struct {
	// BatchOperationKey The key (or operate legacy ID) of the batch operation.
	BatchOperationKey *BasicStringFilterProperty `json:"batchOperationKey,omitempty"`

	// OperationType The type of the batch operation.
	OperationType *BatchOperationTypeFilterProperty `json:"operationType,omitempty"`

	// State The state of the batch operation.
	State *BatchOperationStateFilterProperty `json:"state,omitempty"`
}

// BatchOperationItemFilter Batch operation item filter request.
type BatchOperationItemFilter struct {
	// BatchOperationKey The key (or operate legacy ID) of the batch operation.
	BatchOperationKey *BasicStringFilterProperty `json:"batchOperationKey,omitempty"`

	// ItemKey The key of the item, e.g. a process instance key.
	ItemKey *BasicStringFilterProperty `json:"itemKey,omitempty"`

	// ProcessInstanceKey The process instance key of the processed item.
	ProcessInstanceKey *BatchOperationItemFilter_ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// State The state of the batch operation.
	State *BatchOperationItemStateFilterProperty `json:"state,omitempty"`
}

// BatchOperationItemFilter_ProcessInstanceKey The process instance key of the processed item.
type BatchOperationItemFilter_ProcessInstanceKey struct {
	union json.RawMessage
}

// BatchOperationItemResponse defines model for BatchOperationItemResponse.
type BatchOperationItemResponse struct {
	// BatchOperationKey The key (or operate legacy ID) of the batch operation.
	BatchOperationKey *BatchOperationKey `json:"batchOperationKey,omitempty"`

	// ErrorMessage the error message from the engine in case of a failed operation.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// ItemKey Key of the item, e.g. a process instance key.
	ItemKey *string `json:"itemKey,omitempty"`

	// OperationType The type of the batch operation.
	OperationType *BatchOperationTypeEnum `json:"operationType,omitempty"`

	// ProcessInstanceKey the process instance key of the processed item.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// ProcessedDate the date this item was processed.
	ProcessedDate *time.Time `json:"processedDate,omitempty"`

	// State State of the item.
	State *BatchOperationItemResponseState `json:"state,omitempty"`
}

// BatchOperationItemResponseState State of the item.
type BatchOperationItemResponseState string

// BatchOperationItemSearchQuery defines model for BatchOperationItemSearchQuery.
type BatchOperationItemSearchQuery = SearchQueryRequest

// BatchOperationItemSearchQueryResult defines model for BatchOperationItemSearchQueryResult.
type BatchOperationItemSearchQueryResult = SearchQueryResponse

// BatchOperationItemSearchQuerySortRequest defines model for BatchOperationItemSearchQuerySortRequest.
type BatchOperationItemSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field BatchOperationItemSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// BatchOperationItemSearchQuerySortRequestField The field to sort by.
type BatchOperationItemSearchQuerySortRequestField string

// BatchOperationItemStateEnum The state, one of ACTIVE, COMPLETED, TERMINATED.
type BatchOperationItemStateEnum = interface{}

// BatchOperationItemStateFilterProperty BatchOperationItemStateEnum property with full advanced search capabilities.
type BatchOperationItemStateFilterProperty struct {
	union json.RawMessage
}

// BatchOperationItemStateFilterProperty0 The state, one of ACTIVE, COMPLETED, TERMINATED.
type BatchOperationItemStateFilterProperty0 = BatchOperationItemStateEnum

// BatchOperationKey System-generated key for an batch operation.
type BatchOperationKey struct {
	union json.RawMessage
}

// BatchOperationKey0 Zeebe Engine resource key (Java long serialized as string)
type BatchOperationKey0 = LongKey

// BatchOperationKey1 defines model for .
type BatchOperationKey1 = openapi_types.UUID

// BatchOperationResponse defines model for BatchOperationResponse.
type BatchOperationResponse struct {
	// BatchOperationKey Key or (Operate Legacy ID = UUID) of the batch operation.
	BatchOperationKey *BatchOperationKey `json:"batchOperationKey,omitempty"`

	// BatchOperationType The type of the batch operation.
	BatchOperationType *BatchOperationTypeEnum `json:"batchOperationType,omitempty"`

	// EndDate The end date of the batch operation.
	EndDate *time.Time `json:"endDate,omitempty"`

	// Errors The errors that occurred per partition during the batch operation.
	Errors *[]BatchOperationError `json:"errors,omitempty"`

	// OperationsCompletedCount The number of successfully completed tasks.
	OperationsCompletedCount *int32 `json:"operationsCompletedCount,omitempty"`

	// OperationsFailedCount The number of items which failed during execution of the batch operation. (e.g. because they are rejected by the Zeebe engine).
	OperationsFailedCount *int32 `json:"operationsFailedCount,omitempty"`

	// OperationsTotalCount The total number of items contained in this batch operation.
	OperationsTotalCount *int32 `json:"operationsTotalCount,omitempty"`

	// StartDate The start date of the batch operation.
	StartDate *time.Time `json:"startDate,omitempty"`

	// State The state of the batch operation.
	State *BatchOperationResponseState `json:"state,omitempty"`
}

// BatchOperationResponseState The state of the batch operation.
type BatchOperationResponseState string

// BatchOperationSearchQuery defines model for BatchOperationSearchQuery.
type BatchOperationSearchQuery = SearchQueryRequest

// BatchOperationSearchQueryResult defines model for BatchOperationSearchQueryResult.
type BatchOperationSearchQueryResult = SearchQueryResponse

// BatchOperationSearchQuerySortRequest defines model for BatchOperationSearchQuerySortRequest.
type BatchOperationSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field BatchOperationSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// BatchOperationSearchQuerySortRequestField The field to sort by.
type BatchOperationSearchQuerySortRequestField string

// BatchOperationStateEnum The state, one of ACTIVE, COMPLETED, TERMINATED.
type BatchOperationStateEnum = interface{}

// BatchOperationStateFilterProperty BatchOperationStateEnum property with full advanced search capabilities.
type BatchOperationStateFilterProperty struct {
	union json.RawMessage
}

// BatchOperationStateFilterProperty0 The state, one of ACTIVE, COMPLETED, TERMINATED.
type BatchOperationStateFilterProperty0 = BatchOperationStateEnum

// BatchOperationTypeEnum The type of the batch operation.
type BatchOperationTypeEnum string

// BatchOperationTypeFilterProperty BatchOperationTypeEnum property with full advanced search capabilities.
type BatchOperationTypeFilterProperty struct {
	union json.RawMessage
}

// BatchOperationTypeFilterProperty0 The type of the batch operation.
type BatchOperationTypeFilterProperty0 = BatchOperationTypeEnum

// BrokerInfo Provides information on a broker node.
type BrokerInfo struct {
	// Host The hostname for reaching the broker.
	Host string `json:"host"`

	// NodeId The unique (within a cluster) node ID for the broker.
	NodeId int32 `json:"nodeId"`

	// Partitions A list of partitions managed or replicated on this broker.
	Partitions []Partition `json:"partitions"`

	// Port The port for reaching the broker.
	Port int32 `json:"port"`

	// Version The broker version.
	Version string `json:"version"`
}

// CamundaUserResult defines model for CamundaUserResult.
type CamundaUserResult struct {
	// AuthorizedComponents The web components the user is authorized to use.
	AuthorizedComponents *[]string `json:"authorizedComponents,omitempty"`

	// C8Links The links to the components in the C8 stack.
	C8Links map[string]string `json:"c8Links"`

	// CanLogout Flag for understanding if the user is able to perform logout.
	CanLogout bool `json:"canLogout"`

	// DisplayName The display name of the user.
	DisplayName nullable.Nullable[string] `json:"displayName,omitempty"`

	// Email The email of the user.
	Email nullable.Nullable[string] `json:"email,omitempty"`

	// Groups The groups assigned to the user.
	Groups []string `json:"groups"`

	// Roles The roles assigned to the user.
	Roles []string `json:"roles"`

	// SalesPlanType The plan of the user.
	SalesPlanType string `json:"salesPlanType"`

	// Tenants The tenants the user is a member of.
	Tenants []TenantResult `json:"tenants"`

	// Username The username of the user.
	Username nullable.Nullable[Username] `json:"username,omitempty"`
}

// CancelProcessInstanceRequest defines model for CancelProcessInstanceRequest.
type CancelProcessInstanceRequest struct {
	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`
}

// Changeset JSON object with changed task attribute values.
//
// The following attributes can be adjusted with this endpoint, additional attributes
// will be ignored:
//
// * `candidateGroups` - reset by providing an empty list
// * `candidateUsers` - reset by providing an empty list
// * `dueDate` - reset by providing an empty String
// * `followUpDate` - reset by providing an empty String
// * `priority` - minimum 0, maximum 100, default 50
//
// Providing any of those attributes with a `null` value or omitting it preserves
// the persisted attribute's value.
//
// The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
// This ensures correct event emission for assignee changes.
type Changeset struct {
	// CandidateGroups The list of candidate groups of the task. Reset by providing an empty list.
	CandidateGroups nullable.Nullable[[]string] `json:"candidateGroups,omitempty"`

	// CandidateUsers The list of candidate users of the task. Reset by providing an empty list.
	CandidateUsers nullable.Nullable[[]string] `json:"candidateUsers,omitempty"`

	// DueDate The due date of the task. Reset by providing an empty String.
	DueDate nullable.Nullable[time.Time] `json:"dueDate,omitempty"`

	// FollowUpDate The follow-up date of the task. Reset by providing an empty String.
	FollowUpDate nullable.Nullable[time.Time] `json:"followUpDate,omitempty"`

	// Priority The priority of the task.
	Priority             nullable.Nullable[int32] `json:"priority,omitempty"`
	AdditionalProperties map[string]interface{}   `json:"-"`
}

// ClockPinRequest defines model for ClockPinRequest.
type ClockPinRequest struct {
	// Timestamp The exact time in epoch milliseconds to which the clock should be pinned.
	Timestamp int `json:"timestamp"`
}

// CommandOperation A non-idempotent state transition / process action
type CommandOperation struct {
	// Idempotent Idempotent operations cause at-most one effect regardless of how many times that are called.
	Idempotent *bool                `json:"idempotent,omitempty"`
	Kind       CommandOperationKind `json:"kind"`

	// Safe Safe operations do not mutate the state of the Camunda engine.
	Safe *bool `json:"safe,omitempty"`
}

// CommandOperationKind defines model for CommandOperation.Kind.
type CommandOperationKind string

// CreateOperation Creates a new resource. The duplicatePolicy describes what happens when you make the same request more than once.
type CreateOperation struct {
	// DuplicatePolicy Server behavior when the identical create request is repeated:
	//  - conflict (subsequent identical request â†’ 409; creates none; NOT idempotent)
	//  - return-existing (subsequent identical request â†’ 200/201 with same representation; idempotent)
	//  - ignore (subsequent identical request â†’ 2xx minimal body, no new resource; idempotent)
	//  - upsert (creates if absent, otherwise updates in place producing same final state; idempotent)
	//  - merge (each call adds/accumulates something; NOT idempotent)
	//  - batch-partial (mixed: per item may create or conflict; whole-call classification becomes non-idempotent unless every item stabilized)
	DuplicatePolicy CreateOperationDuplicatePolicy `json:"duplicatePolicy"`

	// IdempotencyMechanism How this operation calculates idempotency: - natural-key (server uses unique natural key(s) in body/path) - body-hash (semantic or byte hash dedupe) - idempotency-key (client supplies Idempotency-Key header) - server-token (client obtains token then submits) - none (default)
	IdempotencyMechanism *CreateOperationIdempotencyMechanism `json:"idempotencyMechanism,omitempty"`

	// IdempotencyScope Scope within which idempotency applies (resource = same logical resource identity, request = exact same payload, key+payload = Idempotency-Key + payload tuple).
	IdempotencyScope *CreateOperationIdempotencyScope `json:"idempotencyScope,omitempty"`

	// Idempotent Idempotent operations cause at-most one effect regardless of how many times that are called. Explicit override; otherwise inferred from duplicatePolicy.
	Idempotent *bool               `json:"idempotent,omitempty"`
	Kind       CreateOperationKind `json:"kind"`

	// Safe Safe operations do not mutate state.
	Safe *bool `json:"safe,omitempty"`
}

// CreateOperationDuplicatePolicy Server behavior when the identical create request is repeated:
//   - conflict (subsequent identical request â†’ 409; creates none; NOT idempotent)
//   - return-existing (subsequent identical request â†’ 200/201 with same representation; idempotent)
//   - ignore (subsequent identical request â†’ 2xx minimal body, no new resource; idempotent)
//   - upsert (creates if absent, otherwise updates in place producing same final state; idempotent)
//   - merge (each call adds/accumulates something; NOT idempotent)
//   - batch-partial (mixed: per item may create or conflict; whole-call classification becomes non-idempotent unless every item stabilized)
type CreateOperationDuplicatePolicy string

// CreateOperationIdempotencyMechanism How this operation calculates idempotency: - natural-key (server uses unique natural key(s) in body/path) - body-hash (semantic or byte hash dedupe) - idempotency-key (client supplies Idempotency-Key header) - server-token (client obtains token then submits) - none (default)
type CreateOperationIdempotencyMechanism string

// CreateOperationIdempotencyScope Scope within which idempotency applies (resource = same logical resource identity, request = exact same payload, key+payload = Idempotency-Key + payload tuple).
type CreateOperationIdempotencyScope string

// CreateOperationKind defines model for CreateOperation.Kind.
type CreateOperationKind string

// CreateProcessInstanceResult defines model for CreateProcessInstanceResult.
type CreateProcessInstanceResult struct {
	// ProcessDefinitionId The BPMN process ID of the process definition which was used to create the process.
	// instance
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The key of the process definition which was used to create the process instance.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessDefinitionVersion The version of the process definition which was used to create the process instance.
	ProcessDefinitionVersion int32 `json:"processDefinitionVersion"`

	// ProcessInstanceKey The unique identifier of the created process instance; to be used wherever a request
	// needs a process instance key (e.g. CancelProcessInstanceRequest).
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId TenantId `json:"tenantId"`

	// Variables All the variables visible in the root scope.
	Variables map[string]interface{} `json:"variables"`
}

// CursorBackwardPagination defines model for CursorBackwardPagination.
type CursorBackwardPagination struct {
	// Before Use the `startCursor` value from the previous response to fetch the previous page of results.
	Before StartCursor `json:"before"`

	// Limit The maximum number of items to return in one request.
	Limit *int32 `json:"limit,omitempty"`
}

// CursorForwardPagination defines model for CursorForwardPagination.
type CursorForwardPagination struct {
	// After Use the `endCursor` value from the previous response to fetch the next page of results.
	After EndCursor `json:"after"`

	// Limit The maximum number of items to return in one request.
	Limit *int32 `json:"limit,omitempty"`
}

// DateTimeFilterProperty Date-time property with full advanced search capabilities.
type DateTimeFilterProperty struct {
	union json.RawMessage
}

// DateTimeFilterProperty0 Matches the value exactly.
type DateTimeFilterProperty0 = time.Time

// DecisionDefinitionFilter Decision definition search filter.
type DecisionDefinitionFilter struct {
	// DecisionDefinitionId The DMN ID of the decision definition.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The assigned key, which acts as a unique identifier for this decision definition.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionRequirementsId the DMN ID of the decision requirements graph that the decision definition is part of.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned key of the decision requirements graph that the decision definition is part of.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// Name The DMN name of the decision definition.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned version of the decision definition.
	Version *int32 `json:"version,omitempty"`
}

// DecisionDefinitionId Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.
type DecisionDefinitionId = string

// DecisionDefinitionKey Zeebe Engine resource key (Java long serialized as string)
type DecisionDefinitionKey = LongKey

// DecisionDefinitionResult defines model for DecisionDefinitionResult.
type DecisionDefinitionResult struct {
	// DecisionDefinitionId The DMN ID of the decision definition.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The assigned key, which acts as a unique identifier for this decision definition.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionRequirementsId the DMN ID of the decision requirements graph that the decision definition is part of.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned key of the decision requirements graph that the decision definition is part of.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// Name The DMN name of the decision definition.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned version of the decision definition.
	Version *int32 `json:"version,omitempty"`
}

// DecisionDefinitionSearchQuery defines model for DecisionDefinitionSearchQuery.
type DecisionDefinitionSearchQuery = SearchQueryRequest

// DecisionDefinitionSearchQueryResult defines model for DecisionDefinitionSearchQueryResult.
type DecisionDefinitionSearchQueryResult = SearchQueryResponse

// DecisionDefinitionSearchQuerySortRequest defines model for DecisionDefinitionSearchQuerySortRequest.
type DecisionDefinitionSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field DecisionDefinitionSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// DecisionDefinitionSearchQuerySortRequestField The field to sort by.
type DecisionDefinitionSearchQuerySortRequestField string

// DecisionDefinitionTypeEnum The type of the decision.
type DecisionDefinitionTypeEnum = interface{}

// DecisionEvaluationById defines model for DecisionEvaluationById.
type DecisionEvaluationById struct {
	// DecisionDefinitionId The ID of the decision to be evaluated.
	// When using the decision ID, the latest
	// deployed version of the decision is used.
	DecisionDefinitionId DecisionDefinitionId `json:"decisionDefinitionId"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables The message variables as JSON document.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// DecisionEvaluationByKey defines model for DecisionEvaluationByKey.
type DecisionEvaluationByKey struct {
	DecisionDefinitionKey DecisionDefinitionKey `json:"decisionDefinitionKey"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables The message variables as JSON document.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// DecisionEvaluationInstanceKey Zeebe Engine resource key (Java long serialized as string)
type DecisionEvaluationInstanceKey = LongKey

// DecisionEvaluationInstruction defines model for DecisionEvaluationInstruction.
type DecisionEvaluationInstruction struct {
	union json.RawMessage
}

// DecisionEvaluationKey Zeebe Engine resource key (Java long serialized as string)
type DecisionEvaluationKey = LongKey

// DecisionInstanceFilter Decision instance search filter.
type DecisionInstanceFilter struct {
	// DecisionDefinitionId The ID of the DMN decision.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The key of the decision.
	DecisionDefinitionKey *DecisionInstanceFilter_DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionDefinitionName The name of the DMN decision.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionType The type of the decision.
	DecisionDefinitionType *DecisionDefinitionTypeEnum `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// DecisionEvaluationInstanceKey System-generated key for a decision evaluation instance.
	DecisionEvaluationInstanceKey *DecisionEvaluationInstanceKey `json:"decisionEvaluationInstanceKey,omitempty"`

	// DecisionEvaluationKey The key of the parent decision evaluation. Note that this is not the identifier of an individual decision instance; the `decisionEvaluationInstanceKey` is the identifier for a decision instance.
	DecisionEvaluationKey *DecisionEvaluationKey `json:"decisionEvaluationKey,omitempty"`

	// ElementInstanceKey The key of the element instance this decision instance is linked to.
	ElementInstanceKey *DecisionInstanceFilter_ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// EvaluationDate The evaluation date of the decision instance.
	EvaluationDate *DateTimeFilterProperty `json:"evaluationDate,omitempty"`

	// EvaluationFailure The evaluation failure of the decision instance.
	EvaluationFailure *string `json:"evaluationFailure,omitempty"`

	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// State The state of the decision instance.
	State *DecisionInstanceStateEnum `json:"state,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// DecisionInstanceFilter_DecisionDefinitionKey The key of the decision.
type DecisionInstanceFilter_DecisionDefinitionKey struct {
	union json.RawMessage
}

// DecisionInstanceFilter_ElementInstanceKey The key of the element instance this decision instance is linked to.
type DecisionInstanceFilter_ElementInstanceKey struct {
	union json.RawMessage
}

// DecisionInstanceGetQueryResult defines model for DecisionInstanceGetQueryResult.
type DecisionInstanceGetQueryResult struct {
	// DecisionDefinitionId The ID of the DMN decision.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The key of the decision.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionDefinitionName The name of the DMN decision.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionType The type of the decision.
	DecisionDefinitionType *DecisionDefinitionTypeEnum `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// DecisionEvaluationInstanceKey System-generated key for a decision evaluation instance.
	DecisionEvaluationInstanceKey *DecisionEvaluationInstanceKey `json:"decisionEvaluationInstanceKey,omitempty"`

	// DecisionEvaluationKey The key of the decision evaluation where this instance was created.
	DecisionEvaluationKey *DecisionEvaluationKey `json:"decisionEvaluationKey,omitempty"`

	// ElementInstanceKey The key of the element instance this decision instance is linked to.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// EvaluatedInputs The evaluated inputs of the decision instance.
	EvaluatedInputs *[]EvaluatedDecisionInputItem `json:"evaluatedInputs,omitempty"`

	// EvaluationDate The evaluation date of the decision instance.
	EvaluationDate *time.Time `json:"evaluationDate,omitempty"`

	// EvaluationFailure The evaluation failure of the decision instance.
	EvaluationFailure *string `json:"evaluationFailure,omitempty"`

	// MatchedRules The matched rules of the decision instance.
	MatchedRules *[]MatchedDecisionRuleItem `json:"matchedRules,omitempty"`

	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// Result The result of the decision instance.
	Result *string `json:"result,omitempty"`

	// State The state of the decision instance.
	State *DecisionInstanceStateEnum `json:"state,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// DecisionInstanceKey Zeebe Engine resource key (Java long serialized as string)
type DecisionInstanceKey = LongKey

// DecisionInstanceResult defines model for DecisionInstanceResult.
type DecisionInstanceResult struct {
	// DecisionDefinitionId The ID of the DMN decision.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The key of the decision.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionDefinitionName The name of the DMN decision.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionType The type of the decision.
	DecisionDefinitionType *DecisionDefinitionTypeEnum `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// DecisionEvaluationInstanceKey System-generated key for a decision evaluation instance.
	DecisionEvaluationInstanceKey *DecisionEvaluationInstanceKey `json:"decisionEvaluationInstanceKey,omitempty"`

	// DecisionEvaluationKey The key of the decision evaluation where this instance was created.
	DecisionEvaluationKey *DecisionEvaluationKey `json:"decisionEvaluationKey,omitempty"`

	// ElementInstanceKey The key of the element instance this decision instance is linked to.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// EvaluationDate The evaluation date of the decision instance.
	EvaluationDate *time.Time `json:"evaluationDate,omitempty"`

	// EvaluationFailure The evaluation failure of the decision instance.
	EvaluationFailure *string `json:"evaluationFailure,omitempty"`

	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// Result The result of the decision instance.
	Result *string `json:"result,omitempty"`

	// State The state of the decision instance.
	State *DecisionInstanceStateEnum `json:"state,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// DecisionInstanceSearchQuery defines model for DecisionInstanceSearchQuery.
type DecisionInstanceSearchQuery = SearchQueryRequest

// DecisionInstanceSearchQueryResult defines model for DecisionInstanceSearchQueryResult.
type DecisionInstanceSearchQueryResult = SearchQueryResponse

// DecisionInstanceSearchQuerySortRequest defines model for DecisionInstanceSearchQuerySortRequest.
type DecisionInstanceSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field DecisionInstanceSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// DecisionInstanceSearchQuerySortRequestField The field to sort by.
type DecisionInstanceSearchQuerySortRequestField string

// DecisionInstanceStateEnum The state of the decision instance.
type DecisionInstanceStateEnum = interface{}

// DecisionRequirementsFilter Decision requirements search filter.
type DecisionRequirementsFilter struct {
	// DecisionRequirementsId the DMN ID of the decision requirements.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned key, which acts as a unique identifier for this decision requirements.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// DecisionRequirementsName The DMN name of the decision requirements.
	DecisionRequirementsName *string `json:"decisionRequirementsName,omitempty"`

	// ResourceName The name of the resource from which the decision requirements were parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned version of the decision requirements.
	Version *int32 `json:"version,omitempty"`
}

// DecisionRequirementsKey Zeebe Engine resource key (Java long serialized as string)
type DecisionRequirementsKey = LongKey

// DecisionRequirementsResult defines model for DecisionRequirementsResult.
type DecisionRequirementsResult struct {
	// DecisionRequirementsId The DMN ID of the decision requirements.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned key, which acts as a unique identifier for this decision requirements.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// DecisionRequirementsName The DMN name of the decision requirements.
	DecisionRequirementsName *string `json:"decisionRequirementsName,omitempty"`

	// ResourceName The name of the resource from which this decision requirements was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned version of the decision requirements.
	Version *int32 `json:"version,omitempty"`
}

// DecisionRequirementsSearchQuery defines model for DecisionRequirementsSearchQuery.
type DecisionRequirementsSearchQuery = SearchQueryRequest

// DecisionRequirementsSearchQueryResult defines model for DecisionRequirementsSearchQueryResult.
type DecisionRequirementsSearchQueryResult = SearchQueryResponse

// DecisionRequirementsSearchQuerySortRequest defines model for DecisionRequirementsSearchQuerySortRequest.
type DecisionRequirementsSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field DecisionRequirementsSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// DecisionRequirementsSearchQuerySortRequestField The field to sort by.
type DecisionRequirementsSearchQuerySortRequestField string

// DeleteOperation Deletes a resource.
type DeleteOperation struct {
	// Idempotent Idempotent operations cause at-most one effect regardless of how many times that are called.
	Idempotent *bool               `json:"idempotent,omitempty"`
	Kind       DeleteOperationKind `json:"kind"`

	// Safe Safe operations do not mutate the state of the Camunda engine.
	Safe *bool `json:"safe,omitempty"`
}

// DeleteOperationKind defines model for DeleteOperation.Kind.
type DeleteOperationKind string

// DeleteResourceRequest defines model for DeleteResourceRequest.
type DeleteResourceRequest struct {
	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`
}

// DeploymentDecisionRequirementsResult Deployed decision requirements.
type DeploymentDecisionRequirementsResult struct {
	// DecisionRequirementsId The dmn decision requirements ID, as parsed during deployment; together with the versions forms a unique identifier for a specific decision.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned decision requirements key, which acts as a unique identifier for this decision requirements.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// DecisionRequirementsName The DMN name of the decision requirements, as parsed during deployment.
	DecisionRequirementsName *string `json:"decisionRequirementsName,omitempty"`

	// ResourceName The resource name from which this decision requirements was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned decision requirements version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentDecisionResult A deployed decision.
type DeploymentDecisionResult struct {
	// DecisionDefinitionId The dmn decision ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific decision.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The assigned decision key, which acts as a unique identifier for this decision.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionRequirementsId The dmn ID of the decision requirements graph that this decision is part of, as parsed during deployment.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The assigned key of the decision requirements graph that this decision is part of.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// Name The DMN name of the decision, as parsed during deployment.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned decision version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentFormResult A deployed form.
type DeploymentFormResult struct {
	// FormId The form ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific form.
	FormId *string `json:"formId,omitempty"`

	// FormKey The assigned key, which acts as a unique identifier for this form.
	FormKey *FormKey `json:"formKey,omitempty"`

	// ResourceName The resource name from which this form was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned form version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentKey Zeebe Engine resource key (Java long serialized as string)
type DeploymentKey = LongKey

// DeploymentMetadataResult defines model for DeploymentMetadataResult.
type DeploymentMetadataResult struct {
	// DecisionDefinition A deployed decision.
	DecisionDefinition *DeploymentDecisionResult `json:"decisionDefinition,omitempty"`

	// DecisionRequirements Deployed decision requirements.
	DecisionRequirements *DeploymentDecisionRequirementsResult `json:"decisionRequirements,omitempty"`

	// Form A deployed form.
	Form *DeploymentFormResult `json:"form,omitempty"`

	// ProcessDefinition A deployed process.
	ProcessDefinition *DeploymentProcessResult `json:"processDefinition,omitempty"`

	// Resource A deployed Resource.
	Resource *DeploymentResourceResult `json:"resource,omitempty"`
}

// DeploymentProcessResult A deployed process.
type DeploymentProcessResult struct {
	// ProcessDefinitionId The bpmn process ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific process definition.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The assigned key, which acts as a unique identifier for this process.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessDefinitionVersion The assigned process version.
	ProcessDefinitionVersion int32 `json:"processDefinitionVersion"`

	// ResourceName The resource name from which this process was parsed.
	ResourceName string `json:"resourceName"`

	// TenantId The unique identifier of the tenant.
	TenantId TenantId `json:"tenantId"`
}

// DeploymentResourceResult A deployed Resource.
type DeploymentResourceResult struct {
	// ResourceId The resource ID, as parsed during deployment, together with the version forms a
	// unique identifier for a specific form.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceKey The assigned key, which acts as a unique identifier for this Resource.
	ResourceKey *ResourceKey `json:"resourceKey,omitempty"`

	// ResourceName The resource name from which this resource was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned resource version.
	Version *int32 `json:"version,omitempty"`
}

// DeploymentResult defines model for DeploymentResult.
type DeploymentResult struct {
	// DeploymentKey The unique key identifying the deployment.
	DeploymentKey DeploymentKey `json:"deploymentKey"`

	// Deployments Items deployed by the request.
	Deployments []DeploymentMetadataResult `json:"deployments"`

	// TenantId The unique identifier of the tenant.
	TenantId TenantId `json:"tenantId"`
}

// DocumentCreationBatchResponse defines model for DocumentCreationBatchResponse.
type DocumentCreationBatchResponse struct {
	// CreatedDocuments Documents that were successfully created.
	CreatedDocuments *[]DocumentReference `json:"createdDocuments,omitempty"`

	// FailedDocuments Documents that failed creation.
	FailedDocuments *[]DocumentCreationFailureDetail `json:"failedDocuments,omitempty"`
}

// DocumentCreationFailureDetail defines model for DocumentCreationFailureDetail.
type DocumentCreationFailureDetail struct {
	// Detail The detail of the failure.
	Detail *string `json:"detail,omitempty"`

	// FileName The name of the file.
	FileName *string `json:"fileName,omitempty"`
}

// DocumentId Document Id that uniquely identifies a document.
type DocumentId = interface{}

// DocumentLink defines model for DocumentLink.
type DocumentLink struct {
	// ExpiresAt The date and time when the link expires.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Url The link to the document.
	Url *string `json:"url,omitempty"`
}

// DocumentLinkRequest defines model for DocumentLinkRequest.
type DocumentLinkRequest struct {
	// TimeToLive The time-to-live of the document link in ms.
	TimeToLive *int `json:"timeToLive,omitempty"`
}

// DocumentMetadata Information about the document.
type DocumentMetadata struct {
	// ContentType The content type of the document.
	ContentType *string `json:"contentType,omitempty"`

	// CustomProperties Custom properties of the document.
	CustomProperties *map[string]interface{} `json:"customProperties,omitempty"`

	// ExpiresAt The date and time when the document expires.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// FileName The name of the file.
	FileName *string `json:"fileName,omitempty"`

	// ProcessDefinitionId The ID of the process definition that created the document.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessInstanceKey The key of the process instance that created the document.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// Size The size of the document in bytes.
	Size *int `json:"size,omitempty"`
}

// DocumentReference defines model for DocumentReference.
type DocumentReference struct {
	// CamundaDocumentType Document discriminator. Always set to "camunda".
	CamundaDocumentType *DocumentReferenceCamundaDocumentType `json:"camunda.document.type,omitempty"`

	// ContentHash The hash of the document.
	ContentHash *string `json:"contentHash,omitempty"`

	// DocumentId The ID of the document.
	DocumentId *DocumentId `json:"documentId,omitempty"`

	// Metadata Information about the document.
	Metadata *DocumentMetadata `json:"metadata,omitempty"`

	// StoreId The ID of the document store.
	StoreId *string `json:"storeId,omitempty"`
}

// DocumentReferenceCamundaDocumentType Document discriminator. Always set to "camunda".
type DocumentReferenceCamundaDocumentType string

// ElementId The model-defined id of an element.
type ElementId = string

// ElementInstanceFilter Element instance filter.
type ElementInstanceFilter struct {
	// ElementId The element ID for this element instance.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The assigned key, which acts as a unique identifier for this element instance.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// ElementInstanceScopeKey The scope key of this element instance. If provided with a process instance key it will return element instances that are immediate children of the process instance. If provided with an element instance key it will return element instances that are immediate children of the element instance.
	ElementInstanceScopeKey *ElementInstanceFilter_ElementInstanceScopeKey `json:"elementInstanceScopeKey,omitempty"`

	// ElementName The element name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.
	ElementName *string `json:"elementName,omitempty"`

	// EndDate The end date of this element instance.
	EndDate *DateTimeFilterProperty `json:"endDate,omitempty"`

	// HasIncident Shows whether this element instance has an incident related to.
	HasIncident *bool `json:"hasIncident,omitempty"`

	// IncidentKey The key of incident if field incident is true.
	IncidentKey *IncidentKey `json:"incidentKey,omitempty"`

	// ProcessDefinitionId The process definition ID associated to this element instance.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated to this element instance.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated to this element instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// StartDate The start date of this element instance.
	StartDate *DateTimeFilterProperty `json:"startDate,omitempty"`

	// State State of element instance as defined set of values.
	State *ElementInstanceStateFilterProperty `json:"state,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Type Type of element as defined set of values.
	Type *ElementInstanceFilterType `json:"type,omitempty"`
}

// ElementInstanceFilter_ElementInstanceScopeKey The scope key of this element instance. If provided with a process instance key it will return element instances that are immediate children of the process instance. If provided with an element instance key it will return element instances that are immediate children of the element instance.
type ElementInstanceFilter_ElementInstanceScopeKey struct {
	union json.RawMessage
}

// ElementInstanceFilterType Type of element as defined set of values.
type ElementInstanceFilterType string

// ElementInstanceKey Zeebe Engine resource key (Java long serialized as string)
type ElementInstanceKey = LongKey

// ElementInstanceResult defines model for ElementInstanceResult.
type ElementInstanceResult struct {
	// ElementId The element ID for this element instance.
	ElementId ElementId `json:"elementId"`

	// ElementInstanceKey The assigned key, which acts as a unique identifier for this element instance.
	ElementInstanceKey ElementInstanceKey `json:"elementInstanceKey"`

	// ElementName The element name for this element instance.
	ElementName string `json:"elementName"`

	// EndDate Date when element instance finished.
	EndDate *time.Time `json:"endDate,omitempty"`

	// HasIncident Shows whether this element instance has an incident. If true also an incidentKey is provided.
	HasIncident bool `json:"hasIncident"`

	// IncidentKey Incident key associated with this element instance.
	IncidentKey *IncidentKey `json:"incidentKey,omitempty"`

	// ProcessDefinitionId The process definition ID associated to this element instance.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The process definition key associated to this element instance.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessInstanceKey The process instance key associated to this element instance.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// StartDate Date when element instance started.
	StartDate time.Time `json:"startDate"`

	// State State of element instance as defined set of values.
	State ElementInstanceStateEnum `json:"state"`

	// TenantId The unique identifier of the tenant.
	TenantId TenantId `json:"tenantId"`

	// Type Type of element as defined set of values.
	Type ElementInstanceResultType `json:"type"`
}

// ElementInstanceResultType Type of element as defined set of values.
type ElementInstanceResultType string

// ElementInstanceSearchQuery defines model for ElementInstanceSearchQuery.
type ElementInstanceSearchQuery = SearchQueryRequest

// ElementInstanceSearchQueryResult defines model for ElementInstanceSearchQueryResult.
type ElementInstanceSearchQueryResult = SearchQueryResponse

// ElementInstanceSearchQuerySortRequest defines model for ElementInstanceSearchQuerySortRequest.
type ElementInstanceSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field ElementInstanceSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// ElementInstanceSearchQuerySortRequestField The field to sort by.
type ElementInstanceSearchQuerySortRequestField string

// ElementInstanceStateEnum Element states
type ElementInstanceStateEnum = interface{}

// ElementInstanceStateFilterProperty ElementInstanceStateEnum property with full advanced search capabilities.
type ElementInstanceStateFilterProperty struct {
	union json.RawMessage
}

// ElementInstanceStateFilterProperty0 Element states
type ElementInstanceStateFilterProperty0 = ElementInstanceStateEnum

// EndCursor The end cursor in a search query result set.
type EndCursor = interface{}

// EvaluateDecisionResult defines model for EvaluateDecisionResult.
type EvaluateDecisionResult struct {
	// DecisionDefinitionId The ID of the decision which was evaluated.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The unique key identifying the decision which was evaluated.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionDefinitionName The name of the decision which was evaluated.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionVersion The version of the decision which was evaluated.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// DecisionEvaluationKey The unique key identifying this decision evaluation.
	DecisionEvaluationKey *DecisionEvaluationKey `json:"decisionEvaluationKey,omitempty"`

	// DecisionInstanceKey Deprecated, please refer to `decisionEvaluationKey`.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	DecisionInstanceKey *DecisionInstanceKey `json:"decisionInstanceKey,omitempty"`

	// DecisionRequirementsId The ID of the decision requirements graph that the decision which was evaluated is part of.
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`

	// DecisionRequirementsKey The unique key identifying the decision requirements graph that the decision which was evaluated is part of.
	DecisionRequirementsKey *DecisionRequirementsKey `json:"decisionRequirementsKey,omitempty"`

	// EvaluatedDecisions Decisions that were evaluated within the requested decision evaluation.
	EvaluatedDecisions *[]EvaluatedDecisionResult `json:"evaluatedDecisions,omitempty"`

	// FailedDecisionDefinitionId The ID of the decision which failed during evaluation.
	FailedDecisionDefinitionId *DecisionDefinitionId `json:"failedDecisionDefinitionId,omitempty"`

	// FailureMessage Message describing why the decision which was evaluated failed.
	FailureMessage *string `json:"failureMessage,omitempty"`

	// Output JSON document that will instantiate the result of the decision which was evaluated.
	Output *string `json:"output,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// EvaluatedDecisionInputItem A decision input that was evaluated within this decision evaluation.
type EvaluatedDecisionInputItem struct {
	// InputId The ID of the evaluated decision input.
	InputId *string `json:"inputId,omitempty"`

	// InputName The name of the evaluated decision input.
	InputName *string `json:"inputName,omitempty"`

	// InputValue The value of the evaluated decision input.
	InputValue *string `json:"inputValue,omitempty"`
}

// EvaluatedDecisionOutputItem The evaluated decision outputs.
type EvaluatedDecisionOutputItem struct {
	// OutputId The ID of the evaluated decision output.
	OutputId *string `json:"outputId,omitempty"`

	// OutputName The name of the evaluated decision output.
	OutputName *string `json:"outputName,omitempty"`

	// OutputValue The value of the evaluated decision output.
	OutputValue *string `json:"outputValue,omitempty"`
}

// EvaluatedDecisionResult A decision that was evaluated.
type EvaluatedDecisionResult struct {
	// DecisionDefinitionId The ID of the decision which was evaluated.
	DecisionDefinitionId *DecisionDefinitionId `json:"decisionDefinitionId,omitempty"`

	// DecisionDefinitionKey The unique key identifying the decision which was evaluate.
	DecisionDefinitionKey *DecisionDefinitionKey `json:"decisionDefinitionKey,omitempty"`

	// DecisionDefinitionName The name of the decision which was evaluated.
	DecisionDefinitionName *string `json:"decisionDefinitionName,omitempty"`

	// DecisionDefinitionType The type of the decision which was evaluated.
	DecisionDefinitionType *string `json:"decisionDefinitionType,omitempty"`

	// DecisionDefinitionVersion The version of the decision which was evaluated.
	DecisionDefinitionVersion *int32 `json:"decisionDefinitionVersion,omitempty"`

	// DecisionEvaluationInstanceKey The unique key identifying this decision evaluation instance.
	DecisionEvaluationInstanceKey *DecisionEvaluationInstanceKey `json:"decisionEvaluationInstanceKey,omitempty"`

	// EvaluatedInputs The decision inputs that were evaluated within this decision evaluation.
	EvaluatedInputs *[]EvaluatedDecisionInputItem `json:"evaluatedInputs,omitempty"`

	// MatchedRules The decision rules that matched within this decision evaluation.
	MatchedRules *[]MatchedDecisionRuleItem `json:"matchedRules,omitempty"`

	// Output JSON document that will instantiate the result of the decision which was evaluated.
	Output *string `json:"output,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// EventOperation Fire-and-forget notification. May fan out.
type EventOperation struct {
	// Idempotent Idempotent operations cause at-most one effect regardless of how many times that are called.
	Idempotent *bool              `json:"idempotent,omitempty"`
	Kind       EventOperationKind `json:"kind"`

	// Safe Safe operations do not mutate the state of the Camunda engine.
	Safe *bool `json:"safe,omitempty"`
}

// EventOperationKind defines model for EventOperation.Kind.
type EventOperationKind string

// FormKey Zeebe Engine resource key (Java long serialized as string)
type FormKey = LongKey

// FormResult defines model for FormResult.
type FormResult struct {
	// FormId The user-provided identifier of the form.
	FormId *string `json:"formId,omitempty"`

	// FormKey The assigned key, which acts as a unique identifier for this form.
	FormKey *FormKey `json:"formKey,omitempty"`

	// Schema The form content.
	Schema *map[string]interface{} `json:"schema,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The version of the the deployed form.
	Version *int `json:"version,omitempty"`
}

// GroupClientResult defines model for GroupClientResult.
type GroupClientResult struct {
	// ClientId The ID of the client.
	ClientId *string `json:"clientId,omitempty"`
}

// GroupClientSearchQueryRequest defines model for GroupClientSearchQueryRequest.
type GroupClientSearchQueryRequest = SearchQueryRequest

// GroupClientSearchQuerySortRequest defines model for GroupClientSearchQuerySortRequest.
type GroupClientSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field GroupClientSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// GroupClientSearchQuerySortRequestField The field to sort by.
type GroupClientSearchQuerySortRequestField string

// GroupClientSearchResult defines model for GroupClientSearchResult.
type GroupClientSearchResult = SearchQueryResponse

// GroupCreateRequest defines model for GroupCreateRequest.
type GroupCreateRequest struct {
	// Description The description of the new group.
	Description *string `json:"description,omitempty"`

	// GroupId The ID of the new group.
	GroupId string `json:"groupId"`

	// Name The display name of the new group.
	Name string `json:"name"`
}

// GroupCreateResult defines model for GroupCreateResult.
type GroupCreateResult struct {
	// Description The description of the created group.
	Description *string `json:"description,omitempty"`

	// GroupId The ID of the created group.
	GroupId *string `json:"groupId,omitempty"`

	// Name The display name of the created group.
	Name *string `json:"name,omitempty"`
}

// GroupFilter Group filter request
type GroupFilter struct {
	// GroupId The group ID search filters.
	GroupId *StringFilterProperty `json:"groupId,omitempty"`

	// Name The group name search filters.
	Name *string `json:"name,omitempty"`
}

// GroupResult Group search response item.
type GroupResult struct {
	// Description The group description.
	Description *string `json:"description,omitempty"`

	// GroupId The group ID.
	GroupId *string `json:"groupId,omitempty"`

	// Name The group name.
	Name *string `json:"name,omitempty"`
}

// GroupSearchQueryRequest defines model for GroupSearchQueryRequest.
type GroupSearchQueryRequest = SearchQueryRequest

// GroupSearchQueryResult defines model for GroupSearchQueryResult.
type GroupSearchQueryResult = SearchQueryResponse

// GroupSearchQuerySortRequest defines model for GroupSearchQuerySortRequest.
type GroupSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field GroupSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// GroupSearchQuerySortRequestField The field to sort by.
type GroupSearchQuerySortRequestField string

// GroupUpdateRequest defines model for GroupUpdateRequest.
type GroupUpdateRequest struct {
	// Description The new description of the group.
	Description string `json:"description"`

	// Name The new name of the group.
	Name string `json:"name"`
}

// GroupUpdateResult defines model for GroupUpdateResult.
type GroupUpdateResult struct {
	// Description The description of the group.
	Description *string `json:"description,omitempty"`

	// GroupId The unique external group ID.
	GroupId *string `json:"groupId,omitempty"`

	// Name The name of the group.
	Name *string `json:"name,omitempty"`
}

// GroupUserResult defines model for GroupUserResult.
type GroupUserResult struct {
	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// GroupUserSearchQueryRequest defines model for GroupUserSearchQueryRequest.
type GroupUserSearchQueryRequest = SearchQueryRequest

// GroupUserSearchQuerySortRequest defines model for GroupUserSearchQuerySortRequest.
type GroupUserSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field GroupUserSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// GroupUserSearchQuerySortRequestField The field to sort by.
type GroupUserSearchQuerySortRequestField string

// GroupUserSearchResult defines model for GroupUserSearchResult.
type GroupUserSearchResult = SearchQueryResponse

// IncidentFilter Incident search filter.
type IncidentFilter struct {
	// CreationTime Date of incident creation.
	CreationTime *time.Time `json:"creationTime,omitempty"`

	// ElementId The element ID associated to this incident.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key associated to this incident.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// ErrorMessage Error message which describes the error in more detail.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// ErrorType Incident error type with a defined set of values.
	ErrorType *IncidentFilterErrorType `json:"errorType,omitempty"`

	// IncidentKey The assigned key, which acts as a unique identifier for this incident.
	IncidentKey *IncidentKey `json:"incidentKey,omitempty"`

	// JobKey The job key, if exists, associated with this incident.
	JobKey *JobKey `json:"jobKey,omitempty"`

	// ProcessDefinitionId The process definition ID associated to this incident.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated to this incident.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated to this incident.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// State State of this incident with a defined set of values.
	State *IncidentFilterState `json:"state,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// IncidentFilterErrorType Incident error type with a defined set of values.
type IncidentFilterErrorType string

// IncidentFilterState State of this incident with a defined set of values.
type IncidentFilterState string

// IncidentKey Zeebe Engine resource key (Java long serialized as string)
type IncidentKey = LongKey

// IncidentResolutionRequest defines model for IncidentResolutionRequest.
type IncidentResolutionRequest struct {
	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`
}

// IncidentResult defines model for IncidentResult.
type IncidentResult struct {
	// CreationTime Date of incident creation.
	CreationTime *time.Time `json:"creationTime,omitempty"`

	// ElementId The element ID associated to this incident.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key associated to this incident.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// ErrorMessage Error message which describes the error in more detail.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// ErrorType Incident error type with a defined set of values.
	ErrorType *IncidentResultErrorType `json:"errorType,omitempty"`

	// IncidentKey The assigned key, which acts as a unique identifier for this incident.
	IncidentKey *IncidentKey `json:"incidentKey,omitempty"`

	// JobKey The job key, if exists, associated with this incident.
	JobKey *JobKey `json:"jobKey,omitempty"`

	// ProcessDefinitionId The process definition ID associated to this incident.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated to this incident.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated to this incident.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// State State of this incident with a defined set of values.
	State *IncidentResultState `json:"state,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// IncidentResultErrorType Incident error type with a defined set of values.
type IncidentResultErrorType string

// IncidentResultState State of this incident with a defined set of values.
type IncidentResultState string

// IncidentSearchQuery defines model for IncidentSearchQuery.
type IncidentSearchQuery = SearchQueryRequest

// IncidentSearchQueryResult defines model for IncidentSearchQueryResult.
type IncidentSearchQueryResult = SearchQueryResponse

// IncidentSearchQuerySortRequest defines model for IncidentSearchQuerySortRequest.
type IncidentSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field IncidentSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// IncidentSearchQuerySortRequestField The field to sort by.
type IncidentSearchQuerySortRequestField string

// IntegerFilterProperty Integer property with advanced search capabilities.
type IntegerFilterProperty struct {
	union json.RawMessage
}

// IntegerFilterProperty0 Matches the value exactly.
type IntegerFilterProperty0 = int32

// JobActivationRequest defines model for JobActivationRequest.
type JobActivationRequest struct {
	// FetchVariable A list of variables to fetch as the job variables; if empty, all visible variables at the time of activation for the scope of the job will be returned.
	FetchVariable *[]string `json:"fetchVariable,omitempty"`

	// MaxJobsToActivate The maximum jobs to activate by this request.
	MaxJobsToActivate int32 `json:"maxJobsToActivate"`

	// RequestTimeout The request will be completed when at least one job is activated or after the requestTimeout (in ms). If the requestTimeout = 0, a default timeout is used. If the requestTimeout < 0, long polling is disabled and the request is completed immediately, even when no job is activated.
	RequestTimeout *int `json:"requestTimeout,omitempty"`

	// TenantIds A list of IDs of tenants for which to activate jobs.
	TenantIds *[]TenantId `json:"tenantIds,omitempty"`

	// Timeout A job returned after this call will not be activated by another call until the timeout (in ms) has been reached.
	Timeout int `json:"timeout"`

	// Type The job type, as defined in the BPMN process (e.g. <zeebe:taskDefinition type="payment-service" />).
	Type string `json:"type"`

	// Worker The name of the worker activating the jobs, mostly used for logging purposes.
	Worker *string `json:"worker,omitempty"`
}

// JobActivationResult The list of activated jobs
type JobActivationResult struct {
	// Jobs The activated jobs.
	Jobs []ActivatedJobResult `json:"jobs"`
}

// JobChangeset JSON object with changed job attribute values.
//
// The following attributes can be adjusted with this endpoint, additional attributes
// will be ignored:
//
// * `retries` - The new amount of retries for the job; must be a positive number.
// * `timeout` - The duration of the new timeout in ms, starting from the current moment.
//
// Providing any of those attributes with a null value or omitting it preserves the persisted attributeâ€™s value.
//
// The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
type JobChangeset struct {
	// Retries The new amount of retries for the job; must be a positive number.
	Retries nullable.Nullable[int32] `json:"retries,omitempty"`

	// Timeout The duration of the new timeout in ms, starting from the current moment.
	Timeout nullable.Nullable[int] `json:"timeout,omitempty"`
}

// JobCompletionRequest defines model for JobCompletionRequest.
type JobCompletionRequest struct {
	// Result The result of the completed job as determined by the worker.
	Result *JobResult `json:"result,omitempty"`

	// Variables The variables to complete the job with.
	Variables nullable.Nullable[map[string]interface{}] `json:"variables,omitempty"`
}

// JobErrorRequest defines model for JobErrorRequest.
type JobErrorRequest struct {
	// ErrorCode The error code that will be matched with an error catch event.
	ErrorCode string `json:"errorCode"`

	// ErrorMessage An error message that provides additional context.
	ErrorMessage nullable.Nullable[string] `json:"errorMessage,omitempty"`

	// Variables JSON object that will instantiate the variables at the local scope of the error catch event that catches the thrown error.
	Variables nullable.Nullable[map[string]interface{}] `json:"variables,omitempty"`
}

// JobFailRequest defines model for JobFailRequest.
type JobFailRequest struct {
	// ErrorMessage An optional message describing why the job failed. This is particularly useful if a job runs out of retries and an incident is raised, as this message can help explain why an incident was raised.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Retries The amount of retries the job should have left
	Retries *int32 `json:"retries,omitempty"`

	// RetryBackOff The backoff timeout (in ms) for the next retry.
	RetryBackOff *int `json:"retryBackOff,omitempty"`

	// Variables JSON object that will instantiate the variables at the local scope of the job's associated task.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// JobFilter Job search filter.
type JobFilter struct {
	// Deadline If this is set, when the job can next be activated.
	Deadline nullable.Nullable[DateTimeFilterProperty] `json:"deadline,omitempty"`

	// DeniedReason The reason provided by the user task listener for denying the work.
	DeniedReason *StringFilterProperty `json:"deniedReason,omitempty"`

	// ElementId The element ID associated with the job.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key associated with the job.
	ElementInstanceKey *JobFilter_ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// EndTime When the job ended.
	EndTime *DateTimeFilterProperty `json:"endTime,omitempty"`

	// ErrorCode The error code provided for the failed job.
	ErrorCode *StringFilterProperty `json:"errorCode,omitempty"`

	// ErrorMessage The error message that provides additional context for a failed job.
	ErrorMessage *StringFilterProperty `json:"errorMessage,omitempty"`

	// HasFailedWithRetriesLeft Indicates whether the job has failed with retries left.
	HasFailedWithRetriesLeft *bool `json:"hasFailedWithRetriesLeft,omitempty"`

	// IsDenied Indicates whether the user task listener denies the work.
	IsDenied nullable.Nullable[bool] `json:"isDenied,omitempty"`

	// JobKey The key, a unique identifier for the job.
	JobKey *JobFilter_JobKey `json:"jobKey,omitempty"`

	// Kind The kind of the job.
	Kind *JobKindFilterProperty `json:"kind,omitempty"`

	// ListenerEventType The listener event type of the job.
	ListenerEventType *JobListenerEventTypeFilterProperty `json:"listenerEventType,omitempty"`

	// ProcessDefinitionId The process definition ID associated with the job.
	ProcessDefinitionId *StringFilterProperty `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated with the job.
	ProcessDefinitionKey *JobFilter_ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated with the job.
	ProcessInstanceKey *JobFilter_ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// Retries The number of retries left.
	Retries *IntegerFilterProperty `json:"retries,omitempty"`

	// State The state of the job.
	State *JobStateFilterProperty `json:"state,omitempty"`

	// TenantId The tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// Type The type of the job.
	Type *StringFilterProperty `json:"type,omitempty"`

	// Worker The name of the worker for this job.
	Worker *StringFilterProperty `json:"worker,omitempty"`
}

// JobFilter_ElementInstanceKey The element instance key associated with the job.
type JobFilter_ElementInstanceKey struct {
	union json.RawMessage
}

// JobFilter_JobKey The key, a unique identifier for the job.
type JobFilter_JobKey struct {
	union json.RawMessage
}

// JobFilter_ProcessDefinitionKey The process definition key associated with the job.
type JobFilter_ProcessDefinitionKey struct {
	union json.RawMessage
}

// JobFilter_ProcessInstanceKey The process instance key associated with the job.
type JobFilter_ProcessInstanceKey struct {
	union json.RawMessage
}

// JobKey Zeebe Engine resource key (Java long serialized as string)
type JobKey = LongKey

// JobKindEnum The job kind.
type JobKindEnum = interface{}

// JobKindFilterProperty JobKindEnum property with full advanced search capabilities.
type JobKindFilterProperty struct {
	union json.RawMessage
}

// JobKindFilterProperty0 The job kind.
type JobKindFilterProperty0 = JobKindEnum

// JobListenerEventTypeEnum The listener event type of the job.
type JobListenerEventTypeEnum = interface{}

// JobListenerEventTypeFilterProperty JobListenerEventTypeEnum property with full advanced search capabilities.
type JobListenerEventTypeFilterProperty struct {
	union json.RawMessage
}

// JobListenerEventTypeFilterProperty0 The listener event type of the job.
type JobListenerEventTypeFilterProperty0 = JobListenerEventTypeEnum

// JobResult The result of the completed job as determined by the worker.
type JobResult struct {
	// Type Used to distinguish between different types of job results.
	Type JobResultType `json:"type"`
}

// JobResultType Used to distinguish between different types of job results.
type JobResultType string

// JobResultActivateElement defines model for JobResultActivateElement.
type JobResultActivateElement struct {
	// ElementId The ID of the element to activate.
	ElementId *ElementId `json:"elementId,omitempty"`

	// Variables JSON document that will create the variables on the scope of the activated element.
	// It must be a JSON object, as variables will be mapped in a key-value fashion.
	Variables nullable.Nullable[map[string]interface{}] `json:"variables,omitempty"`
}

// JobResultAdHocSubProcess defines model for JobResultAdHocSubProcess.
type JobResultAdHocSubProcess struct {
	// ActivateElements Indicates which elements need to be activated in the ad-hoc subprocess.
	ActivateElements *[]JobResultActivateElement `json:"activateElements,omitempty"`

	// IsCancelRemainingInstances Indicates whether the remaining instances of the ad-hoc subprocess should be canceled.
	IsCancelRemainingInstances *bool `json:"isCancelRemainingInstances,omitempty"`

	// IsCompletionConditionFulfilled Indicates whether the completion condition of the ad-hoc subprocess is fulfilled.
	IsCompletionConditionFulfilled *bool `json:"isCompletionConditionFulfilled,omitempty"`

	// Type Used to distinguish between different types of job results.
	Type JobResultAdHocSubProcessType `json:"type"`
}

// JobResultAdHocSubProcessType Used to distinguish between different types of job results.
type JobResultAdHocSubProcessType string

// JobResultCorrections JSON object with attributes that were corrected by the worker.
//
// The following attributes can be corrected, additional attributes will be ignored:
//
// * `assignee` - clear by providing an empty String
// * `dueDate` - clear by providing an empty String
// * `followUpDate` - clear by providing an empty String
// * `candidateGroups` - clear by providing an empty list
// * `candidateUsers` - clear by providing an empty list
// * `priority` - minimum 0, maximum 100, default 50
//
// Providing any of those attributes with a `null` value or omitting it preserves
// the persisted attribute's value.
type JobResultCorrections struct {
	// Assignee Assignee of the task.
	Assignee nullable.Nullable[string] `json:"assignee,omitempty"`

	// CandidateGroups The list of candidate groups of the task.
	CandidateGroups nullable.Nullable[[]string] `json:"candidateGroups,omitempty"`

	// CandidateUsers The list of candidate users of the task.
	CandidateUsers nullable.Nullable[[]string] `json:"candidateUsers,omitempty"`

	// DueDate The due date of the task.
	DueDate nullable.Nullable[time.Time] `json:"dueDate,omitempty"`

	// FollowUpDate The follow-up date of the task.
	FollowUpDate nullable.Nullable[time.Time] `json:"followUpDate,omitempty"`

	// Priority The priority of the task.
	Priority nullable.Nullable[int32] `json:"priority,omitempty"`
}

// JobResultUserTask defines model for JobResultUserTask.
type JobResultUserTask struct {
	// Corrections JSON object with attributes that were corrected by the worker.
	//
	// The following attributes can be corrected, additional attributes will be ignored:
	//
	// * `assignee` - clear by providing an empty String
	// * `dueDate` - clear by providing an empty String
	// * `followUpDate` - clear by providing an empty String
	// * `candidateGroups` - clear by providing an empty list
	// * `candidateUsers` - clear by providing an empty list
	// * `priority` - minimum 0, maximum 100, default 50
	//
	// Providing any of those attributes with a `null` value or omitting it preserves
	// the persisted attribute's value.
	Corrections nullable.Nullable[JobResultCorrections] `json:"corrections,omitempty"`

	// Denied Indicates whether the worker denies the work, i.e. explicitly doesn't approve it. For example, a user task listener can deny the completion of a task by setting this flag to true. In this example, the completion of a task is represented by a job that the worker can complete as denied. As a result, the completion request is rejected and the task remains active. Defaults to false.
	Denied nullable.Nullable[bool] `json:"denied,omitempty"`

	// DeniedReason The reason provided by the user task listener for denying the work.
	DeniedReason nullable.Nullable[string] `json:"deniedReason,omitempty"`

	// Type Used to distinguish between different types of job results.
	Type JobResultUserTaskType `json:"type"`
}

// JobResultUserTaskType Used to distinguish between different types of job results.
type JobResultUserTaskType string

// JobSearchQuery defines model for JobSearchQuery.
type JobSearchQuery = SearchQueryRequest

// JobSearchQueryResult defines model for JobSearchQueryResult.
type JobSearchQueryResult = SearchQueryResponse

// JobSearchQuerySortRequest defines model for JobSearchQuerySortRequest.
type JobSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field JobSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// JobSearchQuerySortRequestField The field to sort by.
type JobSearchQuerySortRequestField string

// JobSearchResult defines model for JobSearchResult.
type JobSearchResult struct {
	// CustomHeaders A set of custom headers defined during modelling.
	CustomHeaders map[string]string `json:"customHeaders"`

	// Deadline If the job has been activated, when it will next be available to be activated.
	Deadline nullable.Nullable[time.Time] `json:"deadline,omitempty"`

	// DeniedReason The reason provided by the user task listener for denying the work.
	DeniedReason nullable.Nullable[string] `json:"deniedReason,omitempty"`

	// ElementId The element ID associated with the job.
	ElementId ElementId `json:"elementId"`

	// ElementInstanceKey The element instance key associated with the job.
	ElementInstanceKey ElementInstanceKey `json:"elementInstanceKey"`

	// EndTime When the job ended.
	EndTime *time.Time `json:"endTime,omitempty"`

	// ErrorCode The error code provided for a failed job.
	ErrorCode nullable.Nullable[string] `json:"errorCode,omitempty"`

	// ErrorMessage The error message that provides additional context for a failed job.
	ErrorMessage nullable.Nullable[string] `json:"errorMessage,omitempty"`

	// HasFailedWithRetriesLeft Indicates whether the job has failed with retries left.
	HasFailedWithRetriesLeft bool `json:"hasFailedWithRetriesLeft"`

	// IsDenied Indicates whether the user task listener denies the work.
	IsDenied nullable.Nullable[bool] `json:"isDenied,omitempty"`

	// JobKey The key, a unique identifier for the job.
	JobKey JobKey `json:"jobKey"`

	// Kind The job kind.
	Kind JobKindEnum `json:"kind"`

	// ListenerEventType The listener event type of the job.
	ListenerEventType JobListenerEventTypeEnum `json:"listenerEventType"`

	// ProcessDefinitionId The process definition ID associated with the job.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The process definition key associated with the job.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessInstanceKey The process instance key associated with the job.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// Retries The amount of retries left to this job.
	Retries int32 `json:"retries"`

	// State The state of the job.
	State JobStateEnum `json:"state"`

	// TenantId The unique identifier of the tenant.
	TenantId TenantId `json:"tenantId"`

	// Type The type of the job.
	Type string `json:"type"`

	// Worker The name of the worker of this job.
	Worker string `json:"worker"`
}

// JobStateEnum The state of the job.
type JobStateEnum = interface{}

// JobStateFilterProperty JobStateEnum property with full advanced search capabilities.
type JobStateFilterProperty struct {
	union json.RawMessage
}

// JobStateFilterProperty0 The state of the job.
type JobStateFilterProperty0 = JobStateEnum

// JobUpdateRequest defines model for JobUpdateRequest.
type JobUpdateRequest struct {
	// Changeset JSON object with changed job attribute values.
	//
	// The following attributes can be adjusted with this endpoint, additional attributes
	// will be ignored:
	//
	// * `retries` - The new amount of retries for the job; must be a positive number.
	// * `timeout` - The duration of the new timeout in ms, starting from the current moment.
	//
	// Providing any of those attributes with a null value or omitting it preserves the persisted attributeâ€™s value.
	//
	// The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
	Changeset JobChangeset `json:"changeset"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`
}

// LicenseResponse The response of a license request.
type LicenseResponse struct {
	// ExpiresAt The date when the Camunda license expires
	ExpiresAt nullable.Nullable[time.Time] `json:"expiresAt,omitempty"`

	// IsCommercial Will be false when a license contains a non-commerical=true property
	IsCommercial bool `json:"isCommercial"`

	// LicenseType Will return the license type property of the Camunda license
	LicenseType string `json:"licenseType"`

	// ValidLicense True if the Camunda license is valid, false if otherwise
	ValidLicense bool `json:"validLicense"`
}

// LikeFilterProperty Checks if the property matches the provided like value.
//
// Supported wildcard characters are:
//
// * `*`: matches zero, one, or multiple characters.
// * `?`: matches one, single character.
//
// Wildcard characters can be escaped with backslash, for instance: `\*`.
type LikeFilterProperty = string

// LongKey Zeebe Engine resource key (Java long serialized as string)
type LongKey = string

// MappingRuleCreateRequest defines model for MappingRuleCreateRequest.
type MappingRuleCreateRequest = MappingRuleCreateUpdateRequest

// MappingRuleCreateResult defines model for MappingRuleCreateResult.
type MappingRuleCreateResult = MappingRuleCreateUpdateResult

// MappingRuleCreateUpdateRequest defines model for MappingRuleCreateUpdateRequest.
type MappingRuleCreateUpdateRequest struct {
	// ClaimName The name of the claim to map.
	ClaimName string `json:"claimName"`

	// ClaimValue The value of the claim to map.
	ClaimValue string `json:"claimValue"`

	// Name The name of the mapping.
	Name string `json:"name"`
}

// MappingRuleCreateUpdateResult defines model for MappingRuleCreateUpdateResult.
type MappingRuleCreateUpdateResult struct {
	// ClaimName The name of the claim to map.
	ClaimName *string `json:"claimName,omitempty"`

	// ClaimValue The value of the claim to map.
	ClaimValue *string `json:"claimValue,omitempty"`

	// MappingRuleId The unique ID of the mapping rule.
	MappingRuleId *string `json:"mappingRuleId,omitempty"`

	// Name The name of the mapping rule.
	Name *string `json:"name,omitempty"`
}

// MappingRuleFilter Mapping rule search filter.
type MappingRuleFilter struct {
	// ClaimName The claim name to match against a token.
	ClaimName *string `json:"claimName,omitempty"`

	// ClaimValue The value of the claim to match.
	ClaimValue *string `json:"claimValue,omitempty"`

	// MappingRuleId The ID of the mapping.
	MappingRuleId *string `json:"mappingRuleId,omitempty"`

	// Name The name of the mapping.
	Name *string `json:"name,omitempty"`
}

// MappingRuleResult defines model for MappingRuleResult.
type MappingRuleResult struct {
	// ClaimName The name of the claim to map.
	ClaimName *string `json:"claimName,omitempty"`

	// ClaimValue The value of the claim to map.
	ClaimValue *string `json:"claimValue,omitempty"`

	// MappingRuleId The ID of the mapping rule.
	MappingRuleId *string `json:"mappingRuleId,omitempty"`

	// Name The name of the mapping rule.
	Name *string `json:"name,omitempty"`
}

// MappingRuleSearchQueryRequest defines model for MappingRuleSearchQueryRequest.
type MappingRuleSearchQueryRequest = SearchQueryRequest

// MappingRuleSearchQueryResult defines model for MappingRuleSearchQueryResult.
type MappingRuleSearchQueryResult = SearchQueryResponse

// MappingRuleSearchQuerySortRequest defines model for MappingRuleSearchQuerySortRequest.
type MappingRuleSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field MappingRuleSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// MappingRuleSearchQuerySortRequestField The field to sort by.
type MappingRuleSearchQuerySortRequestField string

// MappingRuleUpdateRequest defines model for MappingRuleUpdateRequest.
type MappingRuleUpdateRequest = MappingRuleCreateUpdateRequest

// MappingRuleUpdateResult defines model for MappingRuleUpdateResult.
type MappingRuleUpdateResult = MappingRuleCreateUpdateResult

// MatchedDecisionRuleItem A decision rule that matched within this decision evaluation.
type MatchedDecisionRuleItem struct {
	// EvaluatedOutputs The evaluated decision outputs.
	EvaluatedOutputs *[]EvaluatedDecisionOutputItem `json:"evaluatedOutputs,omitempty"`

	// RuleId The ID of the matched rule.
	RuleId *string `json:"ruleId,omitempty"`

	// RuleIndex The index of the matched rule.
	RuleIndex *int32 `json:"ruleIndex,omitempty"`
}

// MessageCorrelationKey Zeebe Engine resource key (Java long serialized as string)
type MessageCorrelationKey = LongKey

// MessageCorrelationRequest defines model for MessageCorrelationRequest.
type MessageCorrelationRequest struct {
	// CorrelationKey The correlation key of the message.
	CorrelationKey string `json:"correlationKey"`

	// Name The message name as defined in the BPMN process
	Name string `json:"name"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables The message variables as JSON document
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// MessageCorrelationResult The message key of the correlated message, as well as the first process instance key it
// correlated with.
type MessageCorrelationResult struct {
	// MessageKey The key of the correlated message
	MessageKey *MessageCorrelationKey `json:"messageKey,omitempty"`

	// ProcessInstanceKey The key of the first process instance the message correlated with
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// TenantId The tenant ID of the correlated message
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// MessageKey Zeebe Engine resource key (Java long serialized as string)
type MessageKey = LongKey

// MessagePublicationRequest defines model for MessagePublicationRequest.
type MessagePublicationRequest struct {
	// CorrelationKey The correlation key of the message.
	CorrelationKey string `json:"correlationKey"`

	// MessageId The unique ID of the message. This is used to ensure only one message with the given ID
	// will be published during the lifetime of the message (if `timeToLive` is set).
	MessageId *string `json:"messageId,omitempty"`

	// Name The name of the message.
	Name string `json:"name"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// TimeToLive Timespan (in ms) to buffer the message on the broker.
	TimeToLive *int `json:"timeToLive,omitempty"`

	// Variables The message variables as JSON document.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// MessagePublicationResult The message key of the published message.
type MessagePublicationResult struct {
	// MessageKey The key of the message
	MessageKey *MessageKey `json:"messageKey,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// MessageSubscriptionFilter Message subscription search filter.
type MessageSubscriptionFilter struct {
	// CorrelationKey The correlation key of the message subscription.
	CorrelationKey *StringFilterProperty `json:"correlationKey,omitempty"`

	// ElementId The element ID associated with this message subscription.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key associated with this message subscription.
	ElementInstanceKey *AdvancedElementInstanceKeyFilter `json:"elementInstanceKey,omitempty"`

	// LastUpdatedDate The last updated date of the message subscription.
	LastUpdatedDate *DateTimeFilterProperty `json:"lastUpdatedDate,omitempty"`

	// MessageName The name of the message associated with the message subscription.
	MessageName *StringFilterProperty `json:"messageName,omitempty"`

	// MessageSubscriptionKey The message subscription key associated with this message subscription.
	MessageSubscriptionKey *AdvancedMessageSubscriptionKeyFilter `json:"messageSubscriptionKey,omitempty"`

	// MessageSubscriptionType The message subscription type.
	MessageSubscriptionType *MessageSubscriptionTypeFilterProperty `json:"messageSubscriptionType,omitempty"`

	// ProcessDefinitionId The process definition ID associated with this message subscription.
	ProcessDefinitionId *StringFilterProperty `json:"processDefinitionId,omitempty"`

	// ProcessInstanceKey The process instance key associated with this message subscription.
	ProcessInstanceKey *AdvancedProcessInstanceKeyFilter `json:"processInstanceKey,omitempty"`

	// TenantId The unique external tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`
}

// MessageSubscriptionKey Zeebe Engine resource key (Java long serialized as string)
type MessageSubscriptionKey = LongKey

// MessageSubscriptionResult defines model for MessageSubscriptionResult.
type MessageSubscriptionResult struct {
	// CorrelationKey The correlation key of the message subscription.
	CorrelationKey *MessageCorrelationKey `json:"correlationKey,omitempty"`

	// ElementId The element ID associated with this message subscription.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The element instance key associated with this message subscription.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// LastUpdatedDate The last updated date of the message subscription.
	LastUpdatedDate *time.Time `json:"lastUpdatedDate,omitempty"`

	// MessageName The name of the message associated with the message subscription.
	MessageName *string `json:"messageName,omitempty"`

	// MessageSubscriptionKey The message subscription key associated with this message subscription.
	MessageSubscriptionKey *MessageSubscriptionKey `json:"messageSubscriptionKey,omitempty"`

	// MessageSubscriptionType The type of message subscription.
	MessageSubscriptionType *MessageSubscriptionTypeEnum `json:"messageSubscriptionType,omitempty"`

	// ProcessDefinitionId The process definition ID associated with this message subscription.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key associated with this message subscription.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The process instance key associated with this message subscription.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// MessageSubscriptionSearchQuery defines model for MessageSubscriptionSearchQuery.
type MessageSubscriptionSearchQuery = SearchQueryRequest

// MessageSubscriptionSearchQueryResult defines model for MessageSubscriptionSearchQueryResult.
type MessageSubscriptionSearchQueryResult = SearchQueryResponse

// MessageSubscriptionSearchQuerySortRequest defines model for MessageSubscriptionSearchQuerySortRequest.
type MessageSubscriptionSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field MessageSubscriptionSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// MessageSubscriptionSearchQuerySortRequestField The field to sort by.
type MessageSubscriptionSearchQuerySortRequestField string

// MessageSubscriptionTypeEnum The type of message subscription.
type MessageSubscriptionTypeEnum string

// MessageSubscriptionTypeFilterProperty MessageSubscriptionTypeEnum with full advanced search capabilities.
type MessageSubscriptionTypeFilterProperty struct {
	union json.RawMessage
}

// MessageSubscriptionTypeFilterProperty0 The type of message subscription.
type MessageSubscriptionTypeFilterProperty0 = MessageSubscriptionTypeEnum

// MigrateProcessInstanceMappingInstruction The mapping instructions describe how to map elements from the source process definition to the target process definition.
type MigrateProcessInstanceMappingInstruction struct {
	// SourceElementId The element ID to migrate from.
	SourceElementId ElementId `json:"sourceElementId"`

	// TargetElementId The element ID to migrate into.
	TargetElementId ElementId `json:"targetElementId"`
}

// ModifyProcessInstanceVariableInstruction Instructions describing which variables should be created.
type ModifyProcessInstanceVariableInstruction struct {
	// ScopeId The ID of the element in which scope the variables should be created.
	// Leave empty to create the variables in the global scope of the process instance
	ScopeId *string `json:"scopeId,omitempty"`

	// Variables JSON document that will instantiate the variables for the root variable scope of the process instance.
	// It must be a JSON object, as variables will be mapped in a key-value fashion.
	Variables map[string]interface{} `json:"variables"`
}

// OffsetPagination defines model for OffsetPagination.
type OffsetPagination struct {
	// From The index of items to start searching from.
	From *int32 `json:"from,omitempty"`

	// Limit The maximum number of items to return in one request. <=10,000 for ElasticSearch.
	Limit *int32 `json:"limit,omitempty"`
}

// OperationMetadata Information about the operation effect characteristics. Suitable for reasoning about the idempotency and safety of operations
type OperationMetadata struct {
	union json.RawMessage
}

// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
// Must be > 0 if provided.
type OperationReference = int

// OwnerTypeEnum The type of the owner of permissions.
type OwnerTypeEnum = interface{}

// Partition Provides information on a partition within a broker node.
type Partition struct {
	// Health Describes the current health of the partition.
	Health PartitionHealth `json:"health"`

	// PartitionId The unique ID of this partition.
	PartitionId int32 `json:"partitionId"`

	// Role Describes the Raft role of the broker for a given partition.
	Role PartitionRole `json:"role"`
}

// PartitionHealth Describes the current health of the partition.
type PartitionHealth string

// PartitionRole Describes the Raft role of the broker for a given partition.
type PartitionRole string

// PatchOperation Updates a resource.
type PatchOperation struct {
	// Idempotent Idempotent operations cause at-most one effect regardless of how many times that are called.
	Idempotent *bool              `json:"idempotent,omitempty"`
	Kind       PatchOperationKind `json:"kind"`

	// Safe Safe operations do not mutate the state of the Camunda engine.
	Safe *bool `json:"safe,omitempty"`
}

// PatchOperationKind defines model for PatchOperation.Kind.
type PatchOperationKind string

// PermissionTypeEnum Specifies the type of permissions.
type PermissionTypeEnum = interface{}

// ProblemDetail A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type ProblemDetail struct {
	// Detail An explanation of the problem in more detail.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI identifying the origin of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code for this problem.
	Status *int32 `json:"status,omitempty"`

	// Title A summary of the problem type.
	Title *string `json:"title,omitempty"`

	// Type A URI identifying the problem type.
	Type *string `json:"type,omitempty"`
}

// ProcessDefinitionElementStatisticsQuery Process definition element statistics request.
type ProcessDefinitionElementStatisticsQuery struct {
	// Filter The process definition statistics search filters.
	Filter *ProcessDefinitionStatisticsFilter `json:"filter,omitempty"`
}

// ProcessDefinitionElementStatisticsQueryResult Process definition element statistics query response.
type ProcessDefinitionElementStatisticsQueryResult struct {
	// Items The element statistics.
	Items *[]ProcessElementStatisticsResult `json:"items,omitempty"`
}

// ProcessDefinitionFilter Process definition search filter.
type ProcessDefinitionFilter struct {
	// HasStartForm Indicates whether the start event of the process has an associated Form Key.
	HasStartForm *bool `json:"hasStartForm,omitempty"`

	// IsLatestVersion Whether to only return the latest version of each process definition. When using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`. The response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.
	IsLatestVersion *bool `json:"isLatestVersion,omitempty"`

	// Name Name of this process definition.
	Name *StringFilterProperty `json:"name,omitempty"`

	// ProcessDefinitionId Process definition ID of this process definition.
	ProcessDefinitionId *StringFilterProperty `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The key for this process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ResourceName Resource name of this process definition.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version Version of this process definition.
	Version *int32 `json:"version,omitempty"`

	// VersionTag Version tag of this process definition.
	VersionTag *string `json:"versionTag,omitempty"`
}

// ProcessDefinitionId Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
type ProcessDefinitionId = string

// ProcessDefinitionKey Zeebe Engine resource key (Java long serialized as string)
type ProcessDefinitionKey = LongKey

// ProcessDefinitionResult defines model for ProcessDefinitionResult.
type ProcessDefinitionResult struct {
	// HasStartForm Indicates whether the start event of the process has an associated Form Key.
	HasStartForm *bool `json:"hasStartForm,omitempty"`

	// Name Name of this process definition.
	Name *string `json:"name,omitempty"`

	// ProcessDefinitionId Process definition ID of this process definition.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The key for this process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ResourceName Resource name for this process definition.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version Version of this process definition.
	Version *int32 `json:"version,omitempty"`

	// VersionTag Version tag of this process definition.
	VersionTag *string `json:"versionTag,omitempty"`
}

// ProcessDefinitionSearchQuery defines model for ProcessDefinitionSearchQuery.
type ProcessDefinitionSearchQuery = SearchQueryRequest

// ProcessDefinitionSearchQueryResult defines model for ProcessDefinitionSearchQueryResult.
type ProcessDefinitionSearchQueryResult = SearchQueryResponse

// ProcessDefinitionSearchQuerySortRequest defines model for ProcessDefinitionSearchQuerySortRequest.
type ProcessDefinitionSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field ProcessDefinitionSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// ProcessDefinitionSearchQuerySortRequestField The field to sort by.
type ProcessDefinitionSearchQuerySortRequestField string

// ProcessDefinitionStatisticsFilter defines model for ProcessDefinitionStatisticsFilter.
type ProcessDefinitionStatisticsFilter struct {
	// Or Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
	//
	// Top-level fields and the `$or` clause are combined using AND logic â€” meaning: (top-level filters) AND (any of the `$or` filters) must match.
	// <br>
	// <em>Example:</em>
	//
	// ```json
	// {
	//   "state": "ACTIVE",
	//   "tenantId": 123,
	//   "$or": [
	//     { "processDefinitionId": "process_v1" },
	//     { "processDefinitionId": "process_v2", "hasIncident": true }
	//   ]
	// }
	// ```
	// This matches process instances that:
	//
	// <ul style="padding-left: 20px; margin-left: 20px;">
	//   <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>
	//   <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>
	//   <li style="list-style-type: disc;">and match either:
	//     <ul style="padding-left: 20px; margin-left: 20px;">
	//       <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>
	//       <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>
	//     </ul>
	//   </li>
	// </ul>
	// <br>
	// <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.
	Or *[]BaseProcessInstanceFilterFields `json:"$or,omitempty"`

	// BatchOperationId The batch operation ID.
	BatchOperationId *StringFilterProperty `json:"batchOperationId,omitempty"`

	// ElementId The element ID associated with the process instance.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceState The state of the element instances associated with the process instance.
	ElementInstanceState *ElementInstanceStateFilterProperty `json:"elementInstanceState,omitempty"`

	// EndDate The end date.
	EndDate *DateTimeFilterProperty `json:"endDate,omitempty"`

	// ErrorMessage The error message related to the process.
	ErrorMessage *StringFilterProperty `json:"errorMessage,omitempty"`

	// HasElementInstanceIncident Whether the element instance has an incident or not.
	HasElementInstanceIncident *bool `json:"hasElementInstanceIncident,omitempty"`

	// HasIncident Whether this process instance has a related incident or not.
	HasIncident *bool `json:"hasIncident,omitempty"`

	// HasRetriesLeft Whether the process has failed jobs with retries left.
	HasRetriesLeft *bool `json:"hasRetriesLeft,omitempty"`

	// IncidentErrorHashCode The incident error hash code, associated with this process.
	IncidentErrorHashCode *IntegerFilterProperty `json:"incidentErrorHashCode,omitempty"`

	// ParentElementInstanceKey The parent element instance key.
	ParentElementInstanceKey *ProcessDefinitionStatisticsFilter_ParentElementInstanceKey `json:"parentElementInstanceKey,omitempty"`

	// ParentProcessInstanceKey The parent process instance key.
	ParentProcessInstanceKey *ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey `json:"parentProcessInstanceKey,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey *ProcessDefinitionStatisticsFilter_ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// StartDate The start date.
	StartDate *DateTimeFilterProperty `json:"startDate,omitempty"`

	// State The process instance state.
	State *ProcessInstanceStateFilterProperty `json:"state,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// Variables The process instance variables.
	Variables *[]VariableValueFilterProperty `json:"variables,omitempty"`
}

// ProcessDefinitionStatisticsFilter_ParentElementInstanceKey The parent element instance key.
type ProcessDefinitionStatisticsFilter_ParentElementInstanceKey struct {
	union json.RawMessage
}

// ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey The parent process instance key.
type ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey struct {
	union json.RawMessage
}

// ProcessDefinitionStatisticsFilter_ProcessInstanceKey The key of this process instance.
type ProcessDefinitionStatisticsFilter_ProcessInstanceKey struct {
	union json.RawMessage
}

// ProcessElementStatisticsResult Process element statistics response.
type ProcessElementStatisticsResult struct {
	// Active The total number of active instances of the element.
	Active *int `json:"active,omitempty"`

	// Canceled The total number of canceled instances of the element.
	Canceled *int `json:"canceled,omitempty"`

	// Completed The total number of completed instances of the element.
	Completed *int `json:"completed,omitempty"`

	// ElementId The element ID for which the results are aggregated.
	ElementId *ElementId `json:"elementId,omitempty"`

	// Incidents The total number of incidents for the element.
	Incidents *int `json:"incidents,omitempty"`
}

// ProcessInstanceCallHierarchyEntry defines model for ProcessInstanceCallHierarchyEntry.
type ProcessInstanceCallHierarchyEntry struct {
	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessDefinitionName The name of the process definition (fall backs to the process definition ID if not available).
	ProcessDefinitionName string `json:"processDefinitionName"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`
}

// ProcessInstanceCancellationBatchOperationRequest The process instance filter that defines which process instances should be canceled.
type ProcessInstanceCancellationBatchOperationRequest struct {
	// Filter Process instance search filter.
	Filter ProcessInstanceFilter `json:"filter"`
}

// ProcessInstanceCreationInstruction Instructions for creating a process instance. The process definition can be specified
// either by ID or by key.
type ProcessInstanceCreationInstruction struct {
	union json.RawMessage
}

// ProcessInstanceCreationInstructionById defines model for ProcessInstanceCreationInstructionById.
type ProcessInstanceCreationInstructionById struct {
	// AwaitCompletion Wait for the process instance to complete. If the process instance completion does
	// not occur within the requestTimeout, the request will be closed. This can lead to a 504
	// response status. Disabled by default.
	AwaitCompletion *bool `json:"awaitCompletion,omitempty"`

	// FetchVariables List of variables by name to be included in the response when awaitCompletion is set to true.
	// If empty, all visible variables in the root scope will be returned.
	FetchVariables *[]string `json:"fetchVariables,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`

	// ProcessDefinitionId The BPMN process ID of the process definition to start an instance of.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionVersion The version of the process. By default, the latest version of the process is used.
	ProcessDefinitionVersion *int32 `json:"processDefinitionVersion,omitempty"`

	// RequestTimeout Timeout (in ms) the request waits for the process to complete. By default or
	// when set to 0, the generic request timeout configured in the cluster is applied.
	RequestTimeout *int `json:"requestTimeout,omitempty"`

	// RuntimeInstructions Runtime instructions (alpha). List of instructions that affect the runtime behavior of
	// the process instance. Refer to specific instruction types for more details.
	//
	// This parameter is an alpha feature and may be subject to change
	// in future releases.
	RuntimeInstructions *[]ProcessInstanceCreationInstructionById_RuntimeInstructions_Item `json:"runtimeInstructions,omitempty"`

	// StartInstructions List of start instructions. By default, the process instance will start at
	// the start event. If provided, the process instance will apply start instructions
	// after it has been created.
	StartInstructions *[]ProcessInstanceCreationStartInstruction `json:"startInstructions,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables JSON object that will instantiate the variables for the root variable scope
	// of the process instance.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// ProcessInstanceCreationInstructionById_RuntimeInstructions_Item defines model for ProcessInstanceCreationInstructionById.runtimeInstructions.Item.
type ProcessInstanceCreationInstructionById_RuntimeInstructions_Item struct {
	union json.RawMessage
}

// ProcessInstanceCreationInstructionByKey defines model for ProcessInstanceCreationInstructionByKey.
type ProcessInstanceCreationInstructionByKey struct {
	// AwaitCompletion Wait for the process instance to complete. If the process instance completion does
	// not occur within the requestTimeout, the request will be closed. This can lead to a 504
	// response status. Disabled by default.
	AwaitCompletion *bool `json:"awaitCompletion,omitempty"`

	// FetchVariables List of variables by name to be included in the response when awaitCompletion is set to true.
	// If empty, all visible variables in the root scope will be returned.
	FetchVariables *[]string `json:"fetchVariables,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`

	// ProcessDefinitionKey The unique key identifying the process definition, for example, returned for a process in the
	// deploy resources endpoint.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// RequestTimeout Timeout (in ms) the request waits for the process to complete. By default or
	// when set to 0, the generic request timeout configured in the cluster is applied.
	RequestTimeout *int `json:"requestTimeout,omitempty"`

	// RuntimeInstructions Runtime instructions (alpha). List of instructions that affect the runtime behavior of
	// the process instance. Refer to specific instruction types for more details.
	//
	// This parameter is an alpha feature and may be subject to change
	// in future releases.
	RuntimeInstructions *[]ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item `json:"runtimeInstructions,omitempty"`

	// StartInstructions List of start instructions. By default, the process instance will start at
	// the start event. If provided, the process instance will apply start instructions
	// after it has been created.
	StartInstructions *[]ProcessInstanceCreationStartInstruction `json:"startInstructions,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables JSON object that will instantiate the variables for the root variable scope
	// of the process instance.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item defines model for ProcessInstanceCreationInstructionByKey.runtimeInstructions.Item.
type ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item struct {
	union json.RawMessage
}

// ProcessInstanceCreationRuntimeInstruction Base type for all runtime instructions.
type ProcessInstanceCreationRuntimeInstruction struct {
	// Type The type of the runtime instruction. For now, only TERMINATE_PROCESS_INSTANCE is supported.
	Type RuntimeInstructionType `json:"type"`
}

// ProcessInstanceCreationStartInstruction defines model for ProcessInstanceCreationStartInstruction.
type ProcessInstanceCreationStartInstruction struct {
	// ElementId Future extensions might include:
	//   - different types of start instructions
	//   - ability to set local variables for different flow scopes
	//
	// For now, however, the start instruction is implicitly a "startBeforeElement" instruction
	ElementId ElementId `json:"elementId"`
}

// ProcessInstanceCreationTerminateInstruction defines model for ProcessInstanceCreationTerminateInstruction.
type ProcessInstanceCreationTerminateInstruction struct {
	// AfterElementId The ID of the element that, once completed or terminated, will cause the process to be terminated.
	AfterElementId ElementId `json:"afterElementId"`

	// Type The type of the runtime instruction. For now, only TERMINATE_PROCESS_INSTANCE is supported.
	Type RuntimeInstructionType `json:"type"`
}

// ProcessInstanceElementStatisticsQueryResult Process instance element statistics query response.
type ProcessInstanceElementStatisticsQueryResult struct {
	// Items The element statistics.
	Items *[]ProcessElementStatisticsResult `json:"items,omitempty"`
}

// ProcessInstanceFilter defines model for ProcessInstanceFilter.
type ProcessInstanceFilter struct {
	// Or Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
	//
	// Top-level fields and the `$or` clause are combined using AND logic â€” meaning: (top-level filters) AND (any of the `$or` filters) must match.
	// <br>
	// <em>Example:</em>
	//
	// ```json
	// {
	//   "state": "ACTIVE",
	//   "tenantId": 123,
	//   "$or": [
	//     { "processDefinitionId": "process_v1" },
	//     { "processDefinitionId": "process_v2", "hasIncident": true }
	//   ]
	// }
	// ```
	// This matches process instances that:
	//
	// <ul style="padding-left: 20px; margin-left: 20px;">
	//   <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>
	//   <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>
	//   <li style="list-style-type: disc;">and match either:
	//     <ul style="padding-left: 20px; margin-left: 20px;">
	//       <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>
	//       <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>
	//     </ul>
	//   </li>
	// </ul>
	// <br>
	// <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.
	Or *[]ProcessInstanceFilterFields `json:"$or,omitempty"`

	// BatchOperationId The batch operation ID.
	BatchOperationId *StringFilterProperty `json:"batchOperationId,omitempty"`

	// ElementId The element ID associated with the process instance.
	ElementId *StringFilterProperty `json:"elementId,omitempty"`

	// ElementInstanceState The state of the element instances associated with the process instance.
	ElementInstanceState *ElementInstanceStateFilterProperty `json:"elementInstanceState,omitempty"`

	// EndDate The end date.
	EndDate *DateTimeFilterProperty `json:"endDate,omitempty"`

	// ErrorMessage The error message related to the process.
	ErrorMessage *StringFilterProperty `json:"errorMessage,omitempty"`

	// HasElementInstanceIncident Whether the element instance has an incident or not.
	HasElementInstanceIncident *bool `json:"hasElementInstanceIncident,omitempty"`

	// HasIncident Whether this process instance has a related incident or not.
	HasIncident *bool `json:"hasIncident,omitempty"`

	// HasRetriesLeft Whether the process has failed jobs with retries left.
	HasRetriesLeft *bool `json:"hasRetriesLeft,omitempty"`

	// IncidentErrorHashCode The incident error hash code, associated with this process.
	IncidentErrorHashCode *IntegerFilterProperty `json:"incidentErrorHashCode,omitempty"`

	// ParentElementInstanceKey The parent element instance key.
	ParentElementInstanceKey *ProcessInstanceFilter_ParentElementInstanceKey `json:"parentElementInstanceKey,omitempty"`

	// ParentProcessInstanceKey The parent process instance key.
	ParentProcessInstanceKey *ProcessInstanceFilter_ParentProcessInstanceKey `json:"parentProcessInstanceKey,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey *ProcessInstanceFilter_ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// StartDate The start date.
	StartDate *DateTimeFilterProperty `json:"startDate,omitempty"`

	// State The process instance state.
	State *ProcessInstanceStateFilterProperty `json:"state,omitempty"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags *TagSet `json:"tags,omitempty"`

	// TenantId The tenant ID.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// Variables The process instance variables.
	Variables *[]VariableValueFilterProperty `json:"variables,omitempty"`
}

// ProcessInstanceFilter_ParentElementInstanceKey The parent element instance key.
type ProcessInstanceFilter_ParentElementInstanceKey struct {
	union json.RawMessage
}

// ProcessInstanceFilter_ParentProcessInstanceKey The parent process instance key.
type ProcessInstanceFilter_ParentProcessInstanceKey struct {
	union json.RawMessage
}

// ProcessInstanceFilter_ProcessInstanceKey The key of this process instance.
type ProcessInstanceFilter_ProcessInstanceKey struct {
	union json.RawMessage
}

// ProcessInstanceFilterFields Base process instance search filter.
type ProcessInstanceFilterFields = BaseProcessInstanceFilterFields

// ProcessInstanceIncidentResolutionBatchOperationRequest The process instance filter that defines which process instances should have their incidents resolved.
type ProcessInstanceIncidentResolutionBatchOperationRequest struct {
	// Filter Process instance search filter.
	Filter ProcessInstanceFilter `json:"filter"`
}

// ProcessInstanceIncidentSearchQuery defines model for ProcessInstanceIncidentSearchQuery.
type ProcessInstanceIncidentSearchQuery = SearchQueryRequest

// ProcessInstanceKey Zeebe Engine resource key (Java long serialized as string)
type ProcessInstanceKey = LongKey

// ProcessInstanceMigrationBatchOperationPlan The migration instructions describe how to migrate a process instance from one process definition to another.
type ProcessInstanceMigrationBatchOperationPlan struct {
	// MappingInstructions Element mappings from the source process instance to the target process instance.
	MappingInstructions []MigrateProcessInstanceMappingInstruction `json:"mappingInstructions"`

	// TargetProcessDefinitionKey The key of process definition to migrate the process instance to.
	TargetProcessDefinitionKey ProcessDefinitionKey `json:"targetProcessDefinitionKey"`
}

// ProcessInstanceMigrationBatchOperationRequest defines model for ProcessInstanceMigrationBatchOperationRequest.
type ProcessInstanceMigrationBatchOperationRequest struct {
	// Filter Process instance search filter.
	Filter ProcessInstanceFilter `json:"filter"`

	// MigrationPlan The migration instructions describe how to migrate a process instance from one process definition to another.
	MigrationPlan ProcessInstanceMigrationBatchOperationPlan `json:"migrationPlan"`
}

// ProcessInstanceMigrationInstruction The migration instructions describe how to migrate a process instance from one process definition to another.
type ProcessInstanceMigrationInstruction struct {
	// MappingInstructions Element mappings from the source process instance to the target process instance.
	MappingInstructions []MigrateProcessInstanceMappingInstruction `json:"mappingInstructions"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`

	// TargetProcessDefinitionKey The key of process definition to migrate the process instance to.
	TargetProcessDefinitionKey ProcessDefinitionKey `json:"targetProcessDefinitionKey"`
}

// ProcessInstanceModificationActivateInstruction Instructions describing an element that should be activated.
type ProcessInstanceModificationActivateInstruction struct {
	// AncestorElementInstanceKey The key of the ancestor scope the element instance should be created in.
	// Set to -1 to create the new element instance within an existing element instance of the
	// flow scope.
	AncestorElementInstanceKey *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey `json:"ancestorElementInstanceKey,omitempty"`

	// ElementId The ID of the element that should be activated.
	ElementId ElementId `json:"elementId"`

	// VariableInstructions Instructions describing which variables should be created.
	VariableInstructions *[]ModifyProcessInstanceVariableInstruction `json:"variableInstructions,omitempty"`
}

// ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0 defines model for .
type ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0 = string

// ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey The key of the ancestor scope the element instance should be created in.
// Set to -1 to create the new element instance within an existing element instance of the
// flow scope.
type ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey struct {
	union json.RawMessage
}

// ProcessInstanceModificationBatchOperationRequest The process instance filter to define on which process instances tokens should be moved,
// as well as mapping instructions which active element instances should be terminated and which
// new element instances should be activated
type ProcessInstanceModificationBatchOperationRequest struct {
	// Filter Process instance search filter.
	Filter ProcessInstanceFilter `json:"filter"`

	// MoveInstructions Instructions describing which elements should be activated in which scopes and which variables should be created.
	MoveInstructions []ProcessInstanceModificationMoveBatchOperationInstruction `json:"moveInstructions"`
}

// ProcessInstanceModificationInstruction defines model for ProcessInstanceModificationInstruction.
type ProcessInstanceModificationInstruction struct {
	// ActivateInstructions Instructions describing which elements should be activated in which scopes and which variables should be created.
	ActivateInstructions *[]ProcessInstanceModificationActivateInstruction `json:"activateInstructions,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`

	// TerminateInstructions Instructions describing which elements should be terminated.
	TerminateInstructions *[]ProcessInstanceModificationTerminateInstruction `json:"terminateInstructions,omitempty"`
}

// ProcessInstanceModificationMoveBatchOperationInstruction Instructions describing a move operation. This instruction will terminate all active elementInstance
// at sourceElementId and activate a new element instance for each terminated one at targetElementId.
type ProcessInstanceModificationMoveBatchOperationInstruction struct {
	// SourceElementId The ID of the element that should be terminated.
	SourceElementId ElementId `json:"sourceElementId"`

	// TargetElementId The ID of the element that should be activated.
	TargetElementId ElementId `json:"targetElementId"`
}

// ProcessInstanceModificationTerminateInstruction Instructions describing which elements should be terminated.
type ProcessInstanceModificationTerminateInstruction struct {
	// ElementInstanceKey The ID of the element that should be terminated.
	ElementInstanceKey ElementInstanceKey `json:"elementInstanceKey"`
}

// ProcessInstanceResult Process instance search response item.
type ProcessInstanceResult struct {
	// EndDate The end date.
	EndDate *time.Time `json:"endDate,omitempty"`

	// HasIncident Whether this process instance has a related incident or not.
	HasIncident bool `json:"hasIncident"`

	// ParentElementInstanceKey The parent element instance key.
	ParentElementInstanceKey *ElementInstanceKey `json:"parentElementInstanceKey,omitempty"`

	// ParentProcessInstanceKey The parent process instance key.
	ParentProcessInstanceKey *ProcessInstanceKey `json:"parentProcessInstanceKey,omitempty"`

	// ProcessDefinitionId Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
	ProcessDefinitionId ProcessDefinitionId `json:"processDefinitionId"`

	// ProcessDefinitionKey The process definition key.
	ProcessDefinitionKey ProcessDefinitionKey `json:"processDefinitionKey"`

	// ProcessDefinitionName The process definition name.
	ProcessDefinitionName string `json:"processDefinitionName"`

	// ProcessDefinitionVersion The process definition version.
	ProcessDefinitionVersion int32 `json:"processDefinitionVersion"`

	// ProcessDefinitionVersionTag The process definition version tag.
	ProcessDefinitionVersionTag *string `json:"processDefinitionVersionTag,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey ProcessInstanceKey `json:"processInstanceKey"`

	// StartDate The start date.
	StartDate time.Time `json:"startDate"`

	// State Process instance states
	State ProcessInstanceStateEnum `json:"state"`

	// Tags List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
	Tags TagSet `json:"tags"`

	// TenantId The unique identifier of the tenant.
	TenantId TenantId `json:"tenantId"`
}

// ProcessInstanceSearchQuery defines model for ProcessInstanceSearchQuery.
type ProcessInstanceSearchQuery = SearchQueryRequest

// ProcessInstanceSearchQueryResult defines model for ProcessInstanceSearchQueryResult.
type ProcessInstanceSearchQueryResult = SearchQueryResponse

// ProcessInstanceSearchQuerySortRequest defines model for ProcessInstanceSearchQuerySortRequest.
type ProcessInstanceSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field ProcessInstanceSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// ProcessInstanceSearchQuerySortRequestField The field to sort by.
type ProcessInstanceSearchQuerySortRequestField string

// ProcessInstanceSequenceFlowResult Process instance sequence flow result.
type ProcessInstanceSequenceFlowResult struct {
	// ElementId The element ID for this sequence flow, as provided in the BPMN process.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ProcessDefinitionId The process definition ID.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The process definition key.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The key of this process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// SequenceFlowId The sequence flow ID.
	SequenceFlowId *string `json:"sequenceFlowId,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// ProcessInstanceSequenceFlowsQueryResult Process instance sequence flows query response.
type ProcessInstanceSequenceFlowsQueryResult struct {
	// Items The sequence flows.
	Items *[]ProcessInstanceSequenceFlowResult `json:"items,omitempty"`
}

// ProcessInstanceStateEnum Process instance states
type ProcessInstanceStateEnum = interface{}

// ProcessInstanceStateFilterProperty ProcessInstanceStateEnum property with full advanced search capabilities.
type ProcessInstanceStateFilterProperty struct {
	union json.RawMessage
}

// ProcessInstanceStateFilterProperty0 Process instance states
type ProcessInstanceStateFilterProperty0 = ProcessInstanceStateEnum

// QueryOperation A pure read operation. May return a different state with each call, but causes no effect with each call.
type QueryOperation struct {
	// Idempotent Idempotent operations cause at-most one effect regardless of how many times that are called.
	Idempotent *bool              `json:"idempotent,omitempty"`
	Kind       QueryOperationKind `json:"kind"`

	// Safe Safe operations do not mutate the state of the Camunda engine.
	Safe *bool `json:"safe,omitempty"`
}

// QueryOperationKind defines model for QueryOperation.Kind.
type QueryOperationKind string

// ResourceKey The system-assigned key for this resource.
type ResourceKey struct {
	union json.RawMessage
}

// ResourceResult defines model for ResourceResult.
type ResourceResult struct {
	// ResourceId The resource ID of this resource.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceKey The unique key of this resource.
	ResourceKey *ResourceKey `json:"resourceKey,omitempty"`

	// ResourceName The resource name from which this resource was parsed.
	ResourceName *string `json:"resourceName,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Version The assigned resource version.
	Version *int32 `json:"version,omitempty"`

	// VersionTag The version tag of this resource.
	VersionTag *string `json:"versionTag,omitempty"`
}

// ResourceTypeEnum The type of resource to add/remove permissions to/from.
type ResourceTypeEnum = interface{}

// RoleClientResult defines model for RoleClientResult.
type RoleClientResult struct {
	// ClientId The ID of the client.
	ClientId *string `json:"clientId,omitempty"`
}

// RoleClientSearchQueryRequest defines model for RoleClientSearchQueryRequest.
type RoleClientSearchQueryRequest = SearchQueryRequest

// RoleClientSearchQuerySortRequest defines model for RoleClientSearchQuerySortRequest.
type RoleClientSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field RoleClientSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// RoleClientSearchQuerySortRequestField The field to sort by.
type RoleClientSearchQuerySortRequestField string

// RoleClientSearchResult defines model for RoleClientSearchResult.
type RoleClientSearchResult = SearchQueryResponse

// RoleCreateRequest defines model for RoleCreateRequest.
type RoleCreateRequest struct {
	// Description The description of the new role.
	Description *string `json:"description,omitempty"`

	// Name The display name of the new role.
	Name string `json:"name"`

	// RoleId The ID of the new role.
	RoleId string `json:"roleId"`
}

// RoleCreateResult defines model for RoleCreateResult.
type RoleCreateResult struct {
	// Description The description of the created role.
	Description *string `json:"description,omitempty"`

	// Name The display name of the created role.
	Name *string `json:"name,omitempty"`

	// RoleId The ID of the created role.
	RoleId *string `json:"roleId,omitempty"`
}

// RoleFilter Role filter request
type RoleFilter struct {
	// Name The role name search filters.
	Name *string `json:"name,omitempty"`

	// RoleId The role ID search filters.
	RoleId *string `json:"roleId,omitempty"`
}

// RoleGroupResult defines model for RoleGroupResult.
type RoleGroupResult struct {
	// GroupId The id of the group.
	GroupId *string `json:"groupId,omitempty"`
}

// RoleGroupSearchQueryRequest defines model for RoleGroupSearchQueryRequest.
type RoleGroupSearchQueryRequest = SearchQueryRequest

// RoleGroupSearchQuerySortRequest defines model for RoleGroupSearchQuerySortRequest.
type RoleGroupSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field RoleGroupSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// RoleGroupSearchQuerySortRequestField The field to sort by.
type RoleGroupSearchQuerySortRequestField string

// RoleGroupSearchResult defines model for RoleGroupSearchResult.
type RoleGroupSearchResult = SearchQueryResponse

// RoleResult Role search response item.
type RoleResult struct {
	// Description The description of the role.
	Description *string `json:"description,omitempty"`

	// Name The role name.
	Name *string `json:"name,omitempty"`

	// RoleId The role id.
	RoleId *string `json:"roleId,omitempty"`
}

// RoleSearchQueryRequest defines model for RoleSearchQueryRequest.
type RoleSearchQueryRequest = SearchQueryRequest

// RoleSearchQueryResult defines model for RoleSearchQueryResult.
type RoleSearchQueryResult = SearchQueryResponse

// RoleSearchQuerySortRequest defines model for RoleSearchQuerySortRequest.
type RoleSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field RoleSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// RoleSearchQuerySortRequestField The field to sort by.
type RoleSearchQuerySortRequestField string

// RoleUpdateRequest defines model for RoleUpdateRequest.
type RoleUpdateRequest struct {
	// Description The description of the new role.
	Description string `json:"description"`

	// Name The display name of the new role.
	Name string `json:"name"`
}

// RoleUpdateResult defines model for RoleUpdateResult.
type RoleUpdateResult struct {
	// Description The description of the updated role.
	Description *string `json:"description,omitempty"`

	// Name The display name of the updated role.
	Name *string `json:"name,omitempty"`

	// RoleId The ID of the updated role.
	RoleId *string `json:"roleId,omitempty"`
}

// RoleUserResult defines model for RoleUserResult.
type RoleUserResult struct {
	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// RoleUserSearchQueryRequest defines model for RoleUserSearchQueryRequest.
type RoleUserSearchQueryRequest = SearchQueryRequest

// RoleUserSearchQuerySortRequest defines model for RoleUserSearchQuerySortRequest.
type RoleUserSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field RoleUserSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// RoleUserSearchQuerySortRequestField The field to sort by.
type RoleUserSearchQuerySortRequestField string

// RoleUserSearchResult defines model for RoleUserSearchResult.
type RoleUserSearchResult = SearchQueryResponse

// RuntimeInstructionType The type of the runtime instruction. For now, only TERMINATE_PROCESS_INSTANCE is supported.
type RuntimeInstructionType string

// ScopeKey Zeebe Engine resource key (Java long serialized as string)
type ScopeKey = LongKey

// SearchQueryPageRequest Pagination criteria. Can use offset-based pagination (from/limit) OR cursor-based pagination (after/before + limit), but not both.
type SearchQueryPageRequest struct {
	union json.RawMessage
}

// SearchQueryPageResponse Pagination information about the search results.
type SearchQueryPageResponse struct {
	// EndCursor The end cursor in a search query result set.
	EndCursor *EndCursor `json:"endCursor,omitempty"`

	// HasMoreTotalItems Indicates if more results exist beyond the reported totalItems value. Due to system limitations, the totalItems value can be capped.
	HasMoreTotalItems *bool `json:"hasMoreTotalItems,omitempty"`

	// StartCursor The start cursor in a search query result set.
	StartCursor *StartCursor `json:"startCursor,omitempty"`

	// TotalItems Total items matching the criteria.
	TotalItems int `json:"totalItems"`
}

// SearchQueryRequest defines model for SearchQueryRequest.
type SearchQueryRequest struct {
	// Page Pagination criteria.
	Page *SearchQueryPageRequest `json:"page,omitempty"`
}

// SearchQueryResponse defines model for SearchQueryResponse.
type SearchQueryResponse struct {
	// Page Pagination information about the search results.
	Page SearchQueryPageResponse `json:"page"`
}

// SetVariableRequest defines model for SetVariableRequest.
type SetVariableRequest struct {
	// Local If set to true, the variables are merged strictly into the local scope (as specified by the `elementInstanceKey`).
	// Otherwise, the variables are propagated to upper scopes and set at the outermost one.
	//
	// Letâ€™s consider the following example:
	//
	// There are two scopes '1' and '2'.
	// Scope '1' is the parent scope of '2'. The effective variables of the scopes are:
	// 1 => { "foo" : 2 }
	// 2 => { "bar" : 1 }
	//
	// An update request with elementInstanceKey as '2', variables { "foo" : 5 }, and local set
	// to true leaves scope '1' unchanged and adjusts scope '2' to { "bar" : 1, "foo" 5 }.
	//
	// By default, with local set to false, scope '1' will be { "foo": 5 }
	// and scope '2' will be { "bar" : 1 }.
	Local *bool `json:"local,omitempty"`

	// OperationReference A reference key chosen by the user that will be part of all records resulting from this operation.
	// Must be > 0 if provided.
	OperationReference *OperationReference `json:"operationReference,omitempty"`

	// Variables JSON object representing the variables to set in the elementâ€™s scope.
	Variables map[string]interface{} `json:"variables"`
}

// SignalBroadcastRequest defines model for SignalBroadcastRequest.
type SignalBroadcastRequest struct {
	// SignalName The name of the signal to broadcast.
	SignalName string `json:"signalName"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Variables The signal variables as a JSON object.
	Variables *map[string]interface{} `json:"variables,omitempty"`
}

// SignalBroadcastResult defines model for SignalBroadcastResult.
type SignalBroadcastResult struct {
	// SignalKey The unique ID of the signal that was broadcast.
	SignalKey SignalKey `json:"signalKey"`

	// TenantId The unique identifier of the tenant.
	TenantId TenantId `json:"tenantId"`
}

// SignalKey Zeebe Engine resource key (Java long serialized as string)
type SignalKey = LongKey

// SortOrderEnum The order in which to sort the related field.
type SortOrderEnum string

// StartCursor The start cursor in a search query result set.
type StartCursor = interface{}

// StringFilterProperty String property with full advanced search capabilities.
type StringFilterProperty struct {
	union json.RawMessage
}

// StringFilterProperty0 Matches the value exactly.
type StringFilterProperty0 = string

// Tag A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
type Tag = string

// TagSet List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
type TagSet = []Tag

// TenantClientResult defines model for TenantClientResult.
type TenantClientResult struct {
	// ClientId The ID of the client.
	ClientId *string `json:"clientId,omitempty"`
}

// TenantClientSearchQueryRequest defines model for TenantClientSearchQueryRequest.
type TenantClientSearchQueryRequest = SearchQueryRequest

// TenantClientSearchQuerySortRequest defines model for TenantClientSearchQuerySortRequest.
type TenantClientSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field TenantClientSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// TenantClientSearchQuerySortRequestField The field to sort by.
type TenantClientSearchQuerySortRequestField string

// TenantClientSearchResult defines model for TenantClientSearchResult.
type TenantClientSearchResult = SearchQueryResponse

// TenantCreateRequest defines model for TenantCreateRequest.
type TenantCreateRequest struct {
	// Description The description of the tenant.
	Description *string `json:"description,omitempty"`

	// Name The name of the tenant.
	Name string `json:"name"`

	// TenantId The unique ID for the tenant. Must be 255 characters or less. Can contain letters, numbers, [`_`, `-`, `+`, `.`, `@`].
	TenantId string `json:"tenantId"`
}

// TenantCreateResult defines model for TenantCreateResult.
type TenantCreateResult struct {
	// Description The description of the tenant.
	Description *string `json:"description,omitempty"`

	// Name The name of the tenant.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// TenantFilter Tenant filter request
type TenantFilter struct {
	// Name The name of the tenant.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// TenantGroupResult defines model for TenantGroupResult.
type TenantGroupResult struct {
	// GroupId The groupId of the group.
	GroupId *string `json:"groupId,omitempty"`
}

// TenantGroupSearchQueryRequest defines model for TenantGroupSearchQueryRequest.
type TenantGroupSearchQueryRequest = SearchQueryRequest

// TenantGroupSearchQuerySortRequest defines model for TenantGroupSearchQuerySortRequest.
type TenantGroupSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field TenantGroupSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// TenantGroupSearchQuerySortRequestField The field to sort by.
type TenantGroupSearchQuerySortRequestField string

// TenantGroupSearchResult defines model for TenantGroupSearchResult.
type TenantGroupSearchResult = SearchQueryResponse

// TenantId The unique identifier of the tenant.
type TenantId = string

// TenantResult Tenant search response item.
type TenantResult struct {
	// Description The tenant description.
	Description *string `json:"description,omitempty"`

	// Name The tenant name.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// TenantSearchQueryRequest defines model for TenantSearchQueryRequest.
type TenantSearchQueryRequest = SearchQueryRequest

// TenantSearchQueryResult defines model for TenantSearchQueryResult.
type TenantSearchQueryResult = SearchQueryResponse

// TenantSearchQuerySortRequest defines model for TenantSearchQuerySortRequest.
type TenantSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field TenantSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// TenantSearchQuerySortRequestField The field to sort by.
type TenantSearchQuerySortRequestField string

// TenantUpdateRequest defines model for TenantUpdateRequest.
type TenantUpdateRequest struct {
	// Description The new description of the tenant.
	Description string `json:"description"`

	// Name The new name of the tenant.
	Name string `json:"name"`
}

// TenantUpdateResult defines model for TenantUpdateResult.
type TenantUpdateResult struct {
	// Description The description of the tenant.
	Description *string `json:"description,omitempty"`

	// Name The name of the tenant.
	Name *string `json:"name,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`
}

// TenantUserResult defines model for TenantUserResult.
type TenantUserResult struct {
	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// TenantUserSearchQueryRequest defines model for TenantUserSearchQueryRequest.
type TenantUserSearchQueryRequest = SearchQueryRequest

// TenantUserSearchQuerySortRequest defines model for TenantUserSearchQuerySortRequest.
type TenantUserSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field TenantUserSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// TenantUserSearchQuerySortRequestField The field to sort by.
type TenantUserSearchQuerySortRequestField string

// TenantUserSearchResult defines model for TenantUserSearchResult.
type TenantUserSearchResult = SearchQueryResponse

// TopologyResponse The response of a topology request.
type TopologyResponse struct {
	// Brokers A list of brokers that are part of this cluster.
	Brokers []BrokerInfo `json:"brokers"`

	// ClusterSize The number of brokers in the cluster.
	ClusterSize int32 `json:"clusterSize"`

	// GatewayVersion The version of the Zeebe Gateway.
	GatewayVersion string `json:"gatewayVersion"`

	// LastCompletedChangeId ID of the last completed change
	LastCompletedChangeId string `json:"lastCompletedChangeId"`

	// PartitionsCount The number of partitions are spread across the cluster.
	PartitionsCount int32 `json:"partitionsCount"`

	// ReplicationFactor The configured replication factor for this cluster.
	ReplicationFactor int32 `json:"replicationFactor"`
}

// UpdateOperation Updates a resource.
type UpdateOperation struct {
	// Idempotent Idempotent operations cause at-most one effect regardless of how many times that are called.
	Idempotent *bool               `json:"idempotent,omitempty"`
	Kind       UpdateOperationKind `json:"kind"`

	// Safe Safe operations do not mutate the state of the Camunda engine.
	Safe *bool `json:"safe,omitempty"`
}

// UpdateOperationKind defines model for UpdateOperation.Kind.
type UpdateOperationKind string

// UsageMetricsResponse defines model for UsageMetricsResponse.
type UsageMetricsResponse = UsageMetricsResponseItem

// UsageMetricsResponseItem defines model for UsageMetricsResponseItem.
type UsageMetricsResponseItem struct {
	// Assignees The amount of unique active task users.
	Assignees *int `json:"assignees,omitempty"`

	// DecisionInstances The amount of executed decision instances.
	DecisionInstances *int `json:"decisionInstances,omitempty"`

	// ProcessInstances The amount of created root process instances.
	ProcessInstances *int `json:"processInstances,omitempty"`
}

// UserCreateResult defines model for UserCreateResult.
type UserCreateResult struct {
	// Email The email of the user.
	Email *string `json:"email,omitempty"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// UserFilter User search filter.
type UserFilter struct {
	// Email The email of the user.
	Email *StringFilterProperty `json:"email,omitempty"`

	// Name The name of the user.
	Name *StringFilterProperty `json:"name,omitempty"`

	// Username The username of the user.
	Username *StringFilterProperty `json:"username,omitempty"`
}

// UserRequest defines model for UserRequest.
type UserRequest struct {
	// Email The email of the user.
	Email string `json:"email"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// Password The password of the user.
	Password string `json:"password"`

	// Username The username of the user.
	Username string `json:"username"`
}

// UserResult defines model for UserResult.
type UserResult struct {
	// Email The email of the user.
	Email *string `json:"email,omitempty"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// UserSearchQueryRequest defines model for UserSearchQueryRequest.
type UserSearchQueryRequest = SearchQueryRequest

// UserSearchQuerySortRequest defines model for UserSearchQuerySortRequest.
type UserSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field UserSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// UserSearchQuerySortRequestField The field to sort by.
type UserSearchQuerySortRequestField string

// UserSearchResult defines model for UserSearchResult.
type UserSearchResult = SearchQueryResponse

// UserTaskAssignmentRequest defines model for UserTaskAssignmentRequest.
type UserTaskAssignmentRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "assign".
	Action nullable.Nullable[string] `json:"action,omitempty"`

	// AllowOverride By default, the task is reassigned if it was already assigned. Set this to `false` to return an error in such cases. The task must then first be unassigned to be assigned again. Use this when you have users picking from group task queues to prevent race conditions.
	AllowOverride nullable.Nullable[bool] `json:"allowOverride,omitempty"`

	// Assignee The assignee for the user task. The assignee must not be empty or `null`.
	Assignee *string `json:"assignee,omitempty"`
}

// UserTaskCompletionRequest defines model for UserTaskCompletionRequest.
type UserTaskCompletionRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "complete".
	Action nullable.Nullable[string] `json:"action,omitempty"`

	// Variables The variables to complete the user task with.
	Variables nullable.Nullable[map[string]interface{}] `json:"variables,omitempty"`
}

// UserTaskFilter User task filter request.
type UserTaskFilter struct {
	// Assignee The assignee of the user task.
	Assignee *StringFilterProperty `json:"assignee,omitempty"`

	// CandidateGroup The candidate group for this user task.
	CandidateGroup *StringFilterProperty `json:"candidateGroup,omitempty"`

	// CandidateUser The candidate user for this user task.
	CandidateUser *StringFilterProperty `json:"candidateUser,omitempty"`

	// CompletionDate The user task completion date.
	CompletionDate *DateTimeFilterProperty `json:"completionDate,omitempty"`

	// CreationDate The user task creation date.
	CreationDate *DateTimeFilterProperty `json:"creationDate,omitempty"`

	// DueDate The user task due date.
	DueDate *DateTimeFilterProperty `json:"dueDate,omitempty"`

	// ElementId The element ID of the user task.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The key of the element instance.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// FollowUpDate The user task follow-up date.
	FollowUpDate *DateTimeFilterProperty `json:"followUpDate,omitempty"`

	// LocalVariables Local variables associated with the user task.
	LocalVariables *[]VariableValueFilterProperty `json:"localVariables,omitempty"`

	// Name The task name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.
	Name *string `json:"name,omitempty"`

	// Priority The priority of the user task.
	Priority *IntegerFilterProperty `json:"priority,omitempty"`

	// ProcessDefinitionId The ID of the process definition.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// ProcessInstanceVariables Process instance variables associated with the user task.
	ProcessInstanceVariables *[]VariableValueFilterProperty `json:"processInstanceVariables,omitempty"`

	// State The user task state.
	State *UserTaskStateFilterProperty `json:"state,omitempty"`

	// TenantId Tenant ID of this user task.
	TenantId *StringFilterProperty `json:"tenantId,omitempty"`

	// UserTaskKey The key for this user task.
	UserTaskKey *UserTaskKey `json:"userTaskKey,omitempty"`
}

// UserTaskKey Zeebe Engine resource key (Java long serialized as string)
type UserTaskKey = LongKey

// UserTaskProperties Contains properties of a user task.
type UserTaskProperties struct {
	// Action The action performed on the user task.
	Action *string `json:"action,omitempty"`

	// Assignee The user assigned to the task.
	Assignee nullable.Nullable[string] `json:"assignee,omitempty"`

	// CandidateGroups The groups eligible to claim the task.
	CandidateGroups *[]string `json:"candidateGroups,omitempty"`

	// CandidateUsers The users eligible to claim the task.
	CandidateUsers *[]string `json:"candidateUsers,omitempty"`

	// ChangedAttributes The attributes that were changed in the task.
	ChangedAttributes *[]string `json:"changedAttributes,omitempty"`

	// DueDate The due date of the user task in ISO 8601 format.
	DueDate nullable.Nullable[time.Time] `json:"dueDate,omitempty"`

	// FollowUpDate The follow-up date of the user task in ISO 8601 format.
	FollowUpDate nullable.Nullable[time.Time] `json:"followUpDate,omitempty"`

	// FormKey The key of the form associated with the user task.
	FormKey *FormKey `json:"formKey,omitempty"`

	// Priority The priority of the user task.
	Priority nullable.Nullable[int32] `json:"priority,omitempty"`

	// UserTaskKey The unique key identifying the user task.
	UserTaskKey nullable.Nullable[UserTaskKey] `json:"userTaskKey,omitempty"`
}

// UserTaskResult defines model for UserTaskResult.
type UserTaskResult struct {
	// Assignee The assignee of the user task.
	Assignee *string `json:"assignee,omitempty"`

	// CandidateGroups The candidate groups for this user task.
	CandidateGroups *[]string `json:"candidateGroups,omitempty"`

	// CandidateUsers The candidate users for this user task.
	CandidateUsers *[]string `json:"candidateUsers,omitempty"`

	// CompletionDate The completion date of a user task.
	CompletionDate *time.Time `json:"completionDate,omitempty"`

	// CreationDate The creation date of a user task.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// CustomHeaders Custom headers for the user task.
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// DueDate The due date of a user task.
	DueDate *time.Time `json:"dueDate,omitempty"`

	// ElementId The element ID of the user task.
	ElementId *ElementId `json:"elementId,omitempty"`

	// ElementInstanceKey The key of the element instance.
	ElementInstanceKey *ElementInstanceKey `json:"elementInstanceKey,omitempty"`

	// ExternalFormReference The external form reference.
	ExternalFormReference *string `json:"externalFormReference,omitempty"`

	// FollowUpDate The follow date of a user task.
	FollowUpDate *time.Time `json:"followUpDate,omitempty"`

	// FormKey The key of the form.
	FormKey *FormKey `json:"formKey,omitempty"`

	// Name The name for this user task.
	Name *string `json:"name,omitempty"`

	// Priority The priority of a user task. The higher the value the higher the priority.
	Priority *int `json:"priority,omitempty"`

	// ProcessDefinitionId The ID of the process definition.
	ProcessDefinitionId *ProcessDefinitionId `json:"processDefinitionId,omitempty"`

	// ProcessDefinitionKey The key of the process definition.
	ProcessDefinitionKey *ProcessDefinitionKey `json:"processDefinitionKey,omitempty"`

	// ProcessDefinitionVersion The version of the process definition.
	ProcessDefinitionVersion *int32 `json:"processDefinitionVersion,omitempty"`

	// ProcessInstanceKey The key of the process instance.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// ProcessName The name of the process definition.
	ProcessName *string `json:"processName,omitempty"`

	// State The state of the user task.
	State *UserTaskStateEnum `json:"state,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// UserTaskKey The key of the user task.
	UserTaskKey *UserTaskKey `json:"userTaskKey,omitempty"`
}

// UserTaskSearchQuery defines model for UserTaskSearchQuery.
type UserTaskSearchQuery = SearchQueryRequest

// UserTaskSearchQueryResult defines model for UserTaskSearchQueryResult.
type UserTaskSearchQueryResult = SearchQueryResponse

// UserTaskSearchQuerySortRequest defines model for UserTaskSearchQuerySortRequest.
type UserTaskSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field UserTaskSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// UserTaskSearchQuerySortRequestField The field to sort by.
type UserTaskSearchQuerySortRequestField string

// UserTaskStateEnum The state of the user task.
type UserTaskStateEnum string

// UserTaskStateFilterProperty UserTaskStateEnum property with full advanced search capabilities.
type UserTaskStateFilterProperty struct {
	union json.RawMessage
}

// UserTaskStateFilterProperty0 The state of the user task.
type UserTaskStateFilterProperty0 = UserTaskStateEnum

// UserTaskUpdateRequest defines model for UserTaskUpdateRequest.
type UserTaskUpdateRequest struct {
	// Action A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "update".
	Action nullable.Nullable[string] `json:"action,omitempty"`

	// Changeset JSON object with changed task attribute values.
	//
	// The following attributes can be adjusted with this endpoint, additional attributes
	// will be ignored:
	//
	// * `candidateGroups` - reset by providing an empty list
	// * `candidateUsers` - reset by providing an empty list
	// * `dueDate` - reset by providing an empty String
	// * `followUpDate` - reset by providing an empty String
	// * `priority` - minimum 0, maximum 100, default 50
	//
	// Providing any of those attributes with a `null` value or omitting it preserves
	// the persisted attribute's value.
	//
	// The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
	// This ensures correct event emission for assignee changes.
	Changeset nullable.Nullable[Changeset] `json:"changeset,omitempty"`
}

// UserTaskVariableFilter The user task variable search filters.
type UserTaskVariableFilter struct {
	// Name Name of the variable.
	Name *StringFilterProperty `json:"name,omitempty"`
}

// UserTaskVariableSearchQueryRequest defines model for UserTaskVariableSearchQueryRequest.
type UserTaskVariableSearchQueryRequest = SearchQueryRequest

// UserTaskVariableSearchQuerySortRequest defines model for UserTaskVariableSearchQuerySortRequest.
type UserTaskVariableSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field UserTaskVariableSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// UserTaskVariableSearchQuerySortRequestField The field to sort by.
type UserTaskVariableSearchQuerySortRequestField string

// UserUpdateRequest defines model for UserUpdateRequest.
type UserUpdateRequest struct {
	// Email The email of the user.
	Email *string `json:"email,omitempty"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// Password The password of the user. If blank, the password is unchanged.
	Password *string `json:"password,omitempty"`
}

// UserUpdateResult defines model for UserUpdateResult.
type UserUpdateResult struct {
	// Email The email of the user.
	Email *string `json:"email,omitempty"`

	// Name The name of the user.
	Name *string `json:"name,omitempty"`

	// Username The unique name of a user.
	Username *Username `json:"username,omitempty"`
}

// Username The unique name of a user.
type Username = interface{}

// VariableFilter Variable filter request.
type VariableFilter struct {
	// IsTruncated Whether the value is truncated or not.
	IsTruncated *bool `json:"isTruncated,omitempty"`

	// Name Name of the variable.
	Name *StringFilterProperty `json:"name,omitempty"`

	// ProcessInstanceKey The key of the process instance of this variable.
	ProcessInstanceKey *VariableFilter_ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// ScopeKey The key of the scope of this variable.
	ScopeKey *VariableFilter_ScopeKey `json:"scopeKey,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// Value The value of the variable.
	Value *StringFilterProperty `json:"value,omitempty"`

	// VariableKey The key for this variable.
	VariableKey *VariableFilter_VariableKey `json:"variableKey,omitempty"`
}

// VariableFilter_ProcessInstanceKey The key of the process instance of this variable.
type VariableFilter_ProcessInstanceKey struct {
	union json.RawMessage
}

// VariableFilter_ScopeKey The key of the scope of this variable.
type VariableFilter_ScopeKey struct {
	union json.RawMessage
}

// VariableFilter_VariableKey The key for this variable.
type VariableFilter_VariableKey struct {
	union json.RawMessage
}

// VariableKey Zeebe Engine resource key (Java long serialized as string)
type VariableKey = LongKey

// VariableResult Variable response item.
type VariableResult = VariableResultBase

// VariableResultBase Variable response item.
type VariableResultBase struct {
	// Name Name of this variable.
	Name *string `json:"name,omitempty"`

	// ProcessInstanceKey The key of the process instance of this variable.
	ProcessInstanceKey *ProcessInstanceKey `json:"processInstanceKey,omitempty"`

	// ScopeKey The key of the scope of this variable.
	ScopeKey *ScopeKey `json:"scopeKey,omitempty"`

	// TenantId The unique identifier of the tenant.
	TenantId *TenantId `json:"tenantId,omitempty"`

	// VariableKey The key for this variable.
	VariableKey *VariableKey `json:"variableKey,omitempty"`
}

// VariableSearchQuery defines model for VariableSearchQuery.
type VariableSearchQuery = SearchQueryRequest

// VariableSearchQueryResult defines model for VariableSearchQueryResult.
type VariableSearchQueryResult = SearchQueryResponse

// VariableSearchQuerySortRequest defines model for VariableSearchQuerySortRequest.
type VariableSearchQuerySortRequest struct {
	// Field The field to sort by.
	Field VariableSearchQuerySortRequestField `json:"field"`

	// Order The order in which to sort the related field.
	Order *SortOrderEnum `json:"order,omitempty"`
}

// VariableSearchQuerySortRequestField The field to sort by.
type VariableSearchQuerySortRequestField string

// VariableSearchResult Variable response item.
type VariableSearchResult = VariableResultBase

// VariableValueFilterProperty defines model for VariableValueFilterProperty.
type VariableValueFilterProperty struct {
	// Name Name of the variable.
	Name string `json:"name"`

	// Value The value of the variable.
	Value StringFilterProperty `json:"value"`
}

// Forbidden A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type Forbidden = ProblemDetail

// InternalServerError A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type InternalServerError = ProblemDetail

// InvalidData A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type InvalidData = ProblemDetail

// ServiceUnavailable A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type ServiceUnavailable = ProblemDetail

// Unauthorized A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
type Unauthorized = ProblemDetail

// CancelBatchOperationJSONBody defines parameters for CancelBatchOperation.
type CancelBatchOperationJSONBody interface{}

// ResumeBatchOperationJSONBody defines parameters for ResumeBatchOperation.
type ResumeBatchOperationJSONBody interface{}

// SuspendBatchOperationJSONBody defines parameters for SuspendBatchOperation.
type SuspendBatchOperationJSONBody interface{}

// DeployResourcesMultipartBody defines parameters for DeployResources.
type DeployResourcesMultipartBody struct {
	// Resources The binary data to create the deployment resources. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
	Resources []openapi_types.File `json:"resources"`

	// TenantId The tenant to deploy the resources to.
	TenantId *string `json:"tenantId,omitempty"`
}

// UploadDocumentMultipartBody defines parameters for UploadDocument.
type UploadDocumentMultipartBody struct {
	File openapi_types.File `json:"file"`

	// Metadata Information about the document.
	Metadata *DocumentMetadata `json:"metadata,omitempty"`
}

// UploadDocumentParams defines parameters for UploadDocument.
type UploadDocumentParams struct {
	// StoreId The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`

	// DocumentId The ID of the document to upload. If not provided, a new ID will be generated. Specifying an existing ID will result in an error if the document already exists.
	DocumentId *string `form:"documentId,omitempty" json:"documentId,omitempty"`
}

// UploadMultipleDocumentsMultipartBody defines parameters for UploadMultipleDocuments.
type UploadMultipleDocumentsMultipartBody struct {
	// Files The documents to upload.
	Files []openapi_types.File `json:"files"`
}

// UploadMultipleDocumentsParams defines parameters for UploadMultipleDocuments.
type UploadMultipleDocumentsParams struct {
	// StoreId The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// DeleteDocumentParams defines parameters for DeleteDocument.
type DeleteDocumentParams struct {
	// StoreId The ID of the document store to delete the document from.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// DownloadDocumentParams defines parameters for DownloadDocument.
type DownloadDocumentParams struct {
	// StoreId The ID of the document store to download the document from.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`

	// ContentHash The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.
	ContentHash string `form:"contentHash" json:"contentHash"`
}

// CreateDocumentLinkParams defines parameters for CreateDocumentLink.
type CreateDocumentLinkParams struct {
	// StoreId The ID of the document store to link the document from.
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`

	// ContentHash The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.
	ContentHash string `form:"contentHash" json:"contentHash"`
}

// GetUsageMetricsParams defines parameters for GetUsageMetrics.
type GetUsageMetricsParams struct {
	// StartTime The start date for usage metrics, including this date.
	StartTime time.Time `form:"startTime" json:"startTime"`

	// EndTime The end date for usage metrics, including this date.
	EndTime time.Time `form:"endTime" json:"endTime"`

	// TenantId Restrict results to a specific tenant ID. If not provided, results for all tenants are returned.
	TenantId *TenantId `form:"tenantId,omitempty" json:"tenantId,omitempty"`

	// WithTenants Whether to return tenant metrics in addition to the total metrics or not. Default false.
	WithTenants *bool `form:"withTenants,omitempty" json:"withTenants,omitempty"`
}

// CreateAuthorizationJSONRequestBody defines body for CreateAuthorization for application/json ContentType.
type CreateAuthorizationJSONRequestBody = AuthorizationRequest

// SearchAuthorizationsJSONRequestBody defines body for SearchAuthorizations for application/json ContentType.
type SearchAuthorizationsJSONRequestBody = AuthorizationSearchQuery

// UpdateAuthorizationJSONRequestBody defines body for UpdateAuthorization for application/json ContentType.
type UpdateAuthorizationJSONRequestBody = AuthorizationRequest

// SearchBatchOperationItemsJSONRequestBody defines body for SearchBatchOperationItems for application/json ContentType.
type SearchBatchOperationItemsJSONRequestBody = BatchOperationItemSearchQuery

// SearchBatchOperationsJSONRequestBody defines body for SearchBatchOperations for application/json ContentType.
type SearchBatchOperationsJSONRequestBody = BatchOperationSearchQuery

// CancelBatchOperationJSONRequestBody defines body for CancelBatchOperation for application/json ContentType.
type CancelBatchOperationJSONRequestBody CancelBatchOperationJSONBody

// ResumeBatchOperationJSONRequestBody defines body for ResumeBatchOperation for application/json ContentType.
type ResumeBatchOperationJSONRequestBody ResumeBatchOperationJSONBody

// SuspendBatchOperationJSONRequestBody defines body for SuspendBatchOperation for application/json ContentType.
type SuspendBatchOperationJSONRequestBody SuspendBatchOperationJSONBody

// PinInternalClockAlphaJSONRequestBody defines body for PinInternalClockAlpha for application/json ContentType.
type PinInternalClockAlphaJSONRequestBody = ClockPinRequest

// EvaluateDecisionJSONRequestBody defines body for EvaluateDecision for application/json ContentType.
type EvaluateDecisionJSONRequestBody = DecisionEvaluationInstruction

// SearchDecisionDefinitionsJSONRequestBody defines body for SearchDecisionDefinitions for application/json ContentType.
type SearchDecisionDefinitionsJSONRequestBody = DecisionDefinitionSearchQuery

// SearchDecisionInstancesJSONRequestBody defines body for SearchDecisionInstances for application/json ContentType.
type SearchDecisionInstancesJSONRequestBody = DecisionInstanceSearchQuery

// SearchDecisionRequirementsJSONRequestBody defines body for SearchDecisionRequirements for application/json ContentType.
type SearchDecisionRequirementsJSONRequestBody = DecisionRequirementsSearchQuery

// DeployResourcesMultipartRequestBody defines body for DeployResources for multipart/form-data ContentType.
type DeployResourcesMultipartRequestBody DeployResourcesMultipartBody

// UploadDocumentMultipartRequestBody defines body for UploadDocument for multipart/form-data ContentType.
type UploadDocumentMultipartRequestBody UploadDocumentMultipartBody

// UploadMultipleDocumentsMultipartRequestBody defines body for UploadMultipleDocuments for multipart/form-data ContentType.
type UploadMultipleDocumentsMultipartRequestBody UploadMultipleDocumentsMultipartBody

// CreateDocumentLinkJSONRequestBody defines body for CreateDocumentLink for application/json ContentType.
type CreateDocumentLinkJSONRequestBody = DocumentLinkRequest

// ActivateActivitiesWithinAnAdHocSubProcessJSONRequestBody defines body for ActivateActivitiesWithinAnAdHocSubProcess for application/json ContentType.
type ActivateActivitiesWithinAnAdHocSubProcessJSONRequestBody = AdHocSubProcessActivateActivitiesInstruction

// SearchElementInstancesJSONRequestBody defines body for SearchElementInstances for application/json ContentType.
type SearchElementInstancesJSONRequestBody = ElementInstanceSearchQuery

// UpdateElementInstanceVariablesJSONRequestBody defines body for UpdateElementInstanceVariables for application/json ContentType.
type UpdateElementInstanceVariablesJSONRequestBody = SetVariableRequest

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody = GroupCreateRequest

// SearchGroupsJSONRequestBody defines body for SearchGroups for application/json ContentType.
type SearchGroupsJSONRequestBody = GroupSearchQueryRequest

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody = GroupUpdateRequest

// SearchGroupClientsJSONRequestBody defines body for SearchGroupClients for application/json ContentType.
type SearchGroupClientsJSONRequestBody = GroupClientSearchQueryRequest

// SearchGroupMappingRulesJSONRequestBody defines body for SearchGroupMappingRules for application/json ContentType.
type SearchGroupMappingRulesJSONRequestBody = MappingRuleSearchQueryRequest

// SearchGroupRolesJSONRequestBody defines body for SearchGroupRoles for application/json ContentType.
type SearchGroupRolesJSONRequestBody = RoleSearchQueryRequest

// SearchGroupUsersJSONRequestBody defines body for SearchGroupUsers for application/json ContentType.
type SearchGroupUsersJSONRequestBody = GroupUserSearchQueryRequest

// SearchIncidentsJSONRequestBody defines body for SearchIncidents for application/json ContentType.
type SearchIncidentsJSONRequestBody = IncidentSearchQuery

// ResolveIncidentJSONRequestBody defines body for ResolveIncident for application/json ContentType.
type ResolveIncidentJSONRequestBody = IncidentResolutionRequest

// ActivateJobsJSONRequestBody defines body for ActivateJobs for application/json ContentType.
type ActivateJobsJSONRequestBody = JobActivationRequest

// SearchJobsJSONRequestBody defines body for SearchJobs for application/json ContentType.
type SearchJobsJSONRequestBody = JobSearchQuery

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = JobUpdateRequest

// CompleteJobJSONRequestBody defines body for CompleteJob for application/json ContentType.
type CompleteJobJSONRequestBody = JobCompletionRequest

// ThrowErrorForJobJSONRequestBody defines body for ThrowErrorForJob for application/json ContentType.
type ThrowErrorForJobJSONRequestBody = JobErrorRequest

// FailJobJSONRequestBody defines body for FailJob for application/json ContentType.
type FailJobJSONRequestBody = JobFailRequest

// CreateMappingRuleJSONRequestBody defines body for CreateMappingRule for application/json ContentType.
type CreateMappingRuleJSONRequestBody = MappingRuleCreateRequest

// SearchMappingRulesJSONRequestBody defines body for SearchMappingRules for application/json ContentType.
type SearchMappingRulesJSONRequestBody = MappingRuleSearchQueryRequest

// UpdateMappingRuleJSONRequestBody defines body for UpdateMappingRule for application/json ContentType.
type UpdateMappingRuleJSONRequestBody = MappingRuleUpdateRequest

// SearchMessageSubscriptionsJSONRequestBody defines body for SearchMessageSubscriptions for application/json ContentType.
type SearchMessageSubscriptionsJSONRequestBody = MessageSubscriptionSearchQuery

// CorrelateMessageJSONRequestBody defines body for CorrelateMessage for application/json ContentType.
type CorrelateMessageJSONRequestBody = MessageCorrelationRequest

// PublishMessageJSONRequestBody defines body for PublishMessage for application/json ContentType.
type PublishMessageJSONRequestBody = MessagePublicationRequest

// SearchProcessDefinitionsJSONRequestBody defines body for SearchProcessDefinitions for application/json ContentType.
type SearchProcessDefinitionsJSONRequestBody = ProcessDefinitionSearchQuery

// GetProcessDefinitionStatisticsJSONRequestBody defines body for GetProcessDefinitionStatistics for application/json ContentType.
type GetProcessDefinitionStatisticsJSONRequestBody = ProcessDefinitionElementStatisticsQuery

// CreateProcessInstanceJSONRequestBody defines body for CreateProcessInstance for application/json ContentType.
type CreateProcessInstanceJSONRequestBody = ProcessInstanceCreationInstruction

// CreateABatchOperationToCancelProcessInstancesJSONRequestBody defines body for CreateABatchOperationToCancelProcessInstances for application/json ContentType.
type CreateABatchOperationToCancelProcessInstancesJSONRequestBody = ProcessInstanceCancellationBatchOperationRequest

// CreateABatchOperationToResolveIncidentsOfProcessInstancesJSONRequestBody defines body for CreateABatchOperationToResolveIncidentsOfProcessInstances for application/json ContentType.
type CreateABatchOperationToResolveIncidentsOfProcessInstancesJSONRequestBody = ProcessInstanceIncidentResolutionBatchOperationRequest

// CreateABatchOperationToMigrateProcessInstancesJSONRequestBody defines body for CreateABatchOperationToMigrateProcessInstances for application/json ContentType.
type CreateABatchOperationToMigrateProcessInstancesJSONRequestBody = ProcessInstanceMigrationBatchOperationRequest

// CreateABatchOperationToModifyProcessInstancesJSONRequestBody defines body for CreateABatchOperationToModifyProcessInstances for application/json ContentType.
type CreateABatchOperationToModifyProcessInstancesJSONRequestBody = ProcessInstanceModificationBatchOperationRequest

// SearchProcessInstancesJSONRequestBody defines body for SearchProcessInstances for application/json ContentType.
type SearchProcessInstancesJSONRequestBody = ProcessInstanceSearchQuery

// CancelProcessInstanceJSONRequestBody defines body for CancelProcessInstance for application/json ContentType.
type CancelProcessInstanceJSONRequestBody = CancelProcessInstanceRequest

// SearchForIncidentsAssociatedWithAProcessInstanceJSONRequestBody defines body for SearchForIncidentsAssociatedWithAProcessInstance for application/json ContentType.
type SearchForIncidentsAssociatedWithAProcessInstanceJSONRequestBody = ProcessInstanceIncidentSearchQuery

// MigrateProcessInstanceJSONRequestBody defines body for MigrateProcessInstance for application/json ContentType.
type MigrateProcessInstanceJSONRequestBody = ProcessInstanceMigrationInstruction

// ModifyProcessInstanceJSONRequestBody defines body for ModifyProcessInstance for application/json ContentType.
type ModifyProcessInstanceJSONRequestBody = ProcessInstanceModificationInstruction

// DeleteResourceJSONRequestBody defines body for DeleteResource for application/json ContentType.
type DeleteResourceJSONRequestBody = DeleteResourceRequest

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody = RoleCreateRequest

// SearchRolesJSONRequestBody defines body for SearchRoles for application/json ContentType.
type SearchRolesJSONRequestBody = RoleSearchQueryRequest

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody = RoleUpdateRequest

// SearchRoleClientsJSONRequestBody defines body for SearchRoleClients for application/json ContentType.
type SearchRoleClientsJSONRequestBody = RoleClientSearchQueryRequest

// SearchRoleGroupsJSONRequestBody defines body for SearchRoleGroups for application/json ContentType.
type SearchRoleGroupsJSONRequestBody = RoleGroupSearchQueryRequest

// SearchRoleMappingRulesJSONRequestBody defines body for SearchRoleMappingRules for application/json ContentType.
type SearchRoleMappingRulesJSONRequestBody = MappingRuleSearchQueryRequest

// SearchRoleUsersJSONRequestBody defines body for SearchRoleUsers for application/json ContentType.
type SearchRoleUsersJSONRequestBody = RoleUserSearchQueryRequest

// CreateAdminUserJSONRequestBody defines body for CreateAdminUser for application/json ContentType.
type CreateAdminUserJSONRequestBody = UserRequest

// BroadcastSignalJSONRequestBody defines body for BroadcastSignal for application/json ContentType.
type BroadcastSignalJSONRequestBody = SignalBroadcastRequest

// CreateTenantJSONRequestBody defines body for CreateTenant for application/json ContentType.
type CreateTenantJSONRequestBody = TenantCreateRequest

// SearchTenantsJSONRequestBody defines body for SearchTenants for application/json ContentType.
type SearchTenantsJSONRequestBody = TenantSearchQueryRequest

// UpdateTenantJSONRequestBody defines body for UpdateTenant for application/json ContentType.
type UpdateTenantJSONRequestBody = TenantUpdateRequest

// SearchClientsForTenantJSONRequestBody defines body for SearchClientsForTenant for application/json ContentType.
type SearchClientsForTenantJSONRequestBody = TenantClientSearchQueryRequest

// SearchGroupsForTenantJSONRequestBody defines body for SearchGroupsForTenant for application/json ContentType.
type SearchGroupsForTenantJSONRequestBody = TenantGroupSearchQueryRequest

// SearchMappingRulesForTenantJSONRequestBody defines body for SearchMappingRulesForTenant for application/json ContentType.
type SearchMappingRulesForTenantJSONRequestBody = MappingRuleSearchQueryRequest

// SearchRolesForTenantJSONRequestBody defines body for SearchRolesForTenant for application/json ContentType.
type SearchRolesForTenantJSONRequestBody = RoleSearchQueryRequest

// SearchUsersForTenantJSONRequestBody defines body for SearchUsersForTenant for application/json ContentType.
type SearchUsersForTenantJSONRequestBody = TenantUserSearchQueryRequest

// SearchUserTasksJSONRequestBody defines body for SearchUserTasks for application/json ContentType.
type SearchUserTasksJSONRequestBody = UserTaskSearchQuery

// UpdateUserTaskJSONRequestBody defines body for UpdateUserTask for application/json ContentType.
type UpdateUserTaskJSONRequestBody = UserTaskUpdateRequest

// AssignUserTaskJSONRequestBody defines body for AssignUserTask for application/json ContentType.
type AssignUserTaskJSONRequestBody = UserTaskAssignmentRequest

// CompleteUserTaskJSONRequestBody defines body for CompleteUserTask for application/json ContentType.
type CompleteUserTaskJSONRequestBody = UserTaskCompletionRequest

// SearchUserTaskVariablesJSONRequestBody defines body for SearchUserTaskVariables for application/json ContentType.
type SearchUserTaskVariablesJSONRequestBody = UserTaskVariableSearchQueryRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = UserRequest

// SearchUsersJSONRequestBody defines body for SearchUsers for application/json ContentType.
type SearchUsersJSONRequestBody = UserSearchQueryRequest

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UserUpdateRequest

// SearchVariablesJSONRequestBody defines body for SearchVariables for application/json ContentType.
type SearchVariablesJSONRequestBody = VariableSearchQuery

// Getter for additional properties for Changeset. Returns the specified
// element and whether it was found
func (a Changeset) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Changeset
func (a *Changeset) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Changeset to handle AdditionalProperties
func (a *Changeset) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["candidateGroups"]; found {
		err = json.Unmarshal(raw, &a.CandidateGroups)
		if err != nil {
			return fmt.Errorf("error reading 'candidateGroups': %w", err)
		}
		delete(object, "candidateGroups")
	}

	if raw, found := object["candidateUsers"]; found {
		err = json.Unmarshal(raw, &a.CandidateUsers)
		if err != nil {
			return fmt.Errorf("error reading 'candidateUsers': %w", err)
		}
		delete(object, "candidateUsers")
	}

	if raw, found := object["dueDate"]; found {
		err = json.Unmarshal(raw, &a.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'dueDate': %w", err)
		}
		delete(object, "dueDate")
	}

	if raw, found := object["followUpDate"]; found {
		err = json.Unmarshal(raw, &a.FollowUpDate)
		if err != nil {
			return fmt.Errorf("error reading 'followUpDate': %w", err)
		}
		delete(object, "followUpDate")
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &a.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
		delete(object, "priority")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Changeset to handle AdditionalProperties
func (a Changeset) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CandidateGroups != nil {
		object["candidateGroups"], err = json.Marshal(a.CandidateGroups)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'candidateGroups': %w", err)
		}
	}

	if a.CandidateUsers != nil {
		object["candidateUsers"], err = json.Marshal(a.CandidateUsers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'candidateUsers': %w", err)
		}
	}

	if a.DueDate != nil {
		object["dueDate"], err = json.Marshal(a.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dueDate': %w", err)
		}
	}

	if a.FollowUpDate != nil {
		object["followUpDate"], err = json.Marshal(a.FollowUpDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'followUpDate': %w", err)
		}
	}

	if a.Priority != nil {
		object["priority"], err = json.Marshal(a.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsElementInstanceKey returns the union data inside the BaseProcessInstanceFilterFields_ParentElementInstanceKey as a ElementInstanceKey
func (t BaseProcessInstanceFilterFields_ParentElementInstanceKey) AsElementInstanceKey() (ElementInstanceKey, error) {
	var body ElementInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceKey overwrites any union data inside the BaseProcessInstanceFilterFields_ParentElementInstanceKey as the provided ElementInstanceKey
func (t *BaseProcessInstanceFilterFields_ParentElementInstanceKey) FromElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceKey performs a merge with any union data inside the BaseProcessInstanceFilterFields_ParentElementInstanceKey, using the provided ElementInstanceKey
func (t *BaseProcessInstanceFilterFields_ParentElementInstanceKey) MergeElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedElementInstanceKeyFilter returns the union data inside the BaseProcessInstanceFilterFields_ParentElementInstanceKey as a AdvancedElementInstanceKeyFilter
func (t BaseProcessInstanceFilterFields_ParentElementInstanceKey) AsAdvancedElementInstanceKeyFilter() (AdvancedElementInstanceKeyFilter, error) {
	var body AdvancedElementInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedElementInstanceKeyFilter overwrites any union data inside the BaseProcessInstanceFilterFields_ParentElementInstanceKey as the provided AdvancedElementInstanceKeyFilter
func (t *BaseProcessInstanceFilterFields_ParentElementInstanceKey) FromAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedElementInstanceKeyFilter performs a merge with any union data inside the BaseProcessInstanceFilterFields_ParentElementInstanceKey, using the provided AdvancedElementInstanceKeyFilter
func (t *BaseProcessInstanceFilterFields_ParentElementInstanceKey) MergeAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BaseProcessInstanceFilterFields_ParentElementInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BaseProcessInstanceFilterFields_ParentElementInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceKey returns the union data inside the BaseProcessInstanceFilterFields_ParentProcessInstanceKey as a ProcessInstanceKey
func (t BaseProcessInstanceFilterFields_ParentProcessInstanceKey) AsProcessInstanceKey() (ProcessInstanceKey, error) {
	var body ProcessInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKey overwrites any union data inside the BaseProcessInstanceFilterFields_ParentProcessInstanceKey as the provided ProcessInstanceKey
func (t *BaseProcessInstanceFilterFields_ParentProcessInstanceKey) FromProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKey performs a merge with any union data inside the BaseProcessInstanceFilterFields_ParentProcessInstanceKey, using the provided ProcessInstanceKey
func (t *BaseProcessInstanceFilterFields_ParentProcessInstanceKey) MergeProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceKeyFilter returns the union data inside the BaseProcessInstanceFilterFields_ParentProcessInstanceKey as a AdvancedProcessInstanceKeyFilter
func (t BaseProcessInstanceFilterFields_ParentProcessInstanceKey) AsAdvancedProcessInstanceKeyFilter() (AdvancedProcessInstanceKeyFilter, error) {
	var body AdvancedProcessInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceKeyFilter overwrites any union data inside the BaseProcessInstanceFilterFields_ParentProcessInstanceKey as the provided AdvancedProcessInstanceKeyFilter
func (t *BaseProcessInstanceFilterFields_ParentProcessInstanceKey) FromAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceKeyFilter performs a merge with any union data inside the BaseProcessInstanceFilterFields_ParentProcessInstanceKey, using the provided AdvancedProcessInstanceKeyFilter
func (t *BaseProcessInstanceFilterFields_ParentProcessInstanceKey) MergeAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BaseProcessInstanceFilterFields_ParentProcessInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BaseProcessInstanceFilterFields_ParentProcessInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceKey returns the union data inside the BaseProcessInstanceFilterFields_ProcessInstanceKey as a ProcessInstanceKey
func (t BaseProcessInstanceFilterFields_ProcessInstanceKey) AsProcessInstanceKey() (ProcessInstanceKey, error) {
	var body ProcessInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKey overwrites any union data inside the BaseProcessInstanceFilterFields_ProcessInstanceKey as the provided ProcessInstanceKey
func (t *BaseProcessInstanceFilterFields_ProcessInstanceKey) FromProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKey performs a merge with any union data inside the BaseProcessInstanceFilterFields_ProcessInstanceKey, using the provided ProcessInstanceKey
func (t *BaseProcessInstanceFilterFields_ProcessInstanceKey) MergeProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceKeyFilter returns the union data inside the BaseProcessInstanceFilterFields_ProcessInstanceKey as a AdvancedProcessInstanceKeyFilter
func (t BaseProcessInstanceFilterFields_ProcessInstanceKey) AsAdvancedProcessInstanceKeyFilter() (AdvancedProcessInstanceKeyFilter, error) {
	var body AdvancedProcessInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceKeyFilter overwrites any union data inside the BaseProcessInstanceFilterFields_ProcessInstanceKey as the provided AdvancedProcessInstanceKeyFilter
func (t *BaseProcessInstanceFilterFields_ProcessInstanceKey) FromAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceKeyFilter performs a merge with any union data inside the BaseProcessInstanceFilterFields_ProcessInstanceKey, using the provided AdvancedProcessInstanceKeyFilter
func (t *BaseProcessInstanceFilterFields_ProcessInstanceKey) MergeAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BaseProcessInstanceFilterFields_ProcessInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BaseProcessInstanceFilterFields_ProcessInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBasicStringFilterProperty0 returns the union data inside the BasicStringFilterProperty as a BasicStringFilterProperty0
func (t BasicStringFilterProperty) AsBasicStringFilterProperty0() (BasicStringFilterProperty0, error) {
	var body BasicStringFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBasicStringFilterProperty0 overwrites any union data inside the BasicStringFilterProperty as the provided BasicStringFilterProperty0
func (t *BasicStringFilterProperty) FromBasicStringFilterProperty0(v BasicStringFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBasicStringFilterProperty0 performs a merge with any union data inside the BasicStringFilterProperty, using the provided BasicStringFilterProperty0
func (t *BasicStringFilterProperty) MergeBasicStringFilterProperty0(v BasicStringFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBasicStringFilter returns the union data inside the BasicStringFilterProperty as a BasicStringFilter
func (t BasicStringFilterProperty) AsBasicStringFilter() (BasicStringFilter, error) {
	var body BasicStringFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBasicStringFilter overwrites any union data inside the BasicStringFilterProperty as the provided BasicStringFilter
func (t *BasicStringFilterProperty) FromBasicStringFilter(v BasicStringFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBasicStringFilter performs a merge with any union data inside the BasicStringFilterProperty, using the provided BasicStringFilter
func (t *BasicStringFilterProperty) MergeBasicStringFilter(v BasicStringFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BasicStringFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BasicStringFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceKey returns the union data inside the BatchOperationItemFilter_ProcessInstanceKey as a ProcessInstanceKey
func (t BatchOperationItemFilter_ProcessInstanceKey) AsProcessInstanceKey() (ProcessInstanceKey, error) {
	var body ProcessInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKey overwrites any union data inside the BatchOperationItemFilter_ProcessInstanceKey as the provided ProcessInstanceKey
func (t *BatchOperationItemFilter_ProcessInstanceKey) FromProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKey performs a merge with any union data inside the BatchOperationItemFilter_ProcessInstanceKey, using the provided ProcessInstanceKey
func (t *BatchOperationItemFilter_ProcessInstanceKey) MergeProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceKeyFilter returns the union data inside the BatchOperationItemFilter_ProcessInstanceKey as a AdvancedProcessInstanceKeyFilter
func (t BatchOperationItemFilter_ProcessInstanceKey) AsAdvancedProcessInstanceKeyFilter() (AdvancedProcessInstanceKeyFilter, error) {
	var body AdvancedProcessInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceKeyFilter overwrites any union data inside the BatchOperationItemFilter_ProcessInstanceKey as the provided AdvancedProcessInstanceKeyFilter
func (t *BatchOperationItemFilter_ProcessInstanceKey) FromAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceKeyFilter performs a merge with any union data inside the BatchOperationItemFilter_ProcessInstanceKey, using the provided AdvancedProcessInstanceKeyFilter
func (t *BatchOperationItemFilter_ProcessInstanceKey) MergeAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchOperationItemFilter_ProcessInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchOperationItemFilter_ProcessInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBatchOperationItemStateFilterProperty0 returns the union data inside the BatchOperationItemStateFilterProperty as a BatchOperationItemStateFilterProperty0
func (t BatchOperationItemStateFilterProperty) AsBatchOperationItemStateFilterProperty0() (BatchOperationItemStateFilterProperty0, error) {
	var body BatchOperationItemStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchOperationItemStateFilterProperty0 overwrites any union data inside the BatchOperationItemStateFilterProperty as the provided BatchOperationItemStateFilterProperty0
func (t *BatchOperationItemStateFilterProperty) FromBatchOperationItemStateFilterProperty0(v BatchOperationItemStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchOperationItemStateFilterProperty0 performs a merge with any union data inside the BatchOperationItemStateFilterProperty, using the provided BatchOperationItemStateFilterProperty0
func (t *BatchOperationItemStateFilterProperty) MergeBatchOperationItemStateFilterProperty0(v BatchOperationItemStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedBatchOperationItemStateFilter returns the union data inside the BatchOperationItemStateFilterProperty as a AdvancedBatchOperationItemStateFilter
func (t BatchOperationItemStateFilterProperty) AsAdvancedBatchOperationItemStateFilter() (AdvancedBatchOperationItemStateFilter, error) {
	var body AdvancedBatchOperationItemStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedBatchOperationItemStateFilter overwrites any union data inside the BatchOperationItemStateFilterProperty as the provided AdvancedBatchOperationItemStateFilter
func (t *BatchOperationItemStateFilterProperty) FromAdvancedBatchOperationItemStateFilter(v AdvancedBatchOperationItemStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedBatchOperationItemStateFilter performs a merge with any union data inside the BatchOperationItemStateFilterProperty, using the provided AdvancedBatchOperationItemStateFilter
func (t *BatchOperationItemStateFilterProperty) MergeAdvancedBatchOperationItemStateFilter(v AdvancedBatchOperationItemStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchOperationItemStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchOperationItemStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBatchOperationKey0 returns the union data inside the BatchOperationKey as a BatchOperationKey0
func (t BatchOperationKey) AsBatchOperationKey0() (BatchOperationKey0, error) {
	var body BatchOperationKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchOperationKey0 overwrites any union data inside the BatchOperationKey as the provided BatchOperationKey0
func (t *BatchOperationKey) FromBatchOperationKey0(v BatchOperationKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchOperationKey0 performs a merge with any union data inside the BatchOperationKey, using the provided BatchOperationKey0
func (t *BatchOperationKey) MergeBatchOperationKey0(v BatchOperationKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBatchOperationKey1 returns the union data inside the BatchOperationKey as a BatchOperationKey1
func (t BatchOperationKey) AsBatchOperationKey1() (BatchOperationKey1, error) {
	var body BatchOperationKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchOperationKey1 overwrites any union data inside the BatchOperationKey as the provided BatchOperationKey1
func (t *BatchOperationKey) FromBatchOperationKey1(v BatchOperationKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchOperationKey1 performs a merge with any union data inside the BatchOperationKey, using the provided BatchOperationKey1
func (t *BatchOperationKey) MergeBatchOperationKey1(v BatchOperationKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchOperationKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchOperationKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBatchOperationStateFilterProperty0 returns the union data inside the BatchOperationStateFilterProperty as a BatchOperationStateFilterProperty0
func (t BatchOperationStateFilterProperty) AsBatchOperationStateFilterProperty0() (BatchOperationStateFilterProperty0, error) {
	var body BatchOperationStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchOperationStateFilterProperty0 overwrites any union data inside the BatchOperationStateFilterProperty as the provided BatchOperationStateFilterProperty0
func (t *BatchOperationStateFilterProperty) FromBatchOperationStateFilterProperty0(v BatchOperationStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchOperationStateFilterProperty0 performs a merge with any union data inside the BatchOperationStateFilterProperty, using the provided BatchOperationStateFilterProperty0
func (t *BatchOperationStateFilterProperty) MergeBatchOperationStateFilterProperty0(v BatchOperationStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedBatchOperationStateFilter returns the union data inside the BatchOperationStateFilterProperty as a AdvancedBatchOperationStateFilter
func (t BatchOperationStateFilterProperty) AsAdvancedBatchOperationStateFilter() (AdvancedBatchOperationStateFilter, error) {
	var body AdvancedBatchOperationStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedBatchOperationStateFilter overwrites any union data inside the BatchOperationStateFilterProperty as the provided AdvancedBatchOperationStateFilter
func (t *BatchOperationStateFilterProperty) FromAdvancedBatchOperationStateFilter(v AdvancedBatchOperationStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedBatchOperationStateFilter performs a merge with any union data inside the BatchOperationStateFilterProperty, using the provided AdvancedBatchOperationStateFilter
func (t *BatchOperationStateFilterProperty) MergeAdvancedBatchOperationStateFilter(v AdvancedBatchOperationStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchOperationStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchOperationStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBatchOperationTypeFilterProperty0 returns the union data inside the BatchOperationTypeFilterProperty as a BatchOperationTypeFilterProperty0
func (t BatchOperationTypeFilterProperty) AsBatchOperationTypeFilterProperty0() (BatchOperationTypeFilterProperty0, error) {
	var body BatchOperationTypeFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchOperationTypeFilterProperty0 overwrites any union data inside the BatchOperationTypeFilterProperty as the provided BatchOperationTypeFilterProperty0
func (t *BatchOperationTypeFilterProperty) FromBatchOperationTypeFilterProperty0(v BatchOperationTypeFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchOperationTypeFilterProperty0 performs a merge with any union data inside the BatchOperationTypeFilterProperty, using the provided BatchOperationTypeFilterProperty0
func (t *BatchOperationTypeFilterProperty) MergeBatchOperationTypeFilterProperty0(v BatchOperationTypeFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedBatchOperationTypeFilter returns the union data inside the BatchOperationTypeFilterProperty as a AdvancedBatchOperationTypeFilter
func (t BatchOperationTypeFilterProperty) AsAdvancedBatchOperationTypeFilter() (AdvancedBatchOperationTypeFilter, error) {
	var body AdvancedBatchOperationTypeFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedBatchOperationTypeFilter overwrites any union data inside the BatchOperationTypeFilterProperty as the provided AdvancedBatchOperationTypeFilter
func (t *BatchOperationTypeFilterProperty) FromAdvancedBatchOperationTypeFilter(v AdvancedBatchOperationTypeFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedBatchOperationTypeFilter performs a merge with any union data inside the BatchOperationTypeFilterProperty, using the provided AdvancedBatchOperationTypeFilter
func (t *BatchOperationTypeFilterProperty) MergeAdvancedBatchOperationTypeFilter(v AdvancedBatchOperationTypeFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchOperationTypeFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchOperationTypeFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDateTimeFilterProperty0 returns the union data inside the DateTimeFilterProperty as a DateTimeFilterProperty0
func (t DateTimeFilterProperty) AsDateTimeFilterProperty0() (DateTimeFilterProperty0, error) {
	var body DateTimeFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimeFilterProperty0 overwrites any union data inside the DateTimeFilterProperty as the provided DateTimeFilterProperty0
func (t *DateTimeFilterProperty) FromDateTimeFilterProperty0(v DateTimeFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimeFilterProperty0 performs a merge with any union data inside the DateTimeFilterProperty, using the provided DateTimeFilterProperty0
func (t *DateTimeFilterProperty) MergeDateTimeFilterProperty0(v DateTimeFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedDateTimeFilter returns the union data inside the DateTimeFilterProperty as a AdvancedDateTimeFilter
func (t DateTimeFilterProperty) AsAdvancedDateTimeFilter() (AdvancedDateTimeFilter, error) {
	var body AdvancedDateTimeFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedDateTimeFilter overwrites any union data inside the DateTimeFilterProperty as the provided AdvancedDateTimeFilter
func (t *DateTimeFilterProperty) FromAdvancedDateTimeFilter(v AdvancedDateTimeFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedDateTimeFilter performs a merge with any union data inside the DateTimeFilterProperty, using the provided AdvancedDateTimeFilter
func (t *DateTimeFilterProperty) MergeAdvancedDateTimeFilter(v AdvancedDateTimeFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DateTimeFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DateTimeFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDecisionEvaluationById returns the union data inside the DecisionEvaluationInstruction as a DecisionEvaluationById
func (t DecisionEvaluationInstruction) AsDecisionEvaluationById() (DecisionEvaluationById, error) {
	var body DecisionEvaluationById
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDecisionEvaluationById overwrites any union data inside the DecisionEvaluationInstruction as the provided DecisionEvaluationById
func (t *DecisionEvaluationInstruction) FromDecisionEvaluationById(v DecisionEvaluationById) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDecisionEvaluationById performs a merge with any union data inside the DecisionEvaluationInstruction, using the provided DecisionEvaluationById
func (t *DecisionEvaluationInstruction) MergeDecisionEvaluationById(v DecisionEvaluationById) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDecisionEvaluationByKey returns the union data inside the DecisionEvaluationInstruction as a DecisionEvaluationByKey
func (t DecisionEvaluationInstruction) AsDecisionEvaluationByKey() (DecisionEvaluationByKey, error) {
	var body DecisionEvaluationByKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDecisionEvaluationByKey overwrites any union data inside the DecisionEvaluationInstruction as the provided DecisionEvaluationByKey
func (t *DecisionEvaluationInstruction) FromDecisionEvaluationByKey(v DecisionEvaluationByKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDecisionEvaluationByKey performs a merge with any union data inside the DecisionEvaluationInstruction, using the provided DecisionEvaluationByKey
func (t *DecisionEvaluationInstruction) MergeDecisionEvaluationByKey(v DecisionEvaluationByKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DecisionEvaluationInstruction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DecisionEvaluationInstruction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDecisionDefinitionKey returns the union data inside the DecisionInstanceFilter_DecisionDefinitionKey as a DecisionDefinitionKey
func (t DecisionInstanceFilter_DecisionDefinitionKey) AsDecisionDefinitionKey() (DecisionDefinitionKey, error) {
	var body DecisionDefinitionKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDecisionDefinitionKey overwrites any union data inside the DecisionInstanceFilter_DecisionDefinitionKey as the provided DecisionDefinitionKey
func (t *DecisionInstanceFilter_DecisionDefinitionKey) FromDecisionDefinitionKey(v DecisionDefinitionKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDecisionDefinitionKey performs a merge with any union data inside the DecisionInstanceFilter_DecisionDefinitionKey, using the provided DecisionDefinitionKey
func (t *DecisionInstanceFilter_DecisionDefinitionKey) MergeDecisionDefinitionKey(v DecisionDefinitionKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedDecisionDefinitionKeyFilter returns the union data inside the DecisionInstanceFilter_DecisionDefinitionKey as a AdvancedDecisionDefinitionKeyFilter
func (t DecisionInstanceFilter_DecisionDefinitionKey) AsAdvancedDecisionDefinitionKeyFilter() (AdvancedDecisionDefinitionKeyFilter, error) {
	var body AdvancedDecisionDefinitionKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedDecisionDefinitionKeyFilter overwrites any union data inside the DecisionInstanceFilter_DecisionDefinitionKey as the provided AdvancedDecisionDefinitionKeyFilter
func (t *DecisionInstanceFilter_DecisionDefinitionKey) FromAdvancedDecisionDefinitionKeyFilter(v AdvancedDecisionDefinitionKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedDecisionDefinitionKeyFilter performs a merge with any union data inside the DecisionInstanceFilter_DecisionDefinitionKey, using the provided AdvancedDecisionDefinitionKeyFilter
func (t *DecisionInstanceFilter_DecisionDefinitionKey) MergeAdvancedDecisionDefinitionKeyFilter(v AdvancedDecisionDefinitionKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DecisionInstanceFilter_DecisionDefinitionKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DecisionInstanceFilter_DecisionDefinitionKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsElementInstanceKey returns the union data inside the DecisionInstanceFilter_ElementInstanceKey as a ElementInstanceKey
func (t DecisionInstanceFilter_ElementInstanceKey) AsElementInstanceKey() (ElementInstanceKey, error) {
	var body ElementInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceKey overwrites any union data inside the DecisionInstanceFilter_ElementInstanceKey as the provided ElementInstanceKey
func (t *DecisionInstanceFilter_ElementInstanceKey) FromElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceKey performs a merge with any union data inside the DecisionInstanceFilter_ElementInstanceKey, using the provided ElementInstanceKey
func (t *DecisionInstanceFilter_ElementInstanceKey) MergeElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedElementInstanceKeyFilter returns the union data inside the DecisionInstanceFilter_ElementInstanceKey as a AdvancedElementInstanceKeyFilter
func (t DecisionInstanceFilter_ElementInstanceKey) AsAdvancedElementInstanceKeyFilter() (AdvancedElementInstanceKeyFilter, error) {
	var body AdvancedElementInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedElementInstanceKeyFilter overwrites any union data inside the DecisionInstanceFilter_ElementInstanceKey as the provided AdvancedElementInstanceKeyFilter
func (t *DecisionInstanceFilter_ElementInstanceKey) FromAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedElementInstanceKeyFilter performs a merge with any union data inside the DecisionInstanceFilter_ElementInstanceKey, using the provided AdvancedElementInstanceKeyFilter
func (t *DecisionInstanceFilter_ElementInstanceKey) MergeAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DecisionInstanceFilter_ElementInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DecisionInstanceFilter_ElementInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsElementInstanceKey returns the union data inside the ElementInstanceFilter_ElementInstanceScopeKey as a ElementInstanceKey
func (t ElementInstanceFilter_ElementInstanceScopeKey) AsElementInstanceKey() (ElementInstanceKey, error) {
	var body ElementInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceKey overwrites any union data inside the ElementInstanceFilter_ElementInstanceScopeKey as the provided ElementInstanceKey
func (t *ElementInstanceFilter_ElementInstanceScopeKey) FromElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceKey performs a merge with any union data inside the ElementInstanceFilter_ElementInstanceScopeKey, using the provided ElementInstanceKey
func (t *ElementInstanceFilter_ElementInstanceScopeKey) MergeElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProcessInstanceKey returns the union data inside the ElementInstanceFilter_ElementInstanceScopeKey as a ProcessInstanceKey
func (t ElementInstanceFilter_ElementInstanceScopeKey) AsProcessInstanceKey() (ProcessInstanceKey, error) {
	var body ProcessInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKey overwrites any union data inside the ElementInstanceFilter_ElementInstanceScopeKey as the provided ProcessInstanceKey
func (t *ElementInstanceFilter_ElementInstanceScopeKey) FromProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKey performs a merge with any union data inside the ElementInstanceFilter_ElementInstanceScopeKey, using the provided ProcessInstanceKey
func (t *ElementInstanceFilter_ElementInstanceScopeKey) MergeProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ElementInstanceFilter_ElementInstanceScopeKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ElementInstanceFilter_ElementInstanceScopeKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsElementInstanceStateFilterProperty0 returns the union data inside the ElementInstanceStateFilterProperty as a ElementInstanceStateFilterProperty0
func (t ElementInstanceStateFilterProperty) AsElementInstanceStateFilterProperty0() (ElementInstanceStateFilterProperty0, error) {
	var body ElementInstanceStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceStateFilterProperty0 overwrites any union data inside the ElementInstanceStateFilterProperty as the provided ElementInstanceStateFilterProperty0
func (t *ElementInstanceStateFilterProperty) FromElementInstanceStateFilterProperty0(v ElementInstanceStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceStateFilterProperty0 performs a merge with any union data inside the ElementInstanceStateFilterProperty, using the provided ElementInstanceStateFilterProperty0
func (t *ElementInstanceStateFilterProperty) MergeElementInstanceStateFilterProperty0(v ElementInstanceStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedElementInstanceStateFilter returns the union data inside the ElementInstanceStateFilterProperty as a AdvancedElementInstanceStateFilter
func (t ElementInstanceStateFilterProperty) AsAdvancedElementInstanceStateFilter() (AdvancedElementInstanceStateFilter, error) {
	var body AdvancedElementInstanceStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedElementInstanceStateFilter overwrites any union data inside the ElementInstanceStateFilterProperty as the provided AdvancedElementInstanceStateFilter
func (t *ElementInstanceStateFilterProperty) FromAdvancedElementInstanceStateFilter(v AdvancedElementInstanceStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedElementInstanceStateFilter performs a merge with any union data inside the ElementInstanceStateFilterProperty, using the provided AdvancedElementInstanceStateFilter
func (t *ElementInstanceStateFilterProperty) MergeAdvancedElementInstanceStateFilter(v AdvancedElementInstanceStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ElementInstanceStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ElementInstanceStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIntegerFilterProperty0 returns the union data inside the IntegerFilterProperty as a IntegerFilterProperty0
func (t IntegerFilterProperty) AsIntegerFilterProperty0() (IntegerFilterProperty0, error) {
	var body IntegerFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFilterProperty0 overwrites any union data inside the IntegerFilterProperty as the provided IntegerFilterProperty0
func (t *IntegerFilterProperty) FromIntegerFilterProperty0(v IntegerFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFilterProperty0 performs a merge with any union data inside the IntegerFilterProperty, using the provided IntegerFilterProperty0
func (t *IntegerFilterProperty) MergeIntegerFilterProperty0(v IntegerFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedIntegerFilter returns the union data inside the IntegerFilterProperty as a AdvancedIntegerFilter
func (t IntegerFilterProperty) AsAdvancedIntegerFilter() (AdvancedIntegerFilter, error) {
	var body AdvancedIntegerFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedIntegerFilter overwrites any union data inside the IntegerFilterProperty as the provided AdvancedIntegerFilter
func (t *IntegerFilterProperty) FromAdvancedIntegerFilter(v AdvancedIntegerFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedIntegerFilter performs a merge with any union data inside the IntegerFilterProperty, using the provided AdvancedIntegerFilter
func (t *IntegerFilterProperty) MergeAdvancedIntegerFilter(v AdvancedIntegerFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IntegerFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IntegerFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsElementInstanceKey returns the union data inside the JobFilter_ElementInstanceKey as a ElementInstanceKey
func (t JobFilter_ElementInstanceKey) AsElementInstanceKey() (ElementInstanceKey, error) {
	var body ElementInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceKey overwrites any union data inside the JobFilter_ElementInstanceKey as the provided ElementInstanceKey
func (t *JobFilter_ElementInstanceKey) FromElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceKey performs a merge with any union data inside the JobFilter_ElementInstanceKey, using the provided ElementInstanceKey
func (t *JobFilter_ElementInstanceKey) MergeElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedElementInstanceKeyFilter returns the union data inside the JobFilter_ElementInstanceKey as a AdvancedElementInstanceKeyFilter
func (t JobFilter_ElementInstanceKey) AsAdvancedElementInstanceKeyFilter() (AdvancedElementInstanceKeyFilter, error) {
	var body AdvancedElementInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedElementInstanceKeyFilter overwrites any union data inside the JobFilter_ElementInstanceKey as the provided AdvancedElementInstanceKeyFilter
func (t *JobFilter_ElementInstanceKey) FromAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedElementInstanceKeyFilter performs a merge with any union data inside the JobFilter_ElementInstanceKey, using the provided AdvancedElementInstanceKeyFilter
func (t *JobFilter_ElementInstanceKey) MergeAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobFilter_ElementInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobFilter_ElementInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJobKey returns the union data inside the JobFilter_JobKey as a JobKey
func (t JobFilter_JobKey) AsJobKey() (JobKey, error) {
	var body JobKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobKey overwrites any union data inside the JobFilter_JobKey as the provided JobKey
func (t *JobFilter_JobKey) FromJobKey(v JobKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobKey performs a merge with any union data inside the JobFilter_JobKey, using the provided JobKey
func (t *JobFilter_JobKey) MergeJobKey(v JobKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedJobKeyFilter returns the union data inside the JobFilter_JobKey as a AdvancedJobKeyFilter
func (t JobFilter_JobKey) AsAdvancedJobKeyFilter() (AdvancedJobKeyFilter, error) {
	var body AdvancedJobKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedJobKeyFilter overwrites any union data inside the JobFilter_JobKey as the provided AdvancedJobKeyFilter
func (t *JobFilter_JobKey) FromAdvancedJobKeyFilter(v AdvancedJobKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedJobKeyFilter performs a merge with any union data inside the JobFilter_JobKey, using the provided AdvancedJobKeyFilter
func (t *JobFilter_JobKey) MergeAdvancedJobKeyFilter(v AdvancedJobKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobFilter_JobKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobFilter_JobKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessDefinitionKey returns the union data inside the JobFilter_ProcessDefinitionKey as a ProcessDefinitionKey
func (t JobFilter_ProcessDefinitionKey) AsProcessDefinitionKey() (ProcessDefinitionKey, error) {
	var body ProcessDefinitionKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessDefinitionKey overwrites any union data inside the JobFilter_ProcessDefinitionKey as the provided ProcessDefinitionKey
func (t *JobFilter_ProcessDefinitionKey) FromProcessDefinitionKey(v ProcessDefinitionKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessDefinitionKey performs a merge with any union data inside the JobFilter_ProcessDefinitionKey, using the provided ProcessDefinitionKey
func (t *JobFilter_ProcessDefinitionKey) MergeProcessDefinitionKey(v ProcessDefinitionKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessDefinitionKeyFilter returns the union data inside the JobFilter_ProcessDefinitionKey as a AdvancedProcessDefinitionKeyFilter
func (t JobFilter_ProcessDefinitionKey) AsAdvancedProcessDefinitionKeyFilter() (AdvancedProcessDefinitionKeyFilter, error) {
	var body AdvancedProcessDefinitionKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessDefinitionKeyFilter overwrites any union data inside the JobFilter_ProcessDefinitionKey as the provided AdvancedProcessDefinitionKeyFilter
func (t *JobFilter_ProcessDefinitionKey) FromAdvancedProcessDefinitionKeyFilter(v AdvancedProcessDefinitionKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessDefinitionKeyFilter performs a merge with any union data inside the JobFilter_ProcessDefinitionKey, using the provided AdvancedProcessDefinitionKeyFilter
func (t *JobFilter_ProcessDefinitionKey) MergeAdvancedProcessDefinitionKeyFilter(v AdvancedProcessDefinitionKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobFilter_ProcessDefinitionKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobFilter_ProcessDefinitionKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceKey returns the union data inside the JobFilter_ProcessInstanceKey as a ProcessInstanceKey
func (t JobFilter_ProcessInstanceKey) AsProcessInstanceKey() (ProcessInstanceKey, error) {
	var body ProcessInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKey overwrites any union data inside the JobFilter_ProcessInstanceKey as the provided ProcessInstanceKey
func (t *JobFilter_ProcessInstanceKey) FromProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKey performs a merge with any union data inside the JobFilter_ProcessInstanceKey, using the provided ProcessInstanceKey
func (t *JobFilter_ProcessInstanceKey) MergeProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceKeyFilter returns the union data inside the JobFilter_ProcessInstanceKey as a AdvancedProcessInstanceKeyFilter
func (t JobFilter_ProcessInstanceKey) AsAdvancedProcessInstanceKeyFilter() (AdvancedProcessInstanceKeyFilter, error) {
	var body AdvancedProcessInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceKeyFilter overwrites any union data inside the JobFilter_ProcessInstanceKey as the provided AdvancedProcessInstanceKeyFilter
func (t *JobFilter_ProcessInstanceKey) FromAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceKeyFilter performs a merge with any union data inside the JobFilter_ProcessInstanceKey, using the provided AdvancedProcessInstanceKeyFilter
func (t *JobFilter_ProcessInstanceKey) MergeAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobFilter_ProcessInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobFilter_ProcessInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJobKindFilterProperty0 returns the union data inside the JobKindFilterProperty as a JobKindFilterProperty0
func (t JobKindFilterProperty) AsJobKindFilterProperty0() (JobKindFilterProperty0, error) {
	var body JobKindFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobKindFilterProperty0 overwrites any union data inside the JobKindFilterProperty as the provided JobKindFilterProperty0
func (t *JobKindFilterProperty) FromJobKindFilterProperty0(v JobKindFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobKindFilterProperty0 performs a merge with any union data inside the JobKindFilterProperty, using the provided JobKindFilterProperty0
func (t *JobKindFilterProperty) MergeJobKindFilterProperty0(v JobKindFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedJobKindFilter returns the union data inside the JobKindFilterProperty as a AdvancedJobKindFilter
func (t JobKindFilterProperty) AsAdvancedJobKindFilter() (AdvancedJobKindFilter, error) {
	var body AdvancedJobKindFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedJobKindFilter overwrites any union data inside the JobKindFilterProperty as the provided AdvancedJobKindFilter
func (t *JobKindFilterProperty) FromAdvancedJobKindFilter(v AdvancedJobKindFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedJobKindFilter performs a merge with any union data inside the JobKindFilterProperty, using the provided AdvancedJobKindFilter
func (t *JobKindFilterProperty) MergeAdvancedJobKindFilter(v AdvancedJobKindFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobKindFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobKindFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJobListenerEventTypeFilterProperty0 returns the union data inside the JobListenerEventTypeFilterProperty as a JobListenerEventTypeFilterProperty0
func (t JobListenerEventTypeFilterProperty) AsJobListenerEventTypeFilterProperty0() (JobListenerEventTypeFilterProperty0, error) {
	var body JobListenerEventTypeFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobListenerEventTypeFilterProperty0 overwrites any union data inside the JobListenerEventTypeFilterProperty as the provided JobListenerEventTypeFilterProperty0
func (t *JobListenerEventTypeFilterProperty) FromJobListenerEventTypeFilterProperty0(v JobListenerEventTypeFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobListenerEventTypeFilterProperty0 performs a merge with any union data inside the JobListenerEventTypeFilterProperty, using the provided JobListenerEventTypeFilterProperty0
func (t *JobListenerEventTypeFilterProperty) MergeJobListenerEventTypeFilterProperty0(v JobListenerEventTypeFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedJobListenerEventTypeFilter returns the union data inside the JobListenerEventTypeFilterProperty as a AdvancedJobListenerEventTypeFilter
func (t JobListenerEventTypeFilterProperty) AsAdvancedJobListenerEventTypeFilter() (AdvancedJobListenerEventTypeFilter, error) {
	var body AdvancedJobListenerEventTypeFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedJobListenerEventTypeFilter overwrites any union data inside the JobListenerEventTypeFilterProperty as the provided AdvancedJobListenerEventTypeFilter
func (t *JobListenerEventTypeFilterProperty) FromAdvancedJobListenerEventTypeFilter(v AdvancedJobListenerEventTypeFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedJobListenerEventTypeFilter performs a merge with any union data inside the JobListenerEventTypeFilterProperty, using the provided AdvancedJobListenerEventTypeFilter
func (t *JobListenerEventTypeFilterProperty) MergeAdvancedJobListenerEventTypeFilter(v AdvancedJobListenerEventTypeFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobListenerEventTypeFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobListenerEventTypeFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJobStateFilterProperty0 returns the union data inside the JobStateFilterProperty as a JobStateFilterProperty0
func (t JobStateFilterProperty) AsJobStateFilterProperty0() (JobStateFilterProperty0, error) {
	var body JobStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobStateFilterProperty0 overwrites any union data inside the JobStateFilterProperty as the provided JobStateFilterProperty0
func (t *JobStateFilterProperty) FromJobStateFilterProperty0(v JobStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobStateFilterProperty0 performs a merge with any union data inside the JobStateFilterProperty, using the provided JobStateFilterProperty0
func (t *JobStateFilterProperty) MergeJobStateFilterProperty0(v JobStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedJobStateFilter returns the union data inside the JobStateFilterProperty as a AdvancedJobStateFilter
func (t JobStateFilterProperty) AsAdvancedJobStateFilter() (AdvancedJobStateFilter, error) {
	var body AdvancedJobStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedJobStateFilter overwrites any union data inside the JobStateFilterProperty as the provided AdvancedJobStateFilter
func (t *JobStateFilterProperty) FromAdvancedJobStateFilter(v AdvancedJobStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedJobStateFilter performs a merge with any union data inside the JobStateFilterProperty, using the provided AdvancedJobStateFilter
func (t *JobStateFilterProperty) MergeAdvancedJobStateFilter(v AdvancedJobStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageSubscriptionTypeFilterProperty0 returns the union data inside the MessageSubscriptionTypeFilterProperty as a MessageSubscriptionTypeFilterProperty0
func (t MessageSubscriptionTypeFilterProperty) AsMessageSubscriptionTypeFilterProperty0() (MessageSubscriptionTypeFilterProperty0, error) {
	var body MessageSubscriptionTypeFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageSubscriptionTypeFilterProperty0 overwrites any union data inside the MessageSubscriptionTypeFilterProperty as the provided MessageSubscriptionTypeFilterProperty0
func (t *MessageSubscriptionTypeFilterProperty) FromMessageSubscriptionTypeFilterProperty0(v MessageSubscriptionTypeFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageSubscriptionTypeFilterProperty0 performs a merge with any union data inside the MessageSubscriptionTypeFilterProperty, using the provided MessageSubscriptionTypeFilterProperty0
func (t *MessageSubscriptionTypeFilterProperty) MergeMessageSubscriptionTypeFilterProperty0(v MessageSubscriptionTypeFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedMessageSubscriptionTypeFilter returns the union data inside the MessageSubscriptionTypeFilterProperty as a AdvancedMessageSubscriptionTypeFilter
func (t MessageSubscriptionTypeFilterProperty) AsAdvancedMessageSubscriptionTypeFilter() (AdvancedMessageSubscriptionTypeFilter, error) {
	var body AdvancedMessageSubscriptionTypeFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedMessageSubscriptionTypeFilter overwrites any union data inside the MessageSubscriptionTypeFilterProperty as the provided AdvancedMessageSubscriptionTypeFilter
func (t *MessageSubscriptionTypeFilterProperty) FromAdvancedMessageSubscriptionTypeFilter(v AdvancedMessageSubscriptionTypeFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedMessageSubscriptionTypeFilter performs a merge with any union data inside the MessageSubscriptionTypeFilterProperty, using the provided AdvancedMessageSubscriptionTypeFilter
func (t *MessageSubscriptionTypeFilterProperty) MergeAdvancedMessageSubscriptionTypeFilter(v AdvancedMessageSubscriptionTypeFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessageSubscriptionTypeFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessageSubscriptionTypeFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCommandOperation returns the union data inside the OperationMetadata as a CommandOperation
func (t OperationMetadata) AsCommandOperation() (CommandOperation, error) {
	var body CommandOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommandOperation overwrites any union data inside the OperationMetadata as the provided CommandOperation
func (t *OperationMetadata) FromCommandOperation(v CommandOperation) error {
	v.Kind = "CommandOperation"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommandOperation performs a merge with any union data inside the OperationMetadata, using the provided CommandOperation
func (t *OperationMetadata) MergeCommandOperation(v CommandOperation) error {
	v.Kind = "CommandOperation"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQueryOperation returns the union data inside the OperationMetadata as a QueryOperation
func (t OperationMetadata) AsQueryOperation() (QueryOperation, error) {
	var body QueryOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQueryOperation overwrites any union data inside the OperationMetadata as the provided QueryOperation
func (t *OperationMetadata) FromQueryOperation(v QueryOperation) error {
	v.Kind = "QueryOperation"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQueryOperation performs a merge with any union data inside the OperationMetadata, using the provided QueryOperation
func (t *OperationMetadata) MergeQueryOperation(v QueryOperation) error {
	v.Kind = "QueryOperation"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateOperation returns the union data inside the OperationMetadata as a CreateOperation
func (t OperationMetadata) AsCreateOperation() (CreateOperation, error) {
	var body CreateOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateOperation overwrites any union data inside the OperationMetadata as the provided CreateOperation
func (t *OperationMetadata) FromCreateOperation(v CreateOperation) error {
	v.Kind = "CreateOperation"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateOperation performs a merge with any union data inside the OperationMetadata, using the provided CreateOperation
func (t *OperationMetadata) MergeCreateOperation(v CreateOperation) error {
	v.Kind = "CreateOperation"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPatchOperation returns the union data inside the OperationMetadata as a PatchOperation
func (t OperationMetadata) AsPatchOperation() (PatchOperation, error) {
	var body PatchOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPatchOperation overwrites any union data inside the OperationMetadata as the provided PatchOperation
func (t *OperationMetadata) FromPatchOperation(v PatchOperation) error {
	v.Kind = "PatchOperation"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePatchOperation performs a merge with any union data inside the OperationMetadata, using the provided PatchOperation
func (t *OperationMetadata) MergePatchOperation(v PatchOperation) error {
	v.Kind = "PatchOperation"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeleteOperation returns the union data inside the OperationMetadata as a DeleteOperation
func (t OperationMetadata) AsDeleteOperation() (DeleteOperation, error) {
	var body DeleteOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeleteOperation overwrites any union data inside the OperationMetadata as the provided DeleteOperation
func (t *OperationMetadata) FromDeleteOperation(v DeleteOperation) error {
	v.Kind = "DeleteOperation"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeleteOperation performs a merge with any union data inside the OperationMetadata, using the provided DeleteOperation
func (t *OperationMetadata) MergeDeleteOperation(v DeleteOperation) error {
	v.Kind = "DeleteOperation"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEventOperation returns the union data inside the OperationMetadata as a EventOperation
func (t OperationMetadata) AsEventOperation() (EventOperation, error) {
	var body EventOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEventOperation overwrites any union data inside the OperationMetadata as the provided EventOperation
func (t *OperationMetadata) FromEventOperation(v EventOperation) error {
	v.Kind = "EventOperation"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEventOperation performs a merge with any union data inside the OperationMetadata, using the provided EventOperation
func (t *OperationMetadata) MergeEventOperation(v EventOperation) error {
	v.Kind = "EventOperation"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOperation returns the union data inside the OperationMetadata as a UpdateOperation
func (t OperationMetadata) AsUpdateOperation() (UpdateOperation, error) {
	var body UpdateOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOperation overwrites any union data inside the OperationMetadata as the provided UpdateOperation
func (t *OperationMetadata) FromUpdateOperation(v UpdateOperation) error {
	v.Kind = "UpdateOperation"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOperation performs a merge with any union data inside the OperationMetadata, using the provided UpdateOperation
func (t *OperationMetadata) MergeUpdateOperation(v UpdateOperation) error {
	v.Kind = "UpdateOperation"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBatchCommandOperation returns the union data inside the OperationMetadata as a BatchCommandOperation
func (t OperationMetadata) AsBatchCommandOperation() (BatchCommandOperation, error) {
	var body BatchCommandOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchCommandOperation overwrites any union data inside the OperationMetadata as the provided BatchCommandOperation
func (t *OperationMetadata) FromBatchCommandOperation(v BatchCommandOperation) error {
	v.Kind = "BatchCommandOperation"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchCommandOperation performs a merge with any union data inside the OperationMetadata, using the provided BatchCommandOperation
func (t *OperationMetadata) MergeBatchCommandOperation(v BatchCommandOperation) error {
	v.Kind = "BatchCommandOperation"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OperationMetadata) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OperationMetadata) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BatchCommandOperation":
		return t.AsBatchCommandOperation()
	case "CommandOperation":
		return t.AsCommandOperation()
	case "CreateOperation":
		return t.AsCreateOperation()
	case "DeleteOperation":
		return t.AsDeleteOperation()
	case "EventOperation":
		return t.AsEventOperation()
	case "PatchOperation":
		return t.AsPatchOperation()
	case "QueryOperation":
		return t.AsQueryOperation()
	case "UpdateOperation":
		return t.AsUpdateOperation()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OperationMetadata) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OperationMetadata) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsElementInstanceKey returns the union data inside the ProcessDefinitionStatisticsFilter_ParentElementInstanceKey as a ElementInstanceKey
func (t ProcessDefinitionStatisticsFilter_ParentElementInstanceKey) AsElementInstanceKey() (ElementInstanceKey, error) {
	var body ElementInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceKey overwrites any union data inside the ProcessDefinitionStatisticsFilter_ParentElementInstanceKey as the provided ElementInstanceKey
func (t *ProcessDefinitionStatisticsFilter_ParentElementInstanceKey) FromElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceKey performs a merge with any union data inside the ProcessDefinitionStatisticsFilter_ParentElementInstanceKey, using the provided ElementInstanceKey
func (t *ProcessDefinitionStatisticsFilter_ParentElementInstanceKey) MergeElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedElementInstanceKeyFilter returns the union data inside the ProcessDefinitionStatisticsFilter_ParentElementInstanceKey as a AdvancedElementInstanceKeyFilter
func (t ProcessDefinitionStatisticsFilter_ParentElementInstanceKey) AsAdvancedElementInstanceKeyFilter() (AdvancedElementInstanceKeyFilter, error) {
	var body AdvancedElementInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedElementInstanceKeyFilter overwrites any union data inside the ProcessDefinitionStatisticsFilter_ParentElementInstanceKey as the provided AdvancedElementInstanceKeyFilter
func (t *ProcessDefinitionStatisticsFilter_ParentElementInstanceKey) FromAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedElementInstanceKeyFilter performs a merge with any union data inside the ProcessDefinitionStatisticsFilter_ParentElementInstanceKey, using the provided AdvancedElementInstanceKeyFilter
func (t *ProcessDefinitionStatisticsFilter_ParentElementInstanceKey) MergeAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessDefinitionStatisticsFilter_ParentElementInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessDefinitionStatisticsFilter_ParentElementInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceKey returns the union data inside the ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey as a ProcessInstanceKey
func (t ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey) AsProcessInstanceKey() (ProcessInstanceKey, error) {
	var body ProcessInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKey overwrites any union data inside the ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey as the provided ProcessInstanceKey
func (t *ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey) FromProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKey performs a merge with any union data inside the ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey, using the provided ProcessInstanceKey
func (t *ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey) MergeProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceKeyFilter returns the union data inside the ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey as a AdvancedProcessInstanceKeyFilter
func (t ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey) AsAdvancedProcessInstanceKeyFilter() (AdvancedProcessInstanceKeyFilter, error) {
	var body AdvancedProcessInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceKeyFilter overwrites any union data inside the ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey as the provided AdvancedProcessInstanceKeyFilter
func (t *ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey) FromAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceKeyFilter performs a merge with any union data inside the ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey, using the provided AdvancedProcessInstanceKeyFilter
func (t *ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey) MergeAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessDefinitionStatisticsFilter_ParentProcessInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceKey returns the union data inside the ProcessDefinitionStatisticsFilter_ProcessInstanceKey as a ProcessInstanceKey
func (t ProcessDefinitionStatisticsFilter_ProcessInstanceKey) AsProcessInstanceKey() (ProcessInstanceKey, error) {
	var body ProcessInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKey overwrites any union data inside the ProcessDefinitionStatisticsFilter_ProcessInstanceKey as the provided ProcessInstanceKey
func (t *ProcessDefinitionStatisticsFilter_ProcessInstanceKey) FromProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKey performs a merge with any union data inside the ProcessDefinitionStatisticsFilter_ProcessInstanceKey, using the provided ProcessInstanceKey
func (t *ProcessDefinitionStatisticsFilter_ProcessInstanceKey) MergeProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceKeyFilter returns the union data inside the ProcessDefinitionStatisticsFilter_ProcessInstanceKey as a AdvancedProcessInstanceKeyFilter
func (t ProcessDefinitionStatisticsFilter_ProcessInstanceKey) AsAdvancedProcessInstanceKeyFilter() (AdvancedProcessInstanceKeyFilter, error) {
	var body AdvancedProcessInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceKeyFilter overwrites any union data inside the ProcessDefinitionStatisticsFilter_ProcessInstanceKey as the provided AdvancedProcessInstanceKeyFilter
func (t *ProcessDefinitionStatisticsFilter_ProcessInstanceKey) FromAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceKeyFilter performs a merge with any union data inside the ProcessDefinitionStatisticsFilter_ProcessInstanceKey, using the provided AdvancedProcessInstanceKeyFilter
func (t *ProcessDefinitionStatisticsFilter_ProcessInstanceKey) MergeAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessDefinitionStatisticsFilter_ProcessInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessDefinitionStatisticsFilter_ProcessInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceCreationInstructionById returns the union data inside the ProcessInstanceCreationInstruction as a ProcessInstanceCreationInstructionById
func (t ProcessInstanceCreationInstruction) AsProcessInstanceCreationInstructionById() (ProcessInstanceCreationInstructionById, error) {
	var body ProcessInstanceCreationInstructionById
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceCreationInstructionById overwrites any union data inside the ProcessInstanceCreationInstruction as the provided ProcessInstanceCreationInstructionById
func (t *ProcessInstanceCreationInstruction) FromProcessInstanceCreationInstructionById(v ProcessInstanceCreationInstructionById) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceCreationInstructionById performs a merge with any union data inside the ProcessInstanceCreationInstruction, using the provided ProcessInstanceCreationInstructionById
func (t *ProcessInstanceCreationInstruction) MergeProcessInstanceCreationInstructionById(v ProcessInstanceCreationInstructionById) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProcessInstanceCreationInstructionByKey returns the union data inside the ProcessInstanceCreationInstruction as a ProcessInstanceCreationInstructionByKey
func (t ProcessInstanceCreationInstruction) AsProcessInstanceCreationInstructionByKey() (ProcessInstanceCreationInstructionByKey, error) {
	var body ProcessInstanceCreationInstructionByKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceCreationInstructionByKey overwrites any union data inside the ProcessInstanceCreationInstruction as the provided ProcessInstanceCreationInstructionByKey
func (t *ProcessInstanceCreationInstruction) FromProcessInstanceCreationInstructionByKey(v ProcessInstanceCreationInstructionByKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceCreationInstructionByKey performs a merge with any union data inside the ProcessInstanceCreationInstruction, using the provided ProcessInstanceCreationInstructionByKey
func (t *ProcessInstanceCreationInstruction) MergeProcessInstanceCreationInstructionByKey(v ProcessInstanceCreationInstructionByKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceCreationInstruction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceCreationInstruction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceCreationTerminateInstruction returns the union data inside the ProcessInstanceCreationInstructionById_RuntimeInstructions_Item as a ProcessInstanceCreationTerminateInstruction
func (t ProcessInstanceCreationInstructionById_RuntimeInstructions_Item) AsProcessInstanceCreationTerminateInstruction() (ProcessInstanceCreationTerminateInstruction, error) {
	var body ProcessInstanceCreationTerminateInstruction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceCreationTerminateInstruction overwrites any union data inside the ProcessInstanceCreationInstructionById_RuntimeInstructions_Item as the provided ProcessInstanceCreationTerminateInstruction
func (t *ProcessInstanceCreationInstructionById_RuntimeInstructions_Item) FromProcessInstanceCreationTerminateInstruction(v ProcessInstanceCreationTerminateInstruction) error {
	v.Type = "TERMINATE_PROCESS_INSTANCE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceCreationTerminateInstruction performs a merge with any union data inside the ProcessInstanceCreationInstructionById_RuntimeInstructions_Item, using the provided ProcessInstanceCreationTerminateInstruction
func (t *ProcessInstanceCreationInstructionById_RuntimeInstructions_Item) MergeProcessInstanceCreationTerminateInstruction(v ProcessInstanceCreationTerminateInstruction) error {
	v.Type = "TERMINATE_PROCESS_INSTANCE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceCreationInstructionById_RuntimeInstructions_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ProcessInstanceCreationInstructionById_RuntimeInstructions_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "TERMINATE_PROCESS_INSTANCE":
		return t.AsProcessInstanceCreationTerminateInstruction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ProcessInstanceCreationInstructionById_RuntimeInstructions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceCreationInstructionById_RuntimeInstructions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceCreationTerminateInstruction returns the union data inside the ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item as a ProcessInstanceCreationTerminateInstruction
func (t ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item) AsProcessInstanceCreationTerminateInstruction() (ProcessInstanceCreationTerminateInstruction, error) {
	var body ProcessInstanceCreationTerminateInstruction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceCreationTerminateInstruction overwrites any union data inside the ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item as the provided ProcessInstanceCreationTerminateInstruction
func (t *ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item) FromProcessInstanceCreationTerminateInstruction(v ProcessInstanceCreationTerminateInstruction) error {
	v.Type = "TERMINATE_PROCESS_INSTANCE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceCreationTerminateInstruction performs a merge with any union data inside the ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item, using the provided ProcessInstanceCreationTerminateInstruction
func (t *ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item) MergeProcessInstanceCreationTerminateInstruction(v ProcessInstanceCreationTerminateInstruction) error {
	v.Type = "TERMINATE_PROCESS_INSTANCE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "TERMINATE_PROCESS_INSTANCE":
		return t.AsProcessInstanceCreationTerminateInstruction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceCreationInstructionByKey_RuntimeInstructions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsElementInstanceKey returns the union data inside the ProcessInstanceFilter_ParentElementInstanceKey as a ElementInstanceKey
func (t ProcessInstanceFilter_ParentElementInstanceKey) AsElementInstanceKey() (ElementInstanceKey, error) {
	var body ElementInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceKey overwrites any union data inside the ProcessInstanceFilter_ParentElementInstanceKey as the provided ElementInstanceKey
func (t *ProcessInstanceFilter_ParentElementInstanceKey) FromElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceKey performs a merge with any union data inside the ProcessInstanceFilter_ParentElementInstanceKey, using the provided ElementInstanceKey
func (t *ProcessInstanceFilter_ParentElementInstanceKey) MergeElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedElementInstanceKeyFilter returns the union data inside the ProcessInstanceFilter_ParentElementInstanceKey as a AdvancedElementInstanceKeyFilter
func (t ProcessInstanceFilter_ParentElementInstanceKey) AsAdvancedElementInstanceKeyFilter() (AdvancedElementInstanceKeyFilter, error) {
	var body AdvancedElementInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedElementInstanceKeyFilter overwrites any union data inside the ProcessInstanceFilter_ParentElementInstanceKey as the provided AdvancedElementInstanceKeyFilter
func (t *ProcessInstanceFilter_ParentElementInstanceKey) FromAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedElementInstanceKeyFilter performs a merge with any union data inside the ProcessInstanceFilter_ParentElementInstanceKey, using the provided AdvancedElementInstanceKeyFilter
func (t *ProcessInstanceFilter_ParentElementInstanceKey) MergeAdvancedElementInstanceKeyFilter(v AdvancedElementInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceFilter_ParentElementInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceFilter_ParentElementInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceKey returns the union data inside the ProcessInstanceFilter_ParentProcessInstanceKey as a ProcessInstanceKey
func (t ProcessInstanceFilter_ParentProcessInstanceKey) AsProcessInstanceKey() (ProcessInstanceKey, error) {
	var body ProcessInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKey overwrites any union data inside the ProcessInstanceFilter_ParentProcessInstanceKey as the provided ProcessInstanceKey
func (t *ProcessInstanceFilter_ParentProcessInstanceKey) FromProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKey performs a merge with any union data inside the ProcessInstanceFilter_ParentProcessInstanceKey, using the provided ProcessInstanceKey
func (t *ProcessInstanceFilter_ParentProcessInstanceKey) MergeProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceKeyFilter returns the union data inside the ProcessInstanceFilter_ParentProcessInstanceKey as a AdvancedProcessInstanceKeyFilter
func (t ProcessInstanceFilter_ParentProcessInstanceKey) AsAdvancedProcessInstanceKeyFilter() (AdvancedProcessInstanceKeyFilter, error) {
	var body AdvancedProcessInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceKeyFilter overwrites any union data inside the ProcessInstanceFilter_ParentProcessInstanceKey as the provided AdvancedProcessInstanceKeyFilter
func (t *ProcessInstanceFilter_ParentProcessInstanceKey) FromAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceKeyFilter performs a merge with any union data inside the ProcessInstanceFilter_ParentProcessInstanceKey, using the provided AdvancedProcessInstanceKeyFilter
func (t *ProcessInstanceFilter_ParentProcessInstanceKey) MergeAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceFilter_ParentProcessInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceFilter_ParentProcessInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceKey returns the union data inside the ProcessInstanceFilter_ProcessInstanceKey as a ProcessInstanceKey
func (t ProcessInstanceFilter_ProcessInstanceKey) AsProcessInstanceKey() (ProcessInstanceKey, error) {
	var body ProcessInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKey overwrites any union data inside the ProcessInstanceFilter_ProcessInstanceKey as the provided ProcessInstanceKey
func (t *ProcessInstanceFilter_ProcessInstanceKey) FromProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKey performs a merge with any union data inside the ProcessInstanceFilter_ProcessInstanceKey, using the provided ProcessInstanceKey
func (t *ProcessInstanceFilter_ProcessInstanceKey) MergeProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceKeyFilter returns the union data inside the ProcessInstanceFilter_ProcessInstanceKey as a AdvancedProcessInstanceKeyFilter
func (t ProcessInstanceFilter_ProcessInstanceKey) AsAdvancedProcessInstanceKeyFilter() (AdvancedProcessInstanceKeyFilter, error) {
	var body AdvancedProcessInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceKeyFilter overwrites any union data inside the ProcessInstanceFilter_ProcessInstanceKey as the provided AdvancedProcessInstanceKeyFilter
func (t *ProcessInstanceFilter_ProcessInstanceKey) FromAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceKeyFilter performs a merge with any union data inside the ProcessInstanceFilter_ProcessInstanceKey, using the provided AdvancedProcessInstanceKeyFilter
func (t *ProcessInstanceFilter_ProcessInstanceKey) MergeAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceFilter_ProcessInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceFilter_ProcessInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0 returns the union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey as a ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0
func (t ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) AsProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0() (ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0, error) {
	var body ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0 overwrites any union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey as the provided ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0
func (t *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) FromProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0(v ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0 performs a merge with any union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey, using the provided ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0
func (t *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) MergeProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0(v ProcessInstanceModificationActivateInstructionAncestorElementInstanceKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElementInstanceKey returns the union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey as a ElementInstanceKey
func (t ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) AsElementInstanceKey() (ElementInstanceKey, error) {
	var body ElementInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElementInstanceKey overwrites any union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey as the provided ElementInstanceKey
func (t *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) FromElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElementInstanceKey performs a merge with any union data inside the ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey, using the provided ElementInstanceKey
func (t *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) MergeElementInstanceKey(v ElementInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceModificationActivateInstruction_AncestorElementInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceStateFilterProperty0 returns the union data inside the ProcessInstanceStateFilterProperty as a ProcessInstanceStateFilterProperty0
func (t ProcessInstanceStateFilterProperty) AsProcessInstanceStateFilterProperty0() (ProcessInstanceStateFilterProperty0, error) {
	var body ProcessInstanceStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceStateFilterProperty0 overwrites any union data inside the ProcessInstanceStateFilterProperty as the provided ProcessInstanceStateFilterProperty0
func (t *ProcessInstanceStateFilterProperty) FromProcessInstanceStateFilterProperty0(v ProcessInstanceStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceStateFilterProperty0 performs a merge with any union data inside the ProcessInstanceStateFilterProperty, using the provided ProcessInstanceStateFilterProperty0
func (t *ProcessInstanceStateFilterProperty) MergeProcessInstanceStateFilterProperty0(v ProcessInstanceStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceStateFilter returns the union data inside the ProcessInstanceStateFilterProperty as a AdvancedProcessInstanceStateFilter
func (t ProcessInstanceStateFilterProperty) AsAdvancedProcessInstanceStateFilter() (AdvancedProcessInstanceStateFilter, error) {
	var body AdvancedProcessInstanceStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceStateFilter overwrites any union data inside the ProcessInstanceStateFilterProperty as the provided AdvancedProcessInstanceStateFilter
func (t *ProcessInstanceStateFilterProperty) FromAdvancedProcessInstanceStateFilter(v AdvancedProcessInstanceStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceStateFilter performs a merge with any union data inside the ProcessInstanceStateFilterProperty, using the provided AdvancedProcessInstanceStateFilter
func (t *ProcessInstanceStateFilterProperty) MergeAdvancedProcessInstanceStateFilter(v AdvancedProcessInstanceStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProcessInstanceStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProcessInstanceStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessDefinitionKey returns the union data inside the ResourceKey as a ProcessDefinitionKey
func (t ResourceKey) AsProcessDefinitionKey() (ProcessDefinitionKey, error) {
	var body ProcessDefinitionKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessDefinitionKey overwrites any union data inside the ResourceKey as the provided ProcessDefinitionKey
func (t *ResourceKey) FromProcessDefinitionKey(v ProcessDefinitionKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessDefinitionKey performs a merge with any union data inside the ResourceKey, using the provided ProcessDefinitionKey
func (t *ResourceKey) MergeProcessDefinitionKey(v ProcessDefinitionKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDecisionRequirementsKey returns the union data inside the ResourceKey as a DecisionRequirementsKey
func (t ResourceKey) AsDecisionRequirementsKey() (DecisionRequirementsKey, error) {
	var body DecisionRequirementsKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDecisionRequirementsKey overwrites any union data inside the ResourceKey as the provided DecisionRequirementsKey
func (t *ResourceKey) FromDecisionRequirementsKey(v DecisionRequirementsKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDecisionRequirementsKey performs a merge with any union data inside the ResourceKey, using the provided DecisionRequirementsKey
func (t *ResourceKey) MergeDecisionRequirementsKey(v DecisionRequirementsKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormKey returns the union data inside the ResourceKey as a FormKey
func (t ResourceKey) AsFormKey() (FormKey, error) {
	var body FormKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormKey overwrites any union data inside the ResourceKey as the provided FormKey
func (t *ResourceKey) FromFormKey(v FormKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormKey performs a merge with any union data inside the ResourceKey, using the provided FormKey
func (t *ResourceKey) MergeFormKey(v FormKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDecisionDefinitionKey returns the union data inside the ResourceKey as a DecisionDefinitionKey
func (t ResourceKey) AsDecisionDefinitionKey() (DecisionDefinitionKey, error) {
	var body DecisionDefinitionKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDecisionDefinitionKey overwrites any union data inside the ResourceKey as the provided DecisionDefinitionKey
func (t *ResourceKey) FromDecisionDefinitionKey(v DecisionDefinitionKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDecisionDefinitionKey performs a merge with any union data inside the ResourceKey, using the provided DecisionDefinitionKey
func (t *ResourceKey) MergeDecisionDefinitionKey(v DecisionDefinitionKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResourceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResourceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOffsetPagination returns the union data inside the SearchQueryPageRequest as a OffsetPagination
func (t SearchQueryPageRequest) AsOffsetPagination() (OffsetPagination, error) {
	var body OffsetPagination
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOffsetPagination overwrites any union data inside the SearchQueryPageRequest as the provided OffsetPagination
func (t *SearchQueryPageRequest) FromOffsetPagination(v OffsetPagination) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOffsetPagination performs a merge with any union data inside the SearchQueryPageRequest, using the provided OffsetPagination
func (t *SearchQueryPageRequest) MergeOffsetPagination(v OffsetPagination) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCursorForwardPagination returns the union data inside the SearchQueryPageRequest as a CursorForwardPagination
func (t SearchQueryPageRequest) AsCursorForwardPagination() (CursorForwardPagination, error) {
	var body CursorForwardPagination
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCursorForwardPagination overwrites any union data inside the SearchQueryPageRequest as the provided CursorForwardPagination
func (t *SearchQueryPageRequest) FromCursorForwardPagination(v CursorForwardPagination) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCursorForwardPagination performs a merge with any union data inside the SearchQueryPageRequest, using the provided CursorForwardPagination
func (t *SearchQueryPageRequest) MergeCursorForwardPagination(v CursorForwardPagination) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCursorBackwardPagination returns the union data inside the SearchQueryPageRequest as a CursorBackwardPagination
func (t SearchQueryPageRequest) AsCursorBackwardPagination() (CursorBackwardPagination, error) {
	var body CursorBackwardPagination
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCursorBackwardPagination overwrites any union data inside the SearchQueryPageRequest as the provided CursorBackwardPagination
func (t *SearchQueryPageRequest) FromCursorBackwardPagination(v CursorBackwardPagination) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCursorBackwardPagination performs a merge with any union data inside the SearchQueryPageRequest, using the provided CursorBackwardPagination
func (t *SearchQueryPageRequest) MergeCursorBackwardPagination(v CursorBackwardPagination) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SearchQueryPageRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchQueryPageRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStringFilterProperty0 returns the union data inside the StringFilterProperty as a StringFilterProperty0
func (t StringFilterProperty) AsStringFilterProperty0() (StringFilterProperty0, error) {
	var body StringFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFilterProperty0 overwrites any union data inside the StringFilterProperty as the provided StringFilterProperty0
func (t *StringFilterProperty) FromStringFilterProperty0(v StringFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFilterProperty0 performs a merge with any union data inside the StringFilterProperty, using the provided StringFilterProperty0
func (t *StringFilterProperty) MergeStringFilterProperty0(v StringFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedStringFilter returns the union data inside the StringFilterProperty as a AdvancedStringFilter
func (t StringFilterProperty) AsAdvancedStringFilter() (AdvancedStringFilter, error) {
	var body AdvancedStringFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedStringFilter overwrites any union data inside the StringFilterProperty as the provided AdvancedStringFilter
func (t *StringFilterProperty) FromAdvancedStringFilter(v AdvancedStringFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedStringFilter performs a merge with any union data inside the StringFilterProperty, using the provided AdvancedStringFilter
func (t *StringFilterProperty) MergeAdvancedStringFilter(v AdvancedStringFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StringFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StringFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUserTaskStateFilterProperty0 returns the union data inside the UserTaskStateFilterProperty as a UserTaskStateFilterProperty0
func (t UserTaskStateFilterProperty) AsUserTaskStateFilterProperty0() (UserTaskStateFilterProperty0, error) {
	var body UserTaskStateFilterProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserTaskStateFilterProperty0 overwrites any union data inside the UserTaskStateFilterProperty as the provided UserTaskStateFilterProperty0
func (t *UserTaskStateFilterProperty) FromUserTaskStateFilterProperty0(v UserTaskStateFilterProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserTaskStateFilterProperty0 performs a merge with any union data inside the UserTaskStateFilterProperty, using the provided UserTaskStateFilterProperty0
func (t *UserTaskStateFilterProperty) MergeUserTaskStateFilterProperty0(v UserTaskStateFilterProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedUserTaskStateFilter returns the union data inside the UserTaskStateFilterProperty as a AdvancedUserTaskStateFilter
func (t UserTaskStateFilterProperty) AsAdvancedUserTaskStateFilter() (AdvancedUserTaskStateFilter, error) {
	var body AdvancedUserTaskStateFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedUserTaskStateFilter overwrites any union data inside the UserTaskStateFilterProperty as the provided AdvancedUserTaskStateFilter
func (t *UserTaskStateFilterProperty) FromAdvancedUserTaskStateFilter(v AdvancedUserTaskStateFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedUserTaskStateFilter performs a merge with any union data inside the UserTaskStateFilterProperty, using the provided AdvancedUserTaskStateFilter
func (t *UserTaskStateFilterProperty) MergeAdvancedUserTaskStateFilter(v AdvancedUserTaskStateFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UserTaskStateFilterProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UserTaskStateFilterProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProcessInstanceKey returns the union data inside the VariableFilter_ProcessInstanceKey as a ProcessInstanceKey
func (t VariableFilter_ProcessInstanceKey) AsProcessInstanceKey() (ProcessInstanceKey, error) {
	var body ProcessInstanceKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessInstanceKey overwrites any union data inside the VariableFilter_ProcessInstanceKey as the provided ProcessInstanceKey
func (t *VariableFilter_ProcessInstanceKey) FromProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessInstanceKey performs a merge with any union data inside the VariableFilter_ProcessInstanceKey, using the provided ProcessInstanceKey
func (t *VariableFilter_ProcessInstanceKey) MergeProcessInstanceKey(v ProcessInstanceKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedProcessInstanceKeyFilter returns the union data inside the VariableFilter_ProcessInstanceKey as a AdvancedProcessInstanceKeyFilter
func (t VariableFilter_ProcessInstanceKey) AsAdvancedProcessInstanceKeyFilter() (AdvancedProcessInstanceKeyFilter, error) {
	var body AdvancedProcessInstanceKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedProcessInstanceKeyFilter overwrites any union data inside the VariableFilter_ProcessInstanceKey as the provided AdvancedProcessInstanceKeyFilter
func (t *VariableFilter_ProcessInstanceKey) FromAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedProcessInstanceKeyFilter performs a merge with any union data inside the VariableFilter_ProcessInstanceKey, using the provided AdvancedProcessInstanceKeyFilter
func (t *VariableFilter_ProcessInstanceKey) MergeAdvancedProcessInstanceKeyFilter(v AdvancedProcessInstanceKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VariableFilter_ProcessInstanceKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VariableFilter_ProcessInstanceKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScopeKey returns the union data inside the VariableFilter_ScopeKey as a ScopeKey
func (t VariableFilter_ScopeKey) AsScopeKey() (ScopeKey, error) {
	var body ScopeKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScopeKey overwrites any union data inside the VariableFilter_ScopeKey as the provided ScopeKey
func (t *VariableFilter_ScopeKey) FromScopeKey(v ScopeKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScopeKey performs a merge with any union data inside the VariableFilter_ScopeKey, using the provided ScopeKey
func (t *VariableFilter_ScopeKey) MergeScopeKey(v ScopeKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedScopeKeyFilter returns the union data inside the VariableFilter_ScopeKey as a AdvancedScopeKeyFilter
func (t VariableFilter_ScopeKey) AsAdvancedScopeKeyFilter() (AdvancedScopeKeyFilter, error) {
	var body AdvancedScopeKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedScopeKeyFilter overwrites any union data inside the VariableFilter_ScopeKey as the provided AdvancedScopeKeyFilter
func (t *VariableFilter_ScopeKey) FromAdvancedScopeKeyFilter(v AdvancedScopeKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedScopeKeyFilter performs a merge with any union data inside the VariableFilter_ScopeKey, using the provided AdvancedScopeKeyFilter
func (t *VariableFilter_ScopeKey) MergeAdvancedScopeKeyFilter(v AdvancedScopeKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VariableFilter_ScopeKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VariableFilter_ScopeKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVariableKey returns the union data inside the VariableFilter_VariableKey as a VariableKey
func (t VariableFilter_VariableKey) AsVariableKey() (VariableKey, error) {
	var body VariableKey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVariableKey overwrites any union data inside the VariableFilter_VariableKey as the provided VariableKey
func (t *VariableFilter_VariableKey) FromVariableKey(v VariableKey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVariableKey performs a merge with any union data inside the VariableFilter_VariableKey, using the provided VariableKey
func (t *VariableFilter_VariableKey) MergeVariableKey(v VariableKey) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdvancedVariableKeyFilter returns the union data inside the VariableFilter_VariableKey as a AdvancedVariableKeyFilter
func (t VariableFilter_VariableKey) AsAdvancedVariableKeyFilter() (AdvancedVariableKeyFilter, error) {
	var body AdvancedVariableKeyFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdvancedVariableKeyFilter overwrites any union data inside the VariableFilter_VariableKey as the provided AdvancedVariableKeyFilter
func (t *VariableFilter_VariableKey) FromAdvancedVariableKeyFilter(v AdvancedVariableKeyFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdvancedVariableKeyFilter performs a merge with any union data inside the VariableFilter_VariableKey, using the provided AdvancedVariableKeyFilter
func (t *VariableFilter_VariableKey) MergeAdvancedVariableKeyFilter(v AdvancedVariableKeyFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VariableFilter_VariableKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VariableFilter_VariableKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuthorizationWithBody request with any body
	CreateAuthorizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAuthorization(ctx context.Context, body CreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchAuthorizationsWithBody request with any body
	SearchAuthorizationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchAuthorizations(ctx context.Context, body SearchAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthorization request
	DeleteAuthorization(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorization request
	GetAuthorization(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAuthorizationWithBody request with any body
	UpdateAuthorizationWithBody(ctx context.Context, authorizationKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAuthorization(ctx context.Context, authorizationKey string, body UpdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchBatchOperationItemsWithBody request with any body
	SearchBatchOperationItemsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchBatchOperationItems(ctx context.Context, body SearchBatchOperationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchBatchOperationsWithBody request with any body
	SearchBatchOperationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchBatchOperations(ctx context.Context, body SearchBatchOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatchOperation request
	GetBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelBatchOperationWithBody request with any body
	CancelBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body CancelBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeBatchOperationWithBody request with any body
	ResumeBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResumeBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body ResumeBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SuspendBatchOperationWithBody request with any body
	SuspendBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SuspendBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body SuspendBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PinInternalClockAlphaWithBody request with any body
	PinInternalClockAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PinInternalClockAlpha(ctx context.Context, body PinInternalClockAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetInternalClockAlpha request
	ResetInternalClockAlpha(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EvaluateDecisionWithBody request with any body
	EvaluateDecisionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EvaluateDecision(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDecisionDefinitionsWithBody request with any body
	SearchDecisionDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDecisionDefinitions(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionDefinition request
	GetDecisionDefinition(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionDefinitionXml request
	GetDecisionDefinitionXml(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDecisionInstancesWithBody request with any body
	SearchDecisionInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDecisionInstances(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionInstance request
	GetDecisionInstance(ctx context.Context, decisionEvaluationInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDecisionRequirementsWithBody request with any body
	SearchDecisionRequirementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDecisionRequirements(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionRequirements request
	GetDecisionRequirements(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionRequirementsXml request
	GetDecisionRequirementsXml(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeployResourcesWithBody request with any body
	DeployResourcesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadDocumentWithBody request with any body
	UploadDocumentWithBody(ctx context.Context, params *UploadDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadMultipleDocumentsWithBody request with any body
	UploadMultipleDocumentsWithBody(ctx context.Context, params *UploadMultipleDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDocument request
	DeleteDocument(ctx context.Context, documentId DocumentId, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadDocument request
	DownloadDocument(ctx context.Context, documentId DocumentId, params *DownloadDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDocumentLinkWithBody request with any body
	CreateDocumentLinkWithBody(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDocumentLink(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateActivitiesWithinAnAdHocSubProcessWithBody request with any body
	ActivateActivitiesWithinAnAdHocSubProcessWithBody(ctx context.Context, adHocSubProcessInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateActivitiesWithinAnAdHocSubProcess(ctx context.Context, adHocSubProcessInstanceKey string, body ActivateActivitiesWithinAnAdHocSubProcessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchElementInstancesWithBody request with any body
	SearchElementInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchElementInstances(ctx context.Context, body SearchElementInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetElementInstance request
	GetElementInstance(ctx context.Context, elementInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateElementInstanceVariablesWithBody request with any body
	UpdateElementInstanceVariablesWithBody(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateElementInstanceVariables(ctx context.Context, elementInstanceKey string, body UpdateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGroupsWithBody request with any body
	SearchGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchGroups(ctx context.Context, body SearchGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupWithBody request with any body
	UpdateGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroup(ctx context.Context, groupId string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGroupClientsWithBody request with any body
	SearchGroupClientsWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchGroupClients(ctx context.Context, groupId string, body SearchGroupClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignAClientFromAGroup request
	UnassignAClientFromAGroup(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignAClientToAGroup request
	AssignAClientToAGroup(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGroupMappingRulesWithBody request with any body
	SearchGroupMappingRulesWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchGroupMappingRules(ctx context.Context, groupId string, body SearchGroupMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignAMappingRuleFromAGroup request
	UnassignAMappingRuleFromAGroup(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignAMappingRuleToAGroup request
	AssignAMappingRuleToAGroup(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGroupRolesWithBody request with any body
	SearchGroupRolesWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchGroupRoles(ctx context.Context, groupId string, body SearchGroupRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGroupUsersWithBody request with any body
	SearchGroupUsersWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchGroupUsers(ctx context.Context, groupId string, body SearchGroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignAUserFromAGroup request
	UnassignAUserFromAGroup(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignAUserToAGroup request
	AssignAUserToAGroup(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchIncidentsWithBody request with any body
	SearchIncidentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchIncidents(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncident request
	GetIncident(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolveIncidentWithBody request with any body
	ResolveIncidentWithBody(ctx context.Context, incidentKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResolveIncident(ctx context.Context, incidentKey string, body ResolveIncidentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateJobsWithBody request with any body
	ActivateJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateJobs(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchJobsWithBody request with any body
	SearchJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchJobs(ctx context.Context, body SearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJobWithBody request with any body
	UpdateJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateJob(ctx context.Context, jobKey string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteJobWithBody request with any body
	CompleteJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompleteJob(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThrowErrorForJobWithBody request with any body
	ThrowErrorForJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ThrowErrorForJob(ctx context.Context, jobKey string, body ThrowErrorForJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FailJobWithBody request with any body
	FailJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FailJob(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicenseStatus request
	GetLicenseStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMappingRuleWithBody request with any body
	CreateMappingRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMappingRule(ctx context.Context, body CreateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMappingRulesWithBody request with any body
	SearchMappingRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchMappingRules(ctx context.Context, body SearchMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAMappingRule request
	DeleteAMappingRule(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAMappingRule request
	GetAMappingRule(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMappingRuleWithBody request with any body
	UpdateMappingRuleWithBody(ctx context.Context, mappingRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMappingRule(ctx context.Context, mappingRuleId string, body UpdateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMessageSubscriptionsWithBody request with any body
	SearchMessageSubscriptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchMessageSubscriptions(ctx context.Context, body SearchMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CorrelateMessageWithBody request with any body
	CorrelateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CorrelateMessage(ctx context.Context, body CorrelateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishMessageWithBody request with any body
	PublishMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublishMessage(ctx context.Context, body PublishMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchProcessDefinitionsWithBody request with any body
	SearchProcessDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchProcessDefinitions(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefinition request
	GetProcessDefinition(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessStartForm request
	GetProcessStartForm(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefinitionStatisticsWithBody request with any body
	GetProcessDefinitionStatisticsWithBody(ctx context.Context, processDefinitionKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetProcessDefinitionStatistics(ctx context.Context, processDefinitionKey string, body GetProcessDefinitionStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefinitionXml request
	GetProcessDefinitionXml(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProcessInstanceWithBody request with any body
	CreateProcessInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProcessInstance(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateABatchOperationToCancelProcessInstancesWithBody request with any body
	CreateABatchOperationToCancelProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateABatchOperationToCancelProcessInstances(ctx context.Context, body CreateABatchOperationToCancelProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateABatchOperationToResolveIncidentsOfProcessInstancesWithBody request with any body
	CreateABatchOperationToResolveIncidentsOfProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateABatchOperationToResolveIncidentsOfProcessInstances(ctx context.Context, body CreateABatchOperationToResolveIncidentsOfProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateABatchOperationToMigrateProcessInstancesWithBody request with any body
	CreateABatchOperationToMigrateProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateABatchOperationToMigrateProcessInstances(ctx context.Context, body CreateABatchOperationToMigrateProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateABatchOperationToModifyProcessInstancesWithBody request with any body
	CreateABatchOperationToModifyProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateABatchOperationToModifyProcessInstances(ctx context.Context, body CreateABatchOperationToModifyProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchProcessInstancesWithBody request with any body
	SearchProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchProcessInstances(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessInstance request
	GetProcessInstance(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCallHierarchyForProcessInstance request
	GetCallHierarchyForProcessInstance(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelProcessInstanceWithBody request with any body
	CancelProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelProcessInstance(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForIncidentsAssociatedWithAProcessInstanceWithBody request with any body
	SearchForIncidentsAssociatedWithAProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForIncidentsAssociatedWithAProcessInstance(ctx context.Context, processInstanceKey string, body SearchForIncidentsAssociatedWithAProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateProcessInstanceWithBody request with any body
	MigrateProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateProcessInstance(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyProcessInstanceWithBody request with any body
	ModifyProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyProcessInstance(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessInstanceSequenceFlows request
	GetProcessInstanceSequenceFlows(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessInstanceStatistics request
	GetProcessInstanceStatistics(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceContent request
	GetResourceContent(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResourceWithBody request with any body
	DeleteResourceWithBody(ctx context.Context, resourceKey ResourceKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteResource(ctx context.Context, resourceKey ResourceKey, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRoleWithBody request with any body
	CreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRole(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRolesWithBody request with any body
	SearchRolesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchRoles(ctx context.Context, body SearchRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleWithBody request with any body
	UpdateRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRole(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRoleClientsWithBody request with any body
	SearchRoleClientsWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchRoleClients(ctx context.Context, roleId string, body SearchRoleClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignARoleFromAClient request
	UnassignARoleFromAClient(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignARoleToAClient request
	AssignARoleToAClient(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRoleGroupsWithBody request with any body
	SearchRoleGroupsWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchRoleGroups(ctx context.Context, roleId string, body SearchRoleGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignARoleFromAGroup request
	UnassignARoleFromAGroup(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignARoleToAGroup request
	AssignARoleToAGroup(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRoleMappingRulesWithBody request with any body
	SearchRoleMappingRulesWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchRoleMappingRules(ctx context.Context, roleId string, body SearchRoleMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignARoleFromAMappingRule request
	UnassignARoleFromAMappingRule(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignARoleToAMappingRule request
	AssignARoleToAMappingRule(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRoleUsersWithBody request with any body
	SearchRoleUsersWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchRoleUsers(ctx context.Context, roleId string, body SearchRoleUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignARoleFromAUser request
	UnassignARoleFromAUser(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignARoleToAUser request
	AssignARoleToAUser(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAdminUserWithBody request with any body
	CreateAdminUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAdminUser(ctx context.Context, body CreateAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BroadcastSignalWithBody request with any body
	BroadcastSignalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BroadcastSignal(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterStatus request
	GetClusterStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageMetrics request
	GetUsageMetrics(ctx context.Context, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTenantWithBody request with any body
	CreateTenantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTenant(ctx context.Context, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTenantsWithBody request with any body
	SearchTenantsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchTenants(ctx context.Context, body SearchTenantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTenant request
	DeleteTenant(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenant request
	GetTenant(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTenantWithBody request with any body
	UpdateTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTenant(ctx context.Context, tenantId TenantId, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchClientsForTenantWithBody request with any body
	SearchClientsForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchClientsForTenant(ctx context.Context, tenantId TenantId, body SearchClientsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignAClientFromATenant request
	UnassignAClientFromATenant(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignAClientToATenant request
	AssignAClientToATenant(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGroupsForTenantWithBody request with any body
	SearchGroupsForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchGroupsForTenant(ctx context.Context, tenantId TenantId, body SearchGroupsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignAGroupFromATenant request
	UnassignAGroupFromATenant(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignAGroupToATenant request
	AssignAGroupToATenant(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMappingRulesForTenantWithBody request with any body
	SearchMappingRulesForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchMappingRulesForTenant(ctx context.Context, tenantId TenantId, body SearchMappingRulesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignAMappingRuleFromATenant request
	UnassignAMappingRuleFromATenant(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignAMappingRuleToATenant request
	AssignAMappingRuleToATenant(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRolesForTenantWithBody request with any body
	SearchRolesForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchRolesForTenant(ctx context.Context, tenantId TenantId, body SearchRolesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignARoleFromATenant request
	UnassignARoleFromATenant(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignARoleToATenant request
	AssignARoleToATenant(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUsersForTenantWithBody request with any body
	SearchUsersForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUsersForTenant(ctx context.Context, tenantId TenantId, body SearchUsersForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignAUserFromATenant request
	UnassignAUserFromATenant(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignAUserToATenant request
	AssignAUserToATenant(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterTopology request
	GetClusterTopology(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUserTasksWithBody request with any body
	SearchUserTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUserTasks(ctx context.Context, body SearchUserTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserTask request
	GetUserTask(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserTaskWithBody request with any body
	UpdateUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserTask(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignUserTask request
	UnassignUserTask(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignUserTaskWithBody request with any body
	AssignUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignUserTask(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteUserTaskWithBody request with any body
	CompleteUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompleteUserTask(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserTaskForm request
	GetUserTaskForm(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUserTaskVariablesWithBody request with any body
	SearchUserTaskVariablesWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUserTaskVariables(ctx context.Context, userTaskKey string, body SearchUserTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUsersWithBody request with any body
	SearchUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUsers(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, username Username, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchVariablesWithBody request with any body
	SearchVariablesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchVariables(ctx context.Context, body SearchVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariable request
	GetVariable(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthorizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthorizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthorization(ctx context.Context, body CreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthorizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchAuthorizationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchAuthorizationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchAuthorizations(ctx context.Context, body SearchAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchAuthorizationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthorization(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthorizationRequest(c.Server, authorizationKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorization(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorizationRequest(c.Server, authorizationKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAuthorizationWithBody(ctx context.Context, authorizationKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAuthorizationRequestWithBody(c.Server, authorizationKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAuthorization(ctx context.Context, authorizationKey string, body UpdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAuthorizationRequest(c.Server, authorizationKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchBatchOperationItemsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchBatchOperationItemsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchBatchOperationItems(ctx context.Context, body SearchBatchOperationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchBatchOperationItemsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchBatchOperationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchBatchOperationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchBatchOperations(ctx context.Context, body SearchBatchOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchBatchOperationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchOperationRequest(c.Server, batchOperationKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelBatchOperationRequestWithBody(c.Server, batchOperationKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body CancelBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelBatchOperationRequest(c.Server, batchOperationKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeBatchOperationRequestWithBody(c.Server, batchOperationKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body ResumeBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeBatchOperationRequest(c.Server, batchOperationKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendBatchOperationWithBody(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendBatchOperationRequestWithBody(c.Server, batchOperationKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendBatchOperation(ctx context.Context, batchOperationKey BatchOperationKey, body SuspendBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendBatchOperationRequest(c.Server, batchOperationKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PinInternalClockAlphaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPinInternalClockAlphaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PinInternalClockAlpha(ctx context.Context, body PinInternalClockAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPinInternalClockAlphaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetInternalClockAlpha(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetInternalClockAlphaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EvaluateDecisionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateDecisionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EvaluateDecision(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateDecisionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionDefinitionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionDefinitions(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionDefinitionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionDefinition(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionDefinitionRequest(c.Server, decisionDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionDefinitionXml(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionDefinitionXmlRequest(c.Server, decisionDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionInstances(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionInstance(ctx context.Context, decisionEvaluationInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionInstanceRequest(c.Server, decisionEvaluationInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionRequirementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionRequirementsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionRequirements(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionRequirementsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionRequirements(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionRequirementsRequest(c.Server, decisionRequirementsKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionRequirementsXml(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionRequirementsXmlRequest(c.Server, decisionRequirementsKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployResourcesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployResourcesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadDocumentWithBody(ctx context.Context, params *UploadDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadDocumentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadMultipleDocumentsWithBody(ctx context.Context, params *UploadMultipleDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadMultipleDocumentsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDocument(ctx context.Context, documentId DocumentId, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDocumentRequest(c.Server, documentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadDocument(ctx context.Context, documentId DocumentId, params *DownloadDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadDocumentRequest(c.Server, documentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocumentLinkWithBody(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDocumentLinkRequestWithBody(c.Server, documentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocumentLink(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDocumentLinkRequest(c.Server, documentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateActivitiesWithinAnAdHocSubProcessWithBody(ctx context.Context, adHocSubProcessInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateActivitiesWithinAnAdHocSubProcessRequestWithBody(c.Server, adHocSubProcessInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateActivitiesWithinAnAdHocSubProcess(ctx context.Context, adHocSubProcessInstanceKey string, body ActivateActivitiesWithinAnAdHocSubProcessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateActivitiesWithinAnAdHocSubProcessRequest(c.Server, adHocSubProcessInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchElementInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchElementInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchElementInstances(ctx context.Context, body SearchElementInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchElementInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetElementInstance(ctx context.Context, elementInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetElementInstanceRequest(c.Server, elementInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateElementInstanceVariablesWithBody(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateElementInstanceVariablesRequestWithBody(c.Server, elementInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateElementInstanceVariables(ctx context.Context, elementInstanceKey string, body UpdateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateElementInstanceVariablesRequest(c.Server, elementInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroups(ctx context.Context, body SearchGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroup(ctx context.Context, groupId string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupClientsWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupClientsRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupClients(ctx context.Context, groupId string, body SearchGroupClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupClientsRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignAClientFromAGroup(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignAClientFromAGroupRequest(c.Server, groupId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignAClientToAGroup(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignAClientToAGroupRequest(c.Server, groupId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupMappingRulesWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupMappingRulesRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupMappingRules(ctx context.Context, groupId string, body SearchGroupMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupMappingRulesRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignAMappingRuleFromAGroup(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignAMappingRuleFromAGroupRequest(c.Server, groupId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignAMappingRuleToAGroup(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignAMappingRuleToAGroupRequest(c.Server, groupId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupRolesWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupRolesRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupRoles(ctx context.Context, groupId string, body SearchGroupRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupRolesRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupUsersWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupUsersRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupUsers(ctx context.Context, groupId string, body SearchGroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupUsersRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignAUserFromAGroup(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignAUserFromAGroupRequest(c.Server, groupId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignAUserToAGroup(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignAUserToAGroupRequest(c.Server, groupId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchIncidentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchIncidentsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchIncidents(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchIncidentsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncident(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncidentRequest(c.Server, incidentKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveIncidentWithBody(ctx context.Context, incidentKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveIncidentRequestWithBody(c.Server, incidentKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveIncident(ctx context.Context, incidentKey string, body ResolveIncidentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveIncidentRequest(c.Server, incidentKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateJobs(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchJobs(ctx context.Context, body SearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJob(ctx context.Context, jobKey string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteJob(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThrowErrorForJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThrowErrorForJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThrowErrorForJob(ctx context.Context, jobKey string, body ThrowErrorForJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThrowErrorForJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FailJobWithBody(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFailJobRequestWithBody(c.Server, jobKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FailJob(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFailJobRequest(c.Server, jobKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicenseStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMappingRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMappingRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMappingRule(ctx context.Context, body CreateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMappingRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRulesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRules(ctx context.Context, body SearchMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRulesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAMappingRule(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAMappingRuleRequest(c.Server, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAMappingRule(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAMappingRuleRequest(c.Server, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMappingRuleWithBody(ctx context.Context, mappingRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMappingRuleRequestWithBody(c.Server, mappingRuleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMappingRule(ctx context.Context, mappingRuleId string, body UpdateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMappingRuleRequest(c.Server, mappingRuleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMessageSubscriptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMessageSubscriptionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMessageSubscriptions(ctx context.Context, body SearchMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMessageSubscriptionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CorrelateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCorrelateMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CorrelateMessage(ctx context.Context, body CorrelateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCorrelateMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishMessage(ctx context.Context, body PublishMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessDefinitionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessDefinitions(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessDefinitionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinition(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionRequest(c.Server, processDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessStartForm(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessStartFormRequest(c.Server, processDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinitionStatisticsWithBody(ctx context.Context, processDefinitionKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionStatisticsRequestWithBody(c.Server, processDefinitionKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinitionStatistics(ctx context.Context, processDefinitionKey string, body GetProcessDefinitionStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionStatisticsRequest(c.Server, processDefinitionKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinitionXml(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionXmlRequest(c.Server, processDefinitionKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProcessInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProcessInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProcessInstance(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProcessInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateABatchOperationToCancelProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateABatchOperationToCancelProcessInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateABatchOperationToCancelProcessInstances(ctx context.Context, body CreateABatchOperationToCancelProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateABatchOperationToCancelProcessInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateABatchOperationToResolveIncidentsOfProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateABatchOperationToResolveIncidentsOfProcessInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateABatchOperationToResolveIncidentsOfProcessInstances(ctx context.Context, body CreateABatchOperationToResolveIncidentsOfProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateABatchOperationToResolveIncidentsOfProcessInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateABatchOperationToMigrateProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateABatchOperationToMigrateProcessInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateABatchOperationToMigrateProcessInstances(ctx context.Context, body CreateABatchOperationToMigrateProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateABatchOperationToMigrateProcessInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateABatchOperationToModifyProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateABatchOperationToModifyProcessInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateABatchOperationToModifyProcessInstances(ctx context.Context, body CreateABatchOperationToModifyProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateABatchOperationToModifyProcessInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessInstances(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessInstance(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessInstanceRequest(c.Server, processInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCallHierarchyForProcessInstance(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCallHierarchyForProcessInstanceRequest(c.Server, processInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelProcessInstanceRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelProcessInstance(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelProcessInstanceRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForIncidentsAssociatedWithAProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForIncidentsAssociatedWithAProcessInstanceRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForIncidentsAssociatedWithAProcessInstance(ctx context.Context, processInstanceKey string, body SearchForIncidentsAssociatedWithAProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForIncidentsAssociatedWithAProcessInstanceRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateProcessInstanceRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateProcessInstance(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateProcessInstanceRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProcessInstanceWithBody(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProcessInstanceRequestWithBody(c.Server, processInstanceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProcessInstance(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProcessInstanceRequest(c.Server, processInstanceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessInstanceSequenceFlows(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessInstanceSequenceFlowsRequest(c.Server, processInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessInstanceStatistics(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessInstanceStatisticsRequest(c.Server, processInstanceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, resourceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceContent(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceContentRequest(c.Server, resourceKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourceWithBody(ctx context.Context, resourceKey ResourceKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequestWithBody(c.Server, resourceKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResource(ctx context.Context, resourceKey ResourceKey, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequest(c.Server, resourceKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRole(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRolesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRolesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRoles(ctx context.Context, body SearchRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRolesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleRequest(c.Server, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRole(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRoleClientsWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRoleClientsRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRoleClients(ctx context.Context, roleId string, body SearchRoleClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRoleClientsRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignARoleFromAClient(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignARoleFromAClientRequest(c.Server, roleId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignARoleToAClient(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignARoleToAClientRequest(c.Server, roleId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRoleGroupsWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRoleGroupsRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRoleGroups(ctx context.Context, roleId string, body SearchRoleGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRoleGroupsRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignARoleFromAGroup(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignARoleFromAGroupRequest(c.Server, roleId, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignARoleToAGroup(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignARoleToAGroupRequest(c.Server, roleId, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRoleMappingRulesWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRoleMappingRulesRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRoleMappingRules(ctx context.Context, roleId string, body SearchRoleMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRoleMappingRulesRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignARoleFromAMappingRule(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignARoleFromAMappingRuleRequest(c.Server, roleId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignARoleToAMappingRule(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignARoleToAMappingRuleRequest(c.Server, roleId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRoleUsersWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRoleUsersRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRoleUsers(ctx context.Context, roleId string, body SearchRoleUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRoleUsersRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignARoleFromAUser(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignARoleFromAUserRequest(c.Server, roleId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignARoleToAUser(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignARoleToAUserRequest(c.Server, roleId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminUser(ctx context.Context, body CreateAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BroadcastSignalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBroadcastSignalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BroadcastSignal(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBroadcastSignalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageMetrics(ctx context.Context, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenant(ctx context.Context, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTenantsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTenantsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTenants(ctx context.Context, body SearchTenantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTenantsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTenant(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTenantRequest(c.Server, tenantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenant(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantRequest(c.Server, tenantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTenant(ctx context.Context, tenantId TenantId, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClientsForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsForTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchClientsForTenant(ctx context.Context, tenantId TenantId, body SearchClientsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchClientsForTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignAClientFromATenant(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignAClientFromATenantRequest(c.Server, tenantId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignAClientToATenant(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignAClientToATenantRequest(c.Server, tenantId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupsForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupsForTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupsForTenant(ctx context.Context, tenantId TenantId, body SearchGroupsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupsForTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignAGroupFromATenant(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignAGroupFromATenantRequest(c.Server, tenantId, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignAGroupToATenant(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignAGroupToATenantRequest(c.Server, tenantId, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRulesForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRulesForTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMappingRulesForTenant(ctx context.Context, tenantId TenantId, body SearchMappingRulesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMappingRulesForTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignAMappingRuleFromATenant(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignAMappingRuleFromATenantRequest(c.Server, tenantId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignAMappingRuleToATenant(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignAMappingRuleToATenantRequest(c.Server, tenantId, mappingRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRolesForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRolesForTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRolesForTenant(ctx context.Context, tenantId TenantId, body SearchRolesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRolesForTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignARoleFromATenant(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignARoleFromATenantRequest(c.Server, tenantId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignARoleToATenant(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignARoleToATenantRequest(c.Server, tenantId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersForTenantWithBody(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersForTenantRequestWithBody(c.Server, tenantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersForTenant(ctx context.Context, tenantId TenantId, body SearchUsersForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersForTenantRequest(c.Server, tenantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignAUserFromATenant(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignAUserFromATenantRequest(c.Server, tenantId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignAUserToATenant(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignAUserToATenantRequest(c.Server, tenantId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterTopology(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterTopologyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUserTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUserTasksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUserTasks(ctx context.Context, body SearchUserTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUserTasksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserTask(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserTaskRequest(c.Server, userTaskKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserTaskRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserTask(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserTaskRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignUserTask(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignUserTaskRequest(c.Server, userTaskKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserTaskRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserTask(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserTaskRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteUserTaskWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteUserTaskRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteUserTask(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteUserTaskRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserTaskForm(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserTaskFormRequest(c.Server, userTaskKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUserTaskVariablesWithBody(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUserTaskVariablesRequestWithBody(c.Server, userTaskKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUserTaskVariables(ctx context.Context, userTaskKey string, body SearchUserTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUserTaskVariablesRequest(c.Server, userTaskKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsers(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, username, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, username Username, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, username, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchVariablesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchVariablesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchVariables(ctx context.Context, body SearchVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchVariablesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariable(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableRequest(c.Server, variableKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authentication/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAuthorizationRequest calls the generic CreateAuthorization builder with application/json body
func NewCreateAuthorizationRequest(server string, body CreateAuthorizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAuthorizationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAuthorizationRequestWithBody generates requests for CreateAuthorization with any type of body
func NewCreateAuthorizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchAuthorizationsRequest calls the generic SearchAuthorizations builder with application/json body
func NewSearchAuthorizationsRequest(server string, body SearchAuthorizationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchAuthorizationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchAuthorizationsRequestWithBody generates requests for SearchAuthorizations with any type of body
func NewSearchAuthorizationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAuthorizationRequest generates requests for DeleteAuthorization
func NewDeleteAuthorizationRequest(server string, authorizationKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorizationKey", runtime.ParamLocationPath, authorizationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthorizationRequest generates requests for GetAuthorization
func NewGetAuthorizationRequest(server string, authorizationKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorizationKey", runtime.ParamLocationPath, authorizationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAuthorizationRequest calls the generic UpdateAuthorization builder with application/json body
func NewUpdateAuthorizationRequest(server string, authorizationKey string, body UpdateAuthorizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAuthorizationRequestWithBody(server, authorizationKey, "application/json", bodyReader)
}

// NewUpdateAuthorizationRequestWithBody generates requests for UpdateAuthorization with any type of body
func NewUpdateAuthorizationRequestWithBody(server string, authorizationKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorizationKey", runtime.ParamLocationPath, authorizationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchBatchOperationItemsRequest calls the generic SearchBatchOperationItems builder with application/json body
func NewSearchBatchOperationItemsRequest(server string, body SearchBatchOperationItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchBatchOperationItemsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchBatchOperationItemsRequestWithBody generates requests for SearchBatchOperationItems with any type of body
func NewSearchBatchOperationItemsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operation-items/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchBatchOperationsRequest calls the generic SearchBatchOperations builder with application/json body
func NewSearchBatchOperationsRequest(server string, body SearchBatchOperationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchBatchOperationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchBatchOperationsRequestWithBody generates requests for SearchBatchOperations with any type of body
func NewSearchBatchOperationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operations/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBatchOperationRequest generates requests for GetBatchOperation
func NewGetBatchOperationRequest(server string, batchOperationKey BatchOperationKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchOperationKey", runtime.ParamLocationPath, batchOperationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelBatchOperationRequest calls the generic CancelBatchOperation builder with application/json body
func NewCancelBatchOperationRequest(server string, batchOperationKey BatchOperationKey, body CancelBatchOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelBatchOperationRequestWithBody(server, batchOperationKey, "application/json", bodyReader)
}

// NewCancelBatchOperationRequestWithBody generates requests for CancelBatchOperation with any type of body
func NewCancelBatchOperationRequestWithBody(server string, batchOperationKey BatchOperationKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchOperationKey", runtime.ParamLocationPath, batchOperationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operations/%s/cancellation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResumeBatchOperationRequest calls the generic ResumeBatchOperation builder with application/json body
func NewResumeBatchOperationRequest(server string, batchOperationKey BatchOperationKey, body ResumeBatchOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResumeBatchOperationRequestWithBody(server, batchOperationKey, "application/json", bodyReader)
}

// NewResumeBatchOperationRequestWithBody generates requests for ResumeBatchOperation with any type of body
func NewResumeBatchOperationRequestWithBody(server string, batchOperationKey BatchOperationKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchOperationKey", runtime.ParamLocationPath, batchOperationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operations/%s/resumption", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSuspendBatchOperationRequest calls the generic SuspendBatchOperation builder with application/json body
func NewSuspendBatchOperationRequest(server string, batchOperationKey BatchOperationKey, body SuspendBatchOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSuspendBatchOperationRequestWithBody(server, batchOperationKey, "application/json", bodyReader)
}

// NewSuspendBatchOperationRequestWithBody generates requests for SuspendBatchOperation with any type of body
func NewSuspendBatchOperationRequestWithBody(server string, batchOperationKey BatchOperationKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batchOperationKey", runtime.ParamLocationPath, batchOperationKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-operations/%s/suspension", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPinInternalClockAlphaRequest calls the generic PinInternalClockAlpha builder with application/json body
func NewPinInternalClockAlphaRequest(server string, body PinInternalClockAlphaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPinInternalClockAlphaRequestWithBody(server, "application/json", bodyReader)
}

// NewPinInternalClockAlphaRequestWithBody generates requests for PinInternalClockAlpha with any type of body
func NewPinInternalClockAlphaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clock")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetInternalClockAlphaRequest generates requests for ResetInternalClockAlpha
func NewResetInternalClockAlphaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clock/reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEvaluateDecisionRequest calls the generic EvaluateDecision builder with application/json body
func NewEvaluateDecisionRequest(server string, body EvaluateDecisionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEvaluateDecisionRequestWithBody(server, "application/json", bodyReader)
}

// NewEvaluateDecisionRequestWithBody generates requests for EvaluateDecision with any type of body
func NewEvaluateDecisionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/evaluation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchDecisionDefinitionsRequest calls the generic SearchDecisionDefinitions builder with application/json body
func NewSearchDecisionDefinitionsRequest(server string, body SearchDecisionDefinitionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDecisionDefinitionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchDecisionDefinitionsRequestWithBody generates requests for SearchDecisionDefinitions with any type of body
func NewSearchDecisionDefinitionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionDefinitionRequest generates requests for GetDecisionDefinition
func NewGetDecisionDefinitionRequest(server string, decisionDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionDefinitionKey", runtime.ParamLocationPath, decisionDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDecisionDefinitionXmlRequest generates requests for GetDecisionDefinitionXml
func NewGetDecisionDefinitionXmlRequest(server string, decisionDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionDefinitionKey", runtime.ParamLocationPath, decisionDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDecisionInstancesRequest calls the generic SearchDecisionInstances builder with application/json body
func NewSearchDecisionInstancesRequest(server string, body SearchDecisionInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDecisionInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchDecisionInstancesRequestWithBody generates requests for SearchDecisionInstances with any type of body
func NewSearchDecisionInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionInstanceRequest generates requests for GetDecisionInstance
func NewGetDecisionInstanceRequest(server string, decisionEvaluationInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionEvaluationInstanceKey", runtime.ParamLocationPath, decisionEvaluationInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDecisionRequirementsRequest calls the generic SearchDecisionRequirements builder with application/json body
func NewSearchDecisionRequirementsRequest(server string, body SearchDecisionRequirementsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDecisionRequirementsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchDecisionRequirementsRequestWithBody generates requests for SearchDecisionRequirements with any type of body
func NewSearchDecisionRequirementsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-requirements/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionRequirementsRequest generates requests for GetDecisionRequirements
func NewGetDecisionRequirementsRequest(server string, decisionRequirementsKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionRequirementsKey", runtime.ParamLocationPath, decisionRequirementsKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-requirements/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDecisionRequirementsXmlRequest generates requests for GetDecisionRequirementsXml
func NewGetDecisionRequirementsXmlRequest(server string, decisionRequirementsKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "decisionRequirementsKey", runtime.ParamLocationPath, decisionRequirementsKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-requirements/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeployResourcesRequestWithBody generates requests for DeployResources with any type of body
func NewDeployResourcesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadDocumentRequestWithBody generates requests for UploadDocument with any type of body
func NewUploadDocumentRequestWithBody(server string, params *UploadDocumentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DocumentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "documentId", runtime.ParamLocationQuery, *params.DocumentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadMultipleDocumentsRequestWithBody generates requests for UploadMultipleDocuments with any type of body
func NewUploadMultipleDocumentsRequestWithBody(server string, params *UploadMultipleDocumentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/batch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDocumentRequest generates requests for DeleteDocument
func NewDeleteDocumentRequest(server string, documentId DocumentId, params *DeleteDocumentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "documentId", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadDocumentRequest generates requests for DownloadDocument
func NewDownloadDocumentRequest(server string, documentId DocumentId, params *DownloadDocumentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "documentId", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentHash", runtime.ParamLocationQuery, params.ContentHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDocumentLinkRequest calls the generic CreateDocumentLink builder with application/json body
func NewCreateDocumentLinkRequest(server string, documentId DocumentId, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDocumentLinkRequestWithBody(server, documentId, params, "application/json", bodyReader)
}

// NewCreateDocumentLinkRequestWithBody generates requests for CreateDocumentLink with any type of body
func NewCreateDocumentLinkRequestWithBody(server string, documentId DocumentId, params *CreateDocumentLinkParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "documentId", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/documents/%s/links", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentHash", runtime.ParamLocationQuery, params.ContentHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActivateActivitiesWithinAnAdHocSubProcessRequest calls the generic ActivateActivitiesWithinAnAdHocSubProcess builder with application/json body
func NewActivateActivitiesWithinAnAdHocSubProcessRequest(server string, adHocSubProcessInstanceKey string, body ActivateActivitiesWithinAnAdHocSubProcessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateActivitiesWithinAnAdHocSubProcessRequestWithBody(server, adHocSubProcessInstanceKey, "application/json", bodyReader)
}

// NewActivateActivitiesWithinAnAdHocSubProcessRequestWithBody generates requests for ActivateActivitiesWithinAnAdHocSubProcess with any type of body
func NewActivateActivitiesWithinAnAdHocSubProcessRequestWithBody(server string, adHocSubProcessInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "adHocSubProcessInstanceKey", runtime.ParamLocationPath, adHocSubProcessInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/element-instances/ad-hoc-activities/%s/activation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchElementInstancesRequest calls the generic SearchElementInstances builder with application/json body
func NewSearchElementInstancesRequest(server string, body SearchElementInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchElementInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchElementInstancesRequestWithBody generates requests for SearchElementInstances with any type of body
func NewSearchElementInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/element-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetElementInstanceRequest generates requests for GetElementInstance
func NewGetElementInstanceRequest(server string, elementInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elementInstanceKey", runtime.ParamLocationPath, elementInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/element-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateElementInstanceVariablesRequest calls the generic UpdateElementInstanceVariables builder with application/json body
func NewUpdateElementInstanceVariablesRequest(server string, elementInstanceKey string, body UpdateElementInstanceVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateElementInstanceVariablesRequestWithBody(server, elementInstanceKey, "application/json", bodyReader)
}

// NewUpdateElementInstanceVariablesRequestWithBody generates requests for UpdateElementInstanceVariables with any type of body
func NewUpdateElementInstanceVariablesRequestWithBody(server string, elementInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elementInstanceKey", runtime.ParamLocationPath, elementInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/element-instances/%s/variables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchGroupsRequest calls the generic SearchGroups builder with application/json body
func NewSearchGroupsRequest(server string, body SearchGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchGroupsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchGroupsRequestWithBody generates requests for SearchGroups with any type of body
func NewSearchGroupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGroupRequest calls the generic UpdateGroup builder with application/json body
func NewUpdateGroupRequest(server string, groupId string, body UpdateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewUpdateGroupRequestWithBody generates requests for UpdateGroup with any type of body
func NewUpdateGroupRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchGroupClientsRequest calls the generic SearchGroupClients builder with application/json body
func NewSearchGroupClientsRequest(server string, groupId string, body SearchGroupClientsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchGroupClientsRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSearchGroupClientsRequestWithBody generates requests for SearchGroupClients with any type of body
func NewSearchGroupClientsRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/clients/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignAClientFromAGroupRequest generates requests for UnassignAClientFromAGroup
func NewUnassignAClientFromAGroupRequest(server string, groupId string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignAClientToAGroupRequest generates requests for AssignAClientToAGroup
func NewAssignAClientToAGroupRequest(server string, groupId string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchGroupMappingRulesRequest calls the generic SearchGroupMappingRules builder with application/json body
func NewSearchGroupMappingRulesRequest(server string, groupId string, body SearchGroupMappingRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchGroupMappingRulesRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSearchGroupMappingRulesRequestWithBody generates requests for SearchGroupMappingRules with any type of body
func NewSearchGroupMappingRulesRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/mapping-rules/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignAMappingRuleFromAGroupRequest generates requests for UnassignAMappingRuleFromAGroup
func NewUnassignAMappingRuleFromAGroupRequest(server string, groupId string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignAMappingRuleToAGroupRequest generates requests for AssignAMappingRuleToAGroup
func NewAssignAMappingRuleToAGroupRequest(server string, groupId string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchGroupRolesRequest calls the generic SearchGroupRoles builder with application/json body
func NewSearchGroupRolesRequest(server string, groupId string, body SearchGroupRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchGroupRolesRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSearchGroupRolesRequestWithBody generates requests for SearchGroupRoles with any type of body
func NewSearchGroupRolesRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/roles/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchGroupUsersRequest calls the generic SearchGroupUsers builder with application/json body
func NewSearchGroupUsersRequest(server string, groupId string, body SearchGroupUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchGroupUsersRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSearchGroupUsersRequestWithBody generates requests for SearchGroupUsers with any type of body
func NewSearchGroupUsersRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignAUserFromAGroupRequest generates requests for UnassignAUserFromAGroup
func NewUnassignAUserFromAGroupRequest(server string, groupId string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignAUserToAGroupRequest generates requests for AssignAUserToAGroup
func NewAssignAUserToAGroupRequest(server string, groupId string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchIncidentsRequest calls the generic SearchIncidents builder with application/json body
func NewSearchIncidentsRequest(server string, body SearchIncidentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchIncidentsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchIncidentsRequestWithBody generates requests for SearchIncidents with any type of body
func NewSearchIncidentsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIncidentRequest generates requests for GetIncident
func NewGetIncidentRequest(server string, incidentKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "incidentKey", runtime.ParamLocationPath, incidentKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResolveIncidentRequest calls the generic ResolveIncident builder with application/json body
func NewResolveIncidentRequest(server string, incidentKey string, body ResolveIncidentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResolveIncidentRequestWithBody(server, incidentKey, "application/json", bodyReader)
}

// NewResolveIncidentRequestWithBody generates requests for ResolveIncident with any type of body
func NewResolveIncidentRequestWithBody(server string, incidentKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "incidentKey", runtime.ParamLocationPath, incidentKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/%s/resolution", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActivateJobsRequest calls the generic ActivateJobs builder with application/json body
func NewActivateJobsRequest(server string, body ActivateJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewActivateJobsRequestWithBody generates requests for ActivateJobs with any type of body
func NewActivateJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/activation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchJobsRequest calls the generic SearchJobs builder with application/json body
func NewSearchJobsRequest(server string, body SearchJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchJobsRequestWithBody generates requests for SearchJobs with any type of body
func NewSearchJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateJobRequest calls the generic UpdateJob builder with application/json body
func NewUpdateJobRequest(server string, jobKey string, body UpdateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewUpdateJobRequestWithBody generates requests for UpdateJob with any type of body
func NewUpdateJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompleteJobRequest calls the generic CompleteJob builder with application/json body
func NewCompleteJobRequest(server string, jobKey string, body CompleteJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompleteJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewCompleteJobRequestWithBody generates requests for CompleteJob with any type of body
func NewCompleteJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/completion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewThrowErrorForJobRequest calls the generic ThrowErrorForJob builder with application/json body
func NewThrowErrorForJobRequest(server string, jobKey string, body ThrowErrorForJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewThrowErrorForJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewThrowErrorForJobRequestWithBody generates requests for ThrowErrorForJob with any type of body
func NewThrowErrorForJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/error", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFailJobRequest calls the generic FailJob builder with application/json body
func NewFailJobRequest(server string, jobKey string, body FailJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFailJobRequestWithBody(server, jobKey, "application/json", bodyReader)
}

// NewFailJobRequestWithBody generates requests for FailJob with any type of body
func NewFailJobRequestWithBody(server string, jobKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobKey", runtime.ParamLocationPath, jobKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/failure", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseStatusRequest generates requests for GetLicenseStatus
func NewGetLicenseStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMappingRuleRequest calls the generic CreateMappingRule builder with application/json body
func NewCreateMappingRuleRequest(server string, body CreateMappingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMappingRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMappingRuleRequestWithBody generates requests for CreateMappingRule with any type of body
func NewCreateMappingRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mapping-rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchMappingRulesRequest calls the generic SearchMappingRules builder with application/json body
func NewSearchMappingRulesRequest(server string, body SearchMappingRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchMappingRulesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchMappingRulesRequestWithBody generates requests for SearchMappingRules with any type of body
func NewSearchMappingRulesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mapping-rules/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAMappingRuleRequest generates requests for DeleteAMappingRule
func NewDeleteAMappingRuleRequest(server string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mapping-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAMappingRuleRequest generates requests for GetAMappingRule
func NewGetAMappingRuleRequest(server string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mapping-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMappingRuleRequest calls the generic UpdateMappingRule builder with application/json body
func NewUpdateMappingRuleRequest(server string, mappingRuleId string, body UpdateMappingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMappingRuleRequestWithBody(server, mappingRuleId, "application/json", bodyReader)
}

// NewUpdateMappingRuleRequestWithBody generates requests for UpdateMappingRule with any type of body
func NewUpdateMappingRuleRequestWithBody(server string, mappingRuleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mapping-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchMessageSubscriptionsRequest calls the generic SearchMessageSubscriptions builder with application/json body
func NewSearchMessageSubscriptionsRequest(server string, body SearchMessageSubscriptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchMessageSubscriptionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchMessageSubscriptionsRequestWithBody generates requests for SearchMessageSubscriptions with any type of body
func NewSearchMessageSubscriptionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/message-subscriptions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCorrelateMessageRequest calls the generic CorrelateMessage builder with application/json body
func NewCorrelateMessageRequest(server string, body CorrelateMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCorrelateMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewCorrelateMessageRequestWithBody generates requests for CorrelateMessage with any type of body
func NewCorrelateMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/correlation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPublishMessageRequest calls the generic PublishMessage builder with application/json body
func NewPublishMessageRequest(server string, body PublishMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewPublishMessageRequestWithBody generates requests for PublishMessage with any type of body
func NewPublishMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/publication")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchProcessDefinitionsRequest calls the generic SearchProcessDefinitions builder with application/json body
func NewSearchProcessDefinitionsRequest(server string, body SearchProcessDefinitionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchProcessDefinitionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchProcessDefinitionsRequestWithBody generates requests for SearchProcessDefinitions with any type of body
func NewSearchProcessDefinitionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessDefinitionRequest generates requests for GetProcessDefinition
func NewGetProcessDefinitionRequest(server string, processDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processDefinitionKey", runtime.ParamLocationPath, processDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessStartFormRequest generates requests for GetProcessStartForm
func NewGetProcessStartFormRequest(server string, processDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processDefinitionKey", runtime.ParamLocationPath, processDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s/form", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessDefinitionStatisticsRequest calls the generic GetProcessDefinitionStatistics builder with application/json body
func NewGetProcessDefinitionStatisticsRequest(server string, processDefinitionKey string, body GetProcessDefinitionStatisticsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetProcessDefinitionStatisticsRequestWithBody(server, processDefinitionKey, "application/json", bodyReader)
}

// NewGetProcessDefinitionStatisticsRequestWithBody generates requests for GetProcessDefinitionStatistics with any type of body
func NewGetProcessDefinitionStatisticsRequestWithBody(server string, processDefinitionKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processDefinitionKey", runtime.ParamLocationPath, processDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s/statistics/element-instances", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessDefinitionXmlRequest generates requests for GetProcessDefinitionXml
func NewGetProcessDefinitionXmlRequest(server string, processDefinitionKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processDefinitionKey", runtime.ParamLocationPath, processDefinitionKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProcessInstanceRequest calls the generic CreateProcessInstance builder with application/json body
func NewCreateProcessInstanceRequest(server string, body CreateProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProcessInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProcessInstanceRequestWithBody generates requests for CreateProcessInstance with any type of body
func NewCreateProcessInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateABatchOperationToCancelProcessInstancesRequest calls the generic CreateABatchOperationToCancelProcessInstances builder with application/json body
func NewCreateABatchOperationToCancelProcessInstancesRequest(server string, body CreateABatchOperationToCancelProcessInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateABatchOperationToCancelProcessInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateABatchOperationToCancelProcessInstancesRequestWithBody generates requests for CreateABatchOperationToCancelProcessInstances with any type of body
func NewCreateABatchOperationToCancelProcessInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/cancellation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateABatchOperationToResolveIncidentsOfProcessInstancesRequest calls the generic CreateABatchOperationToResolveIncidentsOfProcessInstances builder with application/json body
func NewCreateABatchOperationToResolveIncidentsOfProcessInstancesRequest(server string, body CreateABatchOperationToResolveIncidentsOfProcessInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateABatchOperationToResolveIncidentsOfProcessInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateABatchOperationToResolveIncidentsOfProcessInstancesRequestWithBody generates requests for CreateABatchOperationToResolveIncidentsOfProcessInstances with any type of body
func NewCreateABatchOperationToResolveIncidentsOfProcessInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/incident-resolution")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateABatchOperationToMigrateProcessInstancesRequest calls the generic CreateABatchOperationToMigrateProcessInstances builder with application/json body
func NewCreateABatchOperationToMigrateProcessInstancesRequest(server string, body CreateABatchOperationToMigrateProcessInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateABatchOperationToMigrateProcessInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateABatchOperationToMigrateProcessInstancesRequestWithBody generates requests for CreateABatchOperationToMigrateProcessInstances with any type of body
func NewCreateABatchOperationToMigrateProcessInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/migration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateABatchOperationToModifyProcessInstancesRequest calls the generic CreateABatchOperationToModifyProcessInstances builder with application/json body
func NewCreateABatchOperationToModifyProcessInstancesRequest(server string, body CreateABatchOperationToModifyProcessInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateABatchOperationToModifyProcessInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateABatchOperationToModifyProcessInstancesRequestWithBody generates requests for CreateABatchOperationToModifyProcessInstances with any type of body
func NewCreateABatchOperationToModifyProcessInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/modification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchProcessInstancesRequest calls the generic SearchProcessInstances builder with application/json body
func NewSearchProcessInstancesRequest(server string, body SearchProcessInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchProcessInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchProcessInstancesRequestWithBody generates requests for SearchProcessInstances with any type of body
func NewSearchProcessInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessInstanceRequest generates requests for GetProcessInstance
func NewGetProcessInstanceRequest(server string, processInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCallHierarchyForProcessInstanceRequest generates requests for GetCallHierarchyForProcessInstance
func NewGetCallHierarchyForProcessInstanceRequest(server string, processInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/call-hierarchy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelProcessInstanceRequest calls the generic CancelProcessInstance builder with application/json body
func NewCancelProcessInstanceRequest(server string, processInstanceKey string, body CancelProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelProcessInstanceRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewCancelProcessInstanceRequestWithBody generates requests for CancelProcessInstance with any type of body
func NewCancelProcessInstanceRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/cancellation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchForIncidentsAssociatedWithAProcessInstanceRequest calls the generic SearchForIncidentsAssociatedWithAProcessInstance builder with application/json body
func NewSearchForIncidentsAssociatedWithAProcessInstanceRequest(server string, processInstanceKey string, body SearchForIncidentsAssociatedWithAProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForIncidentsAssociatedWithAProcessInstanceRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewSearchForIncidentsAssociatedWithAProcessInstanceRequestWithBody generates requests for SearchForIncidentsAssociatedWithAProcessInstance with any type of body
func NewSearchForIncidentsAssociatedWithAProcessInstanceRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/incidents/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrateProcessInstanceRequest calls the generic MigrateProcessInstance builder with application/json body
func NewMigrateProcessInstanceRequest(server string, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateProcessInstanceRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewMigrateProcessInstanceRequestWithBody generates requests for MigrateProcessInstance with any type of body
func NewMigrateProcessInstanceRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/migration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModifyProcessInstanceRequest calls the generic ModifyProcessInstance builder with application/json body
func NewModifyProcessInstanceRequest(server string, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyProcessInstanceRequestWithBody(server, processInstanceKey, "application/json", bodyReader)
}

// NewModifyProcessInstanceRequestWithBody generates requests for ModifyProcessInstance with any type of body
func NewModifyProcessInstanceRequestWithBody(server string, processInstanceKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/modification", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessInstanceSequenceFlowsRequest generates requests for GetProcessInstanceSequenceFlows
func NewGetProcessInstanceSequenceFlowsRequest(server string, processInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/sequence-flows", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessInstanceStatisticsRequest generates requests for GetProcessInstanceStatistics
func NewGetProcessInstanceStatisticsRequest(server string, processInstanceKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "processInstanceKey", runtime.ParamLocationPath, processInstanceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s/statistics/element-instances", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, resourceKey ResourceKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceKey", runtime.ParamLocationPath, resourceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceContentRequest generates requests for GetResourceContent
func NewGetResourceContentRequest(server string, resourceKey ResourceKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceKey", runtime.ParamLocationPath, resourceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteResourceRequest calls the generic DeleteResource builder with application/json body
func NewDeleteResourceRequest(server string, resourceKey ResourceKey, body DeleteResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteResourceRequestWithBody(server, resourceKey, "application/json", bodyReader)
}

// NewDeleteResourceRequestWithBody generates requests for DeleteResource with any type of body
func NewDeleteResourceRequestWithBody(server string, resourceKey ResourceKey, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceKey", runtime.ParamLocationPath, resourceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s/deletion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRoleRequest calls the generic CreateRole builder with application/json body
func NewCreateRoleRequest(server string, body CreateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRoleRequestWithBody generates requests for CreateRole with any type of body
func NewCreateRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchRolesRequest calls the generic SearchRoles builder with application/json body
func NewSearchRolesRequest(server string, body SearchRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRolesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchRolesRequestWithBody generates requests for SearchRoles with any type of body
func NewSearchRolesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoleRequest generates requests for DeleteRole
func NewDeleteRoleRequest(server string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleRequest calls the generic UpdateRole builder with application/json body
func NewUpdateRoleRequest(server string, roleId string, body UpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func NewUpdateRoleRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchRoleClientsRequest calls the generic SearchRoleClients builder with application/json body
func NewSearchRoleClientsRequest(server string, roleId string, body SearchRoleClientsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRoleClientsRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewSearchRoleClientsRequestWithBody generates requests for SearchRoleClients with any type of body
func NewSearchRoleClientsRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/clients/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignARoleFromAClientRequest generates requests for UnassignARoleFromAClient
func NewUnassignARoleFromAClientRequest(server string, roleId string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignARoleToAClientRequest generates requests for AssignARoleToAClient
func NewAssignARoleToAClientRequest(server string, roleId string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRoleGroupsRequest calls the generic SearchRoleGroups builder with application/json body
func NewSearchRoleGroupsRequest(server string, roleId string, body SearchRoleGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRoleGroupsRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewSearchRoleGroupsRequestWithBody generates requests for SearchRoleGroups with any type of body
func NewSearchRoleGroupsRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/groups/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignARoleFromAGroupRequest generates requests for UnassignARoleFromAGroup
func NewUnassignARoleFromAGroupRequest(server string, roleId string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignARoleToAGroupRequest generates requests for AssignARoleToAGroup
func NewAssignARoleToAGroupRequest(server string, roleId string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRoleMappingRulesRequest calls the generic SearchRoleMappingRules builder with application/json body
func NewSearchRoleMappingRulesRequest(server string, roleId string, body SearchRoleMappingRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRoleMappingRulesRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewSearchRoleMappingRulesRequestWithBody generates requests for SearchRoleMappingRules with any type of body
func NewSearchRoleMappingRulesRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/mapping-rules/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignARoleFromAMappingRuleRequest generates requests for UnassignARoleFromAMappingRule
func NewUnassignARoleFromAMappingRuleRequest(server string, roleId string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignARoleToAMappingRuleRequest generates requests for AssignARoleToAMappingRule
func NewAssignARoleToAMappingRuleRequest(server string, roleId string, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRoleUsersRequest calls the generic SearchRoleUsers builder with application/json body
func NewSearchRoleUsersRequest(server string, roleId string, body SearchRoleUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRoleUsersRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewSearchRoleUsersRequestWithBody generates requests for SearchRoleUsers with any type of body
func NewSearchRoleUsersRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/users/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignARoleFromAUserRequest generates requests for UnassignARoleFromAUser
func NewUnassignARoleFromAUserRequest(server string, roleId string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignARoleToAUserRequest generates requests for AssignARoleToAUser
func NewAssignARoleToAUserRequest(server string, roleId string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAdminUserRequest calls the generic CreateAdminUser builder with application/json body
func NewCreateAdminUserRequest(server string, body CreateAdminUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAdminUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAdminUserRequestWithBody generates requests for CreateAdminUser with any type of body
func NewCreateAdminUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBroadcastSignalRequest calls the generic BroadcastSignal builder with application/json body
func NewBroadcastSignalRequest(server string, body BroadcastSignalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBroadcastSignalRequestWithBody(server, "application/json", bodyReader)
}

// NewBroadcastSignalRequestWithBody generates requests for BroadcastSignal with any type of body
func NewBroadcastSignalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/signals/broadcast")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterStatusRequest generates requests for GetClusterStatus
func NewGetClusterStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsageMetricsRequest generates requests for GetUsageMetrics
func NewGetUsageMetricsRequest(server string, params *GetUsageMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/usage-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTime", runtime.ParamLocationQuery, params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TenantId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenantId", runtime.ParamLocationQuery, *params.TenantId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithTenants != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withTenants", runtime.ParamLocationQuery, *params.WithTenants); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTenantRequest calls the generic CreateTenant builder with application/json body
func NewCreateTenantRequest(server string, body CreateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTenantRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTenantRequestWithBody generates requests for CreateTenant with any type of body
func NewCreateTenantRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchTenantsRequest calls the generic SearchTenants builder with application/json body
func NewSearchTenantsRequest(server string, body SearchTenantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchTenantsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchTenantsRequestWithBody generates requests for SearchTenants with any type of body
func NewSearchTenantsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTenantRequest generates requests for DeleteTenant
func NewDeleteTenantRequest(server string, tenantId TenantId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenantRequest generates requests for GetTenant
func NewGetTenantRequest(server string, tenantId TenantId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTenantRequest calls the generic UpdateTenant builder with application/json body
func NewUpdateTenantRequest(server string, tenantId TenantId, body UpdateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewUpdateTenantRequestWithBody generates requests for UpdateTenant with any type of body
func NewUpdateTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchClientsForTenantRequest calls the generic SearchClientsForTenant builder with application/json body
func NewSearchClientsForTenantRequest(server string, tenantId TenantId, body SearchClientsForTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchClientsForTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewSearchClientsForTenantRequestWithBody generates requests for SearchClientsForTenant with any type of body
func NewSearchClientsForTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/clients/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignAClientFromATenantRequest generates requests for UnassignAClientFromATenant
func NewUnassignAClientFromATenantRequest(server string, tenantId TenantId, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignAClientToATenantRequest generates requests for AssignAClientToATenant
func NewAssignAClientToATenantRequest(server string, tenantId TenantId, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/clients/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchGroupsForTenantRequest calls the generic SearchGroupsForTenant builder with application/json body
func NewSearchGroupsForTenantRequest(server string, tenantId TenantId, body SearchGroupsForTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchGroupsForTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewSearchGroupsForTenantRequestWithBody generates requests for SearchGroupsForTenant with any type of body
func NewSearchGroupsForTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/groups/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignAGroupFromATenantRequest generates requests for UnassignAGroupFromATenant
func NewUnassignAGroupFromATenantRequest(server string, tenantId TenantId, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignAGroupToATenantRequest generates requests for AssignAGroupToATenant
func NewAssignAGroupToATenantRequest(server string, tenantId TenantId, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchMappingRulesForTenantRequest calls the generic SearchMappingRulesForTenant builder with application/json body
func NewSearchMappingRulesForTenantRequest(server string, tenantId TenantId, body SearchMappingRulesForTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchMappingRulesForTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewSearchMappingRulesForTenantRequestWithBody generates requests for SearchMappingRulesForTenant with any type of body
func NewSearchMappingRulesForTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/mapping-rules/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignAMappingRuleFromATenantRequest generates requests for UnassignAMappingRuleFromATenant
func NewUnassignAMappingRuleFromATenantRequest(server string, tenantId TenantId, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignAMappingRuleToATenantRequest generates requests for AssignAMappingRuleToATenant
func NewAssignAMappingRuleToATenantRequest(server string, tenantId TenantId, mappingRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mappingRuleId", runtime.ParamLocationPath, mappingRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/mapping-rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRolesForTenantRequest calls the generic SearchRolesForTenant builder with application/json body
func NewSearchRolesForTenantRequest(server string, tenantId TenantId, body SearchRolesForTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRolesForTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewSearchRolesForTenantRequestWithBody generates requests for SearchRolesForTenant with any type of body
func NewSearchRolesForTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/roles/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignARoleFromATenantRequest generates requests for UnassignARoleFromATenant
func NewUnassignARoleFromATenantRequest(server string, tenantId TenantId, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignARoleToATenantRequest generates requests for AssignARoleToATenant
func NewAssignARoleToATenantRequest(server string, tenantId TenantId, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchUsersForTenantRequest calls the generic SearchUsersForTenant builder with application/json body
func NewSearchUsersForTenantRequest(server string, tenantId TenantId, body SearchUsersForTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUsersForTenantRequestWithBody(server, tenantId, "application/json", bodyReader)
}

// NewSearchUsersForTenantRequestWithBody generates requests for SearchUsersForTenant with any type of body
func NewSearchUsersForTenantRequestWithBody(server string, tenantId TenantId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/users/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignAUserFromATenantRequest generates requests for UnassignAUserFromATenant
func NewUnassignAUserFromATenantRequest(server string, tenantId TenantId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignAUserToATenantRequest generates requests for AssignAUserToATenant
func NewAssignAUserToATenantRequest(server string, tenantId TenantId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenantId", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterTopologyRequest generates requests for GetClusterTopology
func NewGetClusterTopologyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/topology")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchUserTasksRequest calls the generic SearchUserTasks builder with application/json body
func NewSearchUserTasksRequest(server string, body SearchUserTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUserTasksRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchUserTasksRequestWithBody generates requests for SearchUserTasks with any type of body
func NewSearchUserTasksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserTaskRequest generates requests for GetUserTask
func NewGetUserTaskRequest(server string, userTaskKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserTaskRequest calls the generic UpdateUserTask builder with application/json body
func NewUpdateUserTaskRequest(server string, userTaskKey string, body UpdateUserTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserTaskRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewUpdateUserTaskRequestWithBody generates requests for UpdateUserTask with any type of body
func NewUpdateUserTaskRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignUserTaskRequest generates requests for UnassignUserTask
func NewUnassignUserTaskRequest(server string, userTaskKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/assignee", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignUserTaskRequest calls the generic AssignUserTask builder with application/json body
func NewAssignUserTaskRequest(server string, userTaskKey string, body AssignUserTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignUserTaskRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewAssignUserTaskRequestWithBody generates requests for AssignUserTask with any type of body
func NewAssignUserTaskRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/assignment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompleteUserTaskRequest calls the generic CompleteUserTask builder with application/json body
func NewCompleteUserTaskRequest(server string, userTaskKey string, body CompleteUserTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompleteUserTaskRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewCompleteUserTaskRequestWithBody generates requests for CompleteUserTask with any type of body
func NewCompleteUserTaskRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/completion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserTaskFormRequest generates requests for GetUserTaskForm
func NewGetUserTaskFormRequest(server string, userTaskKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/form", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchUserTaskVariablesRequest calls the generic SearchUserTaskVariables builder with application/json body
func NewSearchUserTaskVariablesRequest(server string, userTaskKey string, body SearchUserTaskVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUserTaskVariablesRequestWithBody(server, userTaskKey, "application/json", bodyReader)
}

// NewSearchUserTaskVariablesRequestWithBody generates requests for SearchUserTaskVariables with any type of body
func NewSearchUserTaskVariablesRequestWithBody(server string, userTaskKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userTaskKey", runtime.ParamLocationPath, userTaskKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-tasks/%s/variables/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchUsersRequest calls the generic SearchUsers builder with application/json body
func NewSearchUsersRequest(server string, body SearchUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchUsersRequestWithBody generates requests for SearchUsers with any type of body
func NewSearchUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, username Username, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, username, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, username Username, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchVariablesRequest calls the generic SearchVariables builder with application/json body
func NewSearchVariablesRequest(server string, body SearchVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchVariablesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchVariablesRequestWithBody generates requests for SearchVariables with any type of body
func NewSearchVariablesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVariableRequest generates requests for GetVariable
func NewGetVariableRequest(server string, variableKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "variableKey", runtime.ParamLocationPath, variableKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCurrentUserWithResponse request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)

	// CreateAuthorizationWithBodyWithResponse request with any body
	CreateAuthorizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthorizationResponse, error)

	CreateAuthorizationWithResponse(ctx context.Context, body CreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthorizationResponse, error)

	// SearchAuthorizationsWithBodyWithResponse request with any body
	SearchAuthorizationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchAuthorizationsResponse, error)

	SearchAuthorizationsWithResponse(ctx context.Context, body SearchAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchAuthorizationsResponse, error)

	// DeleteAuthorizationWithResponse request
	DeleteAuthorizationWithResponse(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*DeleteAuthorizationResponse, error)

	// GetAuthorizationWithResponse request
	GetAuthorizationWithResponse(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*GetAuthorizationResponse, error)

	// UpdateAuthorizationWithBodyWithResponse request with any body
	UpdateAuthorizationWithBodyWithResponse(ctx context.Context, authorizationKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAuthorizationResponse, error)

	UpdateAuthorizationWithResponse(ctx context.Context, authorizationKey string, body UpdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAuthorizationResponse, error)

	// SearchBatchOperationItemsWithBodyWithResponse request with any body
	SearchBatchOperationItemsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchBatchOperationItemsResponse, error)

	SearchBatchOperationItemsWithResponse(ctx context.Context, body SearchBatchOperationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchBatchOperationItemsResponse, error)

	// SearchBatchOperationsWithBodyWithResponse request with any body
	SearchBatchOperationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchBatchOperationsResponse, error)

	SearchBatchOperationsWithResponse(ctx context.Context, body SearchBatchOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchBatchOperationsResponse, error)

	// GetBatchOperationWithResponse request
	GetBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, reqEditors ...RequestEditorFn) (*GetBatchOperationResponse, error)

	// CancelBatchOperationWithBodyWithResponse request with any body
	CancelBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelBatchOperationResponse, error)

	CancelBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body CancelBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelBatchOperationResponse, error)

	// ResumeBatchOperationWithBodyWithResponse request with any body
	ResumeBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeBatchOperationResponse, error)

	ResumeBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body ResumeBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeBatchOperationResponse, error)

	// SuspendBatchOperationWithBodyWithResponse request with any body
	SuspendBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SuspendBatchOperationResponse, error)

	SuspendBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body SuspendBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SuspendBatchOperationResponse, error)

	// PinInternalClockAlphaWithBodyWithResponse request with any body
	PinInternalClockAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PinInternalClockAlphaResponse, error)

	PinInternalClockAlphaWithResponse(ctx context.Context, body PinInternalClockAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*PinInternalClockAlphaResponse, error)

	// ResetInternalClockAlphaWithResponse request
	ResetInternalClockAlphaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetInternalClockAlphaResponse, error)

	// EvaluateDecisionWithBodyWithResponse request with any body
	EvaluateDecisionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error)

	EvaluateDecisionWithResponse(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error)

	// SearchDecisionDefinitionsWithBodyWithResponse request with any body
	SearchDecisionDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error)

	SearchDecisionDefinitionsWithResponse(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error)

	// GetDecisionDefinitionWithResponse request
	GetDecisionDefinitionWithResponse(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionResponse, error)

	// GetDecisionDefinitionXmlWithResponse request
	GetDecisionDefinitionXmlWithResponse(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionXmlResponse, error)

	// SearchDecisionInstancesWithBodyWithResponse request with any body
	SearchDecisionInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error)

	SearchDecisionInstancesWithResponse(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error)

	// GetDecisionInstanceWithResponse request
	GetDecisionInstanceWithResponse(ctx context.Context, decisionEvaluationInstanceKey string, reqEditors ...RequestEditorFn) (*GetDecisionInstanceResponse, error)

	// SearchDecisionRequirementsWithBodyWithResponse request with any body
	SearchDecisionRequirementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error)

	SearchDecisionRequirementsWithResponse(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error)

	// GetDecisionRequirementsWithResponse request
	GetDecisionRequirementsWithResponse(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsResponse, error)

	// GetDecisionRequirementsXmlWithResponse request
	GetDecisionRequirementsXmlWithResponse(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsXmlResponse, error)

	// DeployResourcesWithBodyWithResponse request with any body
	DeployResourcesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployResourcesResponse, error)

	// UploadDocumentWithBodyWithResponse request with any body
	UploadDocumentWithBodyWithResponse(ctx context.Context, params *UploadDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadDocumentResponse, error)

	// UploadMultipleDocumentsWithBodyWithResponse request with any body
	UploadMultipleDocumentsWithBodyWithResponse(ctx context.Context, params *UploadMultipleDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadMultipleDocumentsResponse, error)

	// DeleteDocumentWithResponse request
	DeleteDocumentWithResponse(ctx context.Context, documentId DocumentId, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*DeleteDocumentResponse, error)

	// DownloadDocumentWithResponse request
	DownloadDocumentWithResponse(ctx context.Context, documentId DocumentId, params *DownloadDocumentParams, reqEditors ...RequestEditorFn) (*DownloadDocumentResponse, error)

	// CreateDocumentLinkWithBodyWithResponse request with any body
	CreateDocumentLinkWithBodyWithResponse(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error)

	CreateDocumentLinkWithResponse(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error)

	// ActivateActivitiesWithinAnAdHocSubProcessWithBodyWithResponse request with any body
	ActivateActivitiesWithinAnAdHocSubProcessWithBodyWithResponse(ctx context.Context, adHocSubProcessInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateActivitiesWithinAnAdHocSubProcessResponse, error)

	ActivateActivitiesWithinAnAdHocSubProcessWithResponse(ctx context.Context, adHocSubProcessInstanceKey string, body ActivateActivitiesWithinAnAdHocSubProcessJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateActivitiesWithinAnAdHocSubProcessResponse, error)

	// SearchElementInstancesWithBodyWithResponse request with any body
	SearchElementInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchElementInstancesResponse, error)

	SearchElementInstancesWithResponse(ctx context.Context, body SearchElementInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchElementInstancesResponse, error)

	// GetElementInstanceWithResponse request
	GetElementInstanceWithResponse(ctx context.Context, elementInstanceKey string, reqEditors ...RequestEditorFn) (*GetElementInstanceResponse, error)

	// UpdateElementInstanceVariablesWithBodyWithResponse request with any body
	UpdateElementInstanceVariablesWithBodyWithResponse(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateElementInstanceVariablesResponse, error)

	UpdateElementInstanceVariablesWithResponse(ctx context.Context, elementInstanceKey string, body UpdateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateElementInstanceVariablesResponse, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// SearchGroupsWithBodyWithResponse request with any body
	SearchGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupsResponse, error)

	SearchGroupsWithResponse(ctx context.Context, body SearchGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupsResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// UpdateGroupWithBodyWithResponse request with any body
	UpdateGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	UpdateGroupWithResponse(ctx context.Context, groupId string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	// SearchGroupClientsWithBodyWithResponse request with any body
	SearchGroupClientsWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupClientsResponse, error)

	SearchGroupClientsWithResponse(ctx context.Context, groupId string, body SearchGroupClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupClientsResponse, error)

	// UnassignAClientFromAGroupWithResponse request
	UnassignAClientFromAGroupWithResponse(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*UnassignAClientFromAGroupResponse, error)

	// AssignAClientToAGroupWithResponse request
	AssignAClientToAGroupWithResponse(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*AssignAClientToAGroupResponse, error)

	// SearchGroupMappingRulesWithBodyWithResponse request with any body
	SearchGroupMappingRulesWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupMappingRulesResponse, error)

	SearchGroupMappingRulesWithResponse(ctx context.Context, groupId string, body SearchGroupMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupMappingRulesResponse, error)

	// UnassignAMappingRuleFromAGroupWithResponse request
	UnassignAMappingRuleFromAGroupWithResponse(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignAMappingRuleFromAGroupResponse, error)

	// AssignAMappingRuleToAGroupWithResponse request
	AssignAMappingRuleToAGroupWithResponse(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignAMappingRuleToAGroupResponse, error)

	// SearchGroupRolesWithBodyWithResponse request with any body
	SearchGroupRolesWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupRolesResponse, error)

	SearchGroupRolesWithResponse(ctx context.Context, groupId string, body SearchGroupRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupRolesResponse, error)

	// SearchGroupUsersWithBodyWithResponse request with any body
	SearchGroupUsersWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupUsersResponse, error)

	SearchGroupUsersWithResponse(ctx context.Context, groupId string, body SearchGroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupUsersResponse, error)

	// UnassignAUserFromAGroupWithResponse request
	UnassignAUserFromAGroupWithResponse(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*UnassignAUserFromAGroupResponse, error)

	// AssignAUserToAGroupWithResponse request
	AssignAUserToAGroupWithResponse(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*AssignAUserToAGroupResponse, error)

	// SearchIncidentsWithBodyWithResponse request with any body
	SearchIncidentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error)

	SearchIncidentsWithResponse(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error)

	// GetIncidentWithResponse request
	GetIncidentWithResponse(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*GetIncidentResponse, error)

	// ResolveIncidentWithBodyWithResponse request with any body
	ResolveIncidentWithBodyWithResponse(ctx context.Context, incidentKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolveIncidentResponse, error)

	ResolveIncidentWithResponse(ctx context.Context, incidentKey string, body ResolveIncidentJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolveIncidentResponse, error)

	// ActivateJobsWithBodyWithResponse request with any body
	ActivateJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error)

	ActivateJobsWithResponse(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error)

	// SearchJobsWithBodyWithResponse request with any body
	SearchJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchJobsResponse, error)

	SearchJobsWithResponse(ctx context.Context, body SearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchJobsResponse, error)

	// UpdateJobWithBodyWithResponse request with any body
	UpdateJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	UpdateJobWithResponse(ctx context.Context, jobKey string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	// CompleteJobWithBodyWithResponse request with any body
	CompleteJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error)

	CompleteJobWithResponse(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error)

	// ThrowErrorForJobWithBodyWithResponse request with any body
	ThrowErrorForJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ThrowErrorForJobResponse, error)

	ThrowErrorForJobWithResponse(ctx context.Context, jobKey string, body ThrowErrorForJobJSONRequestBody, reqEditors ...RequestEditorFn) (*ThrowErrorForJobResponse, error)

	// FailJobWithBodyWithResponse request with any body
	FailJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FailJobResponse, error)

	FailJobWithResponse(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*FailJobResponse, error)

	// GetLicenseStatusWithResponse request
	GetLicenseStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseStatusResponse, error)

	// CreateMappingRuleWithBodyWithResponse request with any body
	CreateMappingRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMappingRuleResponse, error)

	CreateMappingRuleWithResponse(ctx context.Context, body CreateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMappingRuleResponse, error)

	// SearchMappingRulesWithBodyWithResponse request with any body
	SearchMappingRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRulesResponse, error)

	SearchMappingRulesWithResponse(ctx context.Context, body SearchMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRulesResponse, error)

	// DeleteAMappingRuleWithResponse request
	DeleteAMappingRuleWithResponse(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*DeleteAMappingRuleResponse, error)

	// GetAMappingRuleWithResponse request
	GetAMappingRuleWithResponse(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*GetAMappingRuleResponse, error)

	// UpdateMappingRuleWithBodyWithResponse request with any body
	UpdateMappingRuleWithBodyWithResponse(ctx context.Context, mappingRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMappingRuleResponse, error)

	UpdateMappingRuleWithResponse(ctx context.Context, mappingRuleId string, body UpdateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMappingRuleResponse, error)

	// SearchMessageSubscriptionsWithBodyWithResponse request with any body
	SearchMessageSubscriptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMessageSubscriptionsResponse, error)

	SearchMessageSubscriptionsWithResponse(ctx context.Context, body SearchMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMessageSubscriptionsResponse, error)

	// CorrelateMessageWithBodyWithResponse request with any body
	CorrelateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CorrelateMessageResponse, error)

	CorrelateMessageWithResponse(ctx context.Context, body CorrelateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CorrelateMessageResponse, error)

	// PublishMessageWithBodyWithResponse request with any body
	PublishMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishMessageResponse, error)

	PublishMessageWithResponse(ctx context.Context, body PublishMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishMessageResponse, error)

	// SearchProcessDefinitionsWithBodyWithResponse request with any body
	SearchProcessDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error)

	SearchProcessDefinitionsWithResponse(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error)

	// GetProcessDefinitionWithResponse request
	GetProcessDefinitionWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionResponse, error)

	// GetProcessStartFormWithResponse request
	GetProcessStartFormWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetProcessStartFormResponse, error)

	// GetProcessDefinitionStatisticsWithBodyWithResponse request with any body
	GetProcessDefinitionStatisticsWithBodyWithResponse(ctx context.Context, processDefinitionKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetProcessDefinitionStatisticsResponse, error)

	GetProcessDefinitionStatisticsWithResponse(ctx context.Context, processDefinitionKey string, body GetProcessDefinitionStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetProcessDefinitionStatisticsResponse, error)

	// GetProcessDefinitionXmlWithResponse request
	GetProcessDefinitionXmlWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionXmlResponse, error)

	// CreateProcessInstanceWithBodyWithResponse request with any body
	CreateProcessInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error)

	CreateProcessInstanceWithResponse(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error)

	// CreateABatchOperationToCancelProcessInstancesWithBodyWithResponse request with any body
	CreateABatchOperationToCancelProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateABatchOperationToCancelProcessInstancesResponse, error)

	CreateABatchOperationToCancelProcessInstancesWithResponse(ctx context.Context, body CreateABatchOperationToCancelProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateABatchOperationToCancelProcessInstancesResponse, error)

	// CreateABatchOperationToResolveIncidentsOfProcessInstancesWithBodyWithResponse request with any body
	CreateABatchOperationToResolveIncidentsOfProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateABatchOperationToResolveIncidentsOfProcessInstancesResponse, error)

	CreateABatchOperationToResolveIncidentsOfProcessInstancesWithResponse(ctx context.Context, body CreateABatchOperationToResolveIncidentsOfProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateABatchOperationToResolveIncidentsOfProcessInstancesResponse, error)

	// CreateABatchOperationToMigrateProcessInstancesWithBodyWithResponse request with any body
	CreateABatchOperationToMigrateProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateABatchOperationToMigrateProcessInstancesResponse, error)

	CreateABatchOperationToMigrateProcessInstancesWithResponse(ctx context.Context, body CreateABatchOperationToMigrateProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateABatchOperationToMigrateProcessInstancesResponse, error)

	// CreateABatchOperationToModifyProcessInstancesWithBodyWithResponse request with any body
	CreateABatchOperationToModifyProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateABatchOperationToModifyProcessInstancesResponse, error)

	CreateABatchOperationToModifyProcessInstancesWithResponse(ctx context.Context, body CreateABatchOperationToModifyProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateABatchOperationToModifyProcessInstancesResponse, error)

	// SearchProcessInstancesWithBodyWithResponse request with any body
	SearchProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error)

	SearchProcessInstancesWithResponse(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error)

	// GetProcessInstanceWithResponse request
	GetProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceResponse, error)

	// GetCallHierarchyForProcessInstanceWithResponse request
	GetCallHierarchyForProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetCallHierarchyForProcessInstanceResponse, error)

	// CancelProcessInstanceWithBodyWithResponse request with any body
	CancelProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error)

	CancelProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error)

	// SearchForIncidentsAssociatedWithAProcessInstanceWithBodyWithResponse request with any body
	SearchForIncidentsAssociatedWithAProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForIncidentsAssociatedWithAProcessInstanceResponse, error)

	SearchForIncidentsAssociatedWithAProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body SearchForIncidentsAssociatedWithAProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForIncidentsAssociatedWithAProcessInstanceResponse, error)

	// MigrateProcessInstanceWithBodyWithResponse request with any body
	MigrateProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error)

	MigrateProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error)

	// ModifyProcessInstanceWithBodyWithResponse request with any body
	ModifyProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error)

	ModifyProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error)

	// GetProcessInstanceSequenceFlowsWithResponse request
	GetProcessInstanceSequenceFlowsWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceSequenceFlowsResponse, error)

	// GetProcessInstanceStatisticsWithResponse request
	GetProcessInstanceStatisticsWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceStatisticsResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetResourceContentWithResponse request
	GetResourceContentWithResponse(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*GetResourceContentResponse, error)

	// DeleteResourceWithBodyWithResponse request with any body
	DeleteResourceWithBodyWithResponse(ctx context.Context, resourceKey ResourceKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	DeleteResourceWithResponse(ctx context.Context, resourceKey ResourceKey, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	// CreateRoleWithBodyWithResponse request with any body
	CreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	CreateRoleWithResponse(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	// SearchRolesWithBodyWithResponse request with any body
	SearchRolesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRolesResponse, error)

	SearchRolesWithResponse(ctx context.Context, body SearchRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRolesResponse, error)

	// DeleteRoleWithResponse request
	DeleteRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// UpdateRoleWithBodyWithResponse request with any body
	UpdateRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	UpdateRoleWithResponse(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	// SearchRoleClientsWithBodyWithResponse request with any body
	SearchRoleClientsWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRoleClientsResponse, error)

	SearchRoleClientsWithResponse(ctx context.Context, roleId string, body SearchRoleClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRoleClientsResponse, error)

	// UnassignARoleFromAClientWithResponse request
	UnassignARoleFromAClientWithResponse(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*UnassignARoleFromAClientResponse, error)

	// AssignARoleToAClientWithResponse request
	AssignARoleToAClientWithResponse(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*AssignARoleToAClientResponse, error)

	// SearchRoleGroupsWithBodyWithResponse request with any body
	SearchRoleGroupsWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRoleGroupsResponse, error)

	SearchRoleGroupsWithResponse(ctx context.Context, roleId string, body SearchRoleGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRoleGroupsResponse, error)

	// UnassignARoleFromAGroupWithResponse request
	UnassignARoleFromAGroupWithResponse(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*UnassignARoleFromAGroupResponse, error)

	// AssignARoleToAGroupWithResponse request
	AssignARoleToAGroupWithResponse(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*AssignARoleToAGroupResponse, error)

	// SearchRoleMappingRulesWithBodyWithResponse request with any body
	SearchRoleMappingRulesWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRoleMappingRulesResponse, error)

	SearchRoleMappingRulesWithResponse(ctx context.Context, roleId string, body SearchRoleMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRoleMappingRulesResponse, error)

	// UnassignARoleFromAMappingRuleWithResponse request
	UnassignARoleFromAMappingRuleWithResponse(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignARoleFromAMappingRuleResponse, error)

	// AssignARoleToAMappingRuleWithResponse request
	AssignARoleToAMappingRuleWithResponse(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignARoleToAMappingRuleResponse, error)

	// SearchRoleUsersWithBodyWithResponse request with any body
	SearchRoleUsersWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRoleUsersResponse, error)

	SearchRoleUsersWithResponse(ctx context.Context, roleId string, body SearchRoleUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRoleUsersResponse, error)

	// UnassignARoleFromAUserWithResponse request
	UnassignARoleFromAUserWithResponse(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*UnassignARoleFromAUserResponse, error)

	// AssignARoleToAUserWithResponse request
	AssignARoleToAUserWithResponse(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*AssignARoleToAUserResponse, error)

	// CreateAdminUserWithBodyWithResponse request with any body
	CreateAdminUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminUserResponse, error)

	CreateAdminUserWithResponse(ctx context.Context, body CreateAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminUserResponse, error)

	// BroadcastSignalWithBodyWithResponse request with any body
	BroadcastSignalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error)

	BroadcastSignalWithResponse(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error)

	// GetClusterStatusWithResponse request
	GetClusterStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterStatusResponse, error)

	// GetUsageMetricsWithResponse request
	GetUsageMetricsWithResponse(ctx context.Context, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*GetUsageMetricsResponse, error)

	// CreateTenantWithBodyWithResponse request with any body
	CreateTenantWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error)

	CreateTenantWithResponse(ctx context.Context, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error)

	// SearchTenantsWithBodyWithResponse request with any body
	SearchTenantsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTenantsResponse, error)

	SearchTenantsWithResponse(ctx context.Context, body SearchTenantsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTenantsResponse, error)

	// DeleteTenantWithResponse request
	DeleteTenantWithResponse(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*DeleteTenantResponse, error)

	// GetTenantWithResponse request
	GetTenantWithResponse(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*GetTenantResponse, error)

	// UpdateTenantWithBodyWithResponse request with any body
	UpdateTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error)

	UpdateTenantWithResponse(ctx context.Context, tenantId TenantId, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error)

	// SearchClientsForTenantWithBodyWithResponse request with any body
	SearchClientsForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchClientsForTenantResponse, error)

	SearchClientsForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchClientsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchClientsForTenantResponse, error)

	// UnassignAClientFromATenantWithResponse request
	UnassignAClientFromATenantWithResponse(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*UnassignAClientFromATenantResponse, error)

	// AssignAClientToATenantWithResponse request
	AssignAClientToATenantWithResponse(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*AssignAClientToATenantResponse, error)

	// SearchGroupsForTenantWithBodyWithResponse request with any body
	SearchGroupsForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupsForTenantResponse, error)

	SearchGroupsForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchGroupsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupsForTenantResponse, error)

	// UnassignAGroupFromATenantWithResponse request
	UnassignAGroupFromATenantWithResponse(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*UnassignAGroupFromATenantResponse, error)

	// AssignAGroupToATenantWithResponse request
	AssignAGroupToATenantWithResponse(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*AssignAGroupToATenantResponse, error)

	// SearchMappingRulesForTenantWithBodyWithResponse request with any body
	SearchMappingRulesForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRulesForTenantResponse, error)

	SearchMappingRulesForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchMappingRulesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRulesForTenantResponse, error)

	// UnassignAMappingRuleFromATenantWithResponse request
	UnassignAMappingRuleFromATenantWithResponse(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignAMappingRuleFromATenantResponse, error)

	// AssignAMappingRuleToATenantWithResponse request
	AssignAMappingRuleToATenantWithResponse(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignAMappingRuleToATenantResponse, error)

	// SearchRolesForTenantWithBodyWithResponse request with any body
	SearchRolesForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRolesForTenantResponse, error)

	SearchRolesForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchRolesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRolesForTenantResponse, error)

	// UnassignARoleFromATenantWithResponse request
	UnassignARoleFromATenantWithResponse(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*UnassignARoleFromATenantResponse, error)

	// AssignARoleToATenantWithResponse request
	AssignARoleToATenantWithResponse(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*AssignARoleToATenantResponse, error)

	// SearchUsersForTenantWithBodyWithResponse request with any body
	SearchUsersForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersForTenantResponse, error)

	SearchUsersForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchUsersForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersForTenantResponse, error)

	// UnassignAUserFromATenantWithResponse request
	UnassignAUserFromATenantWithResponse(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*UnassignAUserFromATenantResponse, error)

	// AssignAUserToATenantWithResponse request
	AssignAUserToATenantWithResponse(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*AssignAUserToATenantResponse, error)

	// GetClusterTopologyWithResponse request
	GetClusterTopologyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterTopologyResponse, error)

	// SearchUserTasksWithBodyWithResponse request with any body
	SearchUserTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUserTasksResponse, error)

	SearchUserTasksWithResponse(ctx context.Context, body SearchUserTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUserTasksResponse, error)

	// GetUserTaskWithResponse request
	GetUserTaskWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*GetUserTaskResponse, error)

	// UpdateUserTaskWithBodyWithResponse request with any body
	UpdateUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error)

	UpdateUserTaskWithResponse(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error)

	// UnassignUserTaskWithResponse request
	UnassignUserTaskWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*UnassignUserTaskResponse, error)

	// AssignUserTaskWithBodyWithResponse request with any body
	AssignUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error)

	AssignUserTaskWithResponse(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error)

	// CompleteUserTaskWithBodyWithResponse request with any body
	CompleteUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error)

	CompleteUserTaskWithResponse(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error)

	// GetUserTaskFormWithResponse request
	GetUserTaskFormWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*GetUserTaskFormResponse, error)

	// SearchUserTaskVariablesWithBodyWithResponse request with any body
	SearchUserTaskVariablesWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUserTaskVariablesResponse, error)

	SearchUserTaskVariablesWithResponse(ctx context.Context, userTaskKey string, body SearchUserTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUserTaskVariablesResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// SearchUsersWithBodyWithResponse request with any body
	SearchUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error)

	SearchUsersWithResponse(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, username Username, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// SearchVariablesWithBodyWithResponse request with any body
	SearchVariablesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchVariablesResponse, error)

	SearchVariablesWithResponse(ctx context.Context, body SearchVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchVariablesResponse, error)

	// GetVariableWithResponse request
	GetVariableWithResponse(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*GetVariableResponse, error)
}

type GetCurrentUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CamundaUserResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuthorizationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *AuthorizationCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchAuthorizationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AuthorizationSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchAuthorizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchAuthorizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthorizationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorizationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AuthorizationResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAuthorizationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchBatchOperationItemsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationItemSearchQueryResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchBatchOperationItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchBatchOperationItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchBatchOperationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationSearchQueryResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchBatchOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchBatchOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationResponse
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CancelBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ResumeBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SuspendBatchOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r SuspendBatchOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SuspendBatchOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PinInternalClockAlphaResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PinInternalClockAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PinInternalClockAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetInternalClockAlphaResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ResetInternalClockAlphaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetInternalClockAlphaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EvaluateDecisionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *EvaluateDecisionResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r EvaluateDecisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EvaluateDecisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDecisionDefinitionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionDefinitionSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchDecisionDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDecisionDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionDefinitionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionDefinitionResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDecisionDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionDefinitionXmlResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDecisionDefinitionXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionDefinitionXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDecisionInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionInstanceSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchDecisionInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDecisionInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionInstanceGetQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDecisionInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDecisionRequirementsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionRequirementsSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchDecisionRequirementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDecisionRequirementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionRequirementsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionRequirementsResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDecisionRequirementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionRequirementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionRequirementsXmlResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDecisionRequirementsXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionRequirementsXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeployResourcesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DeploymentResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeployResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeployResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadDocumentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *DocumentReference
	ApplicationproblemJSON400 *InvalidData
}

// Status returns HTTPResponse.Status
func (r UploadDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadMultipleDocumentsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *DocumentCreationBatchResponse
	JSON207                   *DocumentCreationBatchResponse
	ApplicationproblemJSON400 *InvalidData
}

// Status returns HTTPResponse.Status
func (r UploadMultipleDocumentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadMultipleDocumentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDocumentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadDocumentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DownloadDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDocumentLinkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *DocumentLink
	ApplicationproblemJSON400 *InvalidData
}

// Status returns HTTPResponse.Status
func (r CreateDocumentLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDocumentLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateActivitiesWithinAnAdHocSubProcessResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ActivateActivitiesWithinAnAdHocSubProcessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateActivitiesWithinAnAdHocSubProcessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchElementInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ElementInstanceSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchElementInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchElementInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetElementInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ElementInstanceResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetElementInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetElementInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateElementInstanceVariablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateElementInstanceVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateElementInstanceVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *GroupCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGroupsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GroupSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r SearchGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GroupResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GroupUpdateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGroupClientsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GroupClientSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchGroupClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGroupClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignAClientFromAGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignAClientFromAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignAClientFromAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignAClientToAGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignAClientToAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignAClientToAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGroupMappingRulesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MappingRuleSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchGroupMappingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGroupMappingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignAMappingRuleFromAGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignAMappingRuleFromAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignAMappingRuleFromAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignAMappingRuleToAGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignAMappingRuleToAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignAMappingRuleToAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGroupRolesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchGroupRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGroupRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGroupUsersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GroupUserSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchGroupUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGroupUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignAUserFromAGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignAUserFromAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignAUserFromAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignAUserToAGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignAUserToAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignAUserToAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchIncidentsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *IncidentSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchIncidentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchIncidentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncidentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *IncidentResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetIncidentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncidentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveIncidentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ResolveIncidentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveIncidentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateJobsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *JobActivationResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ActivateJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchJobsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *JobSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CompleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThrowErrorForJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ThrowErrorForJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThrowErrorForJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FailJobResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r FailJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FailJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseStatusResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LicenseResponse
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetLicenseStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *MappingRuleCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMappingRulesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MappingRuleSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchMappingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMappingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteAMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MappingRuleResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MappingRuleUpdateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *ProblemDetail
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMessageSubscriptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MessageSubscriptionSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchMessageSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMessageSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CorrelateMessageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MessageCorrelationResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CorrelateMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CorrelateMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishMessageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MessagePublicationResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r PublishMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchProcessDefinitionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessDefinitionSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchProcessDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchProcessDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefinitionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessDefinitionResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessStartFormResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *FormResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessStartFormResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessStartFormResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefinitionStatisticsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessDefinitionElementStatisticsQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessDefinitionStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefinitionStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefinitionXmlResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessDefinitionXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefinitionXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CreateProcessInstanceResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
	ApplicationproblemJSON504 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CreateProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateABatchOperationToCancelProcessInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationCreatedResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateABatchOperationToCancelProcessInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateABatchOperationToCancelProcessInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateABatchOperationToResolveIncidentsOfProcessInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationCreatedResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateABatchOperationToResolveIncidentsOfProcessInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateABatchOperationToResolveIncidentsOfProcessInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateABatchOperationToMigrateProcessInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationCreatedResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateABatchOperationToMigrateProcessInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateABatchOperationToMigrateProcessInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateABatchOperationToModifyProcessInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BatchOperationCreatedResult
	ApplicationproblemJSON400 *ProblemDetail
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateABatchOperationToModifyProcessInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateABatchOperationToModifyProcessInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchProcessInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchProcessInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchProcessInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCallHierarchyForProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]ProcessInstanceCallHierarchyEntry
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCallHierarchyForProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCallHierarchyForProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CancelProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForIncidentsAssociatedWithAProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *IncidentSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchForIncidentsAssociatedWithAProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForIncidentsAssociatedWithAProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r MigrateProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyProcessInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r ModifyProcessInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyProcessInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessInstanceSequenceFlowsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceSequenceFlowsQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessInstanceSequenceFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessInstanceSequenceFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessInstanceStatisticsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceElementStatisticsQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProcessInstanceStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessInstanceStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResourceResult
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceContentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *string
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetResourceContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *RoleCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRolesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r SearchRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleUpdateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRoleClientsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleClientSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchRoleClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRoleClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignARoleFromAClientResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignARoleFromAClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignARoleFromAClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignARoleToAClientResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignARoleToAClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignARoleToAClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRoleGroupsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleGroupSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchRoleGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRoleGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignARoleFromAGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignARoleFromAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignARoleFromAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignARoleToAGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignARoleToAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignARoleToAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRoleMappingRulesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MappingRuleSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchRoleMappingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRoleMappingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignARoleFromAMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignARoleFromAMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignARoleFromAMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignARoleToAMappingRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignARoleToAMappingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignARoleToAMappingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRoleUsersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RoleUserSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchRoleUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRoleUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignARoleFromAUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignARoleFromAUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignARoleFromAUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignARoleToAUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignARoleToAUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignARoleToAUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAdminUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *UserCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateAdminUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAdminUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BroadcastSignalResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SignalBroadcastResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r BroadcastSignalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BroadcastSignalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetClusterStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageMetricsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UsageMetricsResponse
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUsageMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *TenantCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTenantsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TenantSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchTenantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTenantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TenantResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TenantUpdateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchClientsForTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantClientSearchResult
}

// Status returns HTTPResponse.Status
func (r SearchClientsForTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchClientsForTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignAClientFromATenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignAClientFromATenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignAClientFromATenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignAClientToATenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignAClientToATenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignAClientToATenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGroupsForTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantGroupSearchResult
}

// Status returns HTTPResponse.Status
func (r SearchGroupsForTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGroupsForTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignAGroupFromATenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignAGroupFromATenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignAGroupFromATenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignAGroupToATenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignAGroupToATenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignAGroupToATenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMappingRulesForTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MappingRuleSearchQueryResult
}

// Status returns HTTPResponse.Status
func (r SearchMappingRulesForTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMappingRulesForTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignAMappingRuleFromATenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignAMappingRuleFromATenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignAMappingRuleFromATenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignAMappingRuleToATenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignAMappingRuleToATenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignAMappingRuleToATenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRolesForTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleSearchQueryResult
}

// Status returns HTTPResponse.Status
func (r SearchRolesForTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRolesForTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignARoleFromATenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignARoleFromATenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignARoleFromATenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignARoleToATenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignARoleToATenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignARoleToATenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUsersForTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantUserSearchResult
}

// Status returns HTTPResponse.Status
func (r SearchUsersForTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUsersForTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignAUserFromATenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignAUserFromATenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignAUserFromATenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignAUserToATenantResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignAUserToATenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignAUserToATenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterTopologyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *TopologyResponse
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClusterTopologyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterTopologyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUserTasksResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UserTaskSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchUserTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUserTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UserTaskResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UnassignUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r AssignUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteUserTaskResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CompleteUserTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteUserTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserTaskFormResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *FormResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserTaskFormResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserTaskFormResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUserTaskVariablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *VariableSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchUserTaskVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUserTaskVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *UserCreateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON409 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUsersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UserSearchResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UserResult
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UserUpdateResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON503 *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchVariablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *VariableSearchQueryResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *VariableResult
	ApplicationproblemJSON400 *InvalidData
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *ProblemDetail
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// CreateAuthorizationWithBodyWithResponse request with arbitrary body returning *CreateAuthorizationResponse
func (c *ClientWithResponses) CreateAuthorizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthorizationResponse, error) {
	rsp, err := c.CreateAuthorizationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthorizationResponse(rsp)
}

func (c *ClientWithResponses) CreateAuthorizationWithResponse(ctx context.Context, body CreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthorizationResponse, error) {
	rsp, err := c.CreateAuthorization(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthorizationResponse(rsp)
}

// SearchAuthorizationsWithBodyWithResponse request with arbitrary body returning *SearchAuthorizationsResponse
func (c *ClientWithResponses) SearchAuthorizationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchAuthorizationsResponse, error) {
	rsp, err := c.SearchAuthorizationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchAuthorizationsResponse(rsp)
}

func (c *ClientWithResponses) SearchAuthorizationsWithResponse(ctx context.Context, body SearchAuthorizationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchAuthorizationsResponse, error) {
	rsp, err := c.SearchAuthorizations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchAuthorizationsResponse(rsp)
}

// DeleteAuthorizationWithResponse request returning *DeleteAuthorizationResponse
func (c *ClientWithResponses) DeleteAuthorizationWithResponse(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*DeleteAuthorizationResponse, error) {
	rsp, err := c.DeleteAuthorization(ctx, authorizationKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthorizationResponse(rsp)
}

// GetAuthorizationWithResponse request returning *GetAuthorizationResponse
func (c *ClientWithResponses) GetAuthorizationWithResponse(ctx context.Context, authorizationKey string, reqEditors ...RequestEditorFn) (*GetAuthorizationResponse, error) {
	rsp, err := c.GetAuthorization(ctx, authorizationKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorizationResponse(rsp)
}

// UpdateAuthorizationWithBodyWithResponse request with arbitrary body returning *UpdateAuthorizationResponse
func (c *ClientWithResponses) UpdateAuthorizationWithBodyWithResponse(ctx context.Context, authorizationKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAuthorizationResponse, error) {
	rsp, err := c.UpdateAuthorizationWithBody(ctx, authorizationKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAuthorizationResponse(rsp)
}

func (c *ClientWithResponses) UpdateAuthorizationWithResponse(ctx context.Context, authorizationKey string, body UpdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAuthorizationResponse, error) {
	rsp, err := c.UpdateAuthorization(ctx, authorizationKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAuthorizationResponse(rsp)
}

// SearchBatchOperationItemsWithBodyWithResponse request with arbitrary body returning *SearchBatchOperationItemsResponse
func (c *ClientWithResponses) SearchBatchOperationItemsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchBatchOperationItemsResponse, error) {
	rsp, err := c.SearchBatchOperationItemsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchBatchOperationItemsResponse(rsp)
}

func (c *ClientWithResponses) SearchBatchOperationItemsWithResponse(ctx context.Context, body SearchBatchOperationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchBatchOperationItemsResponse, error) {
	rsp, err := c.SearchBatchOperationItems(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchBatchOperationItemsResponse(rsp)
}

// SearchBatchOperationsWithBodyWithResponse request with arbitrary body returning *SearchBatchOperationsResponse
func (c *ClientWithResponses) SearchBatchOperationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchBatchOperationsResponse, error) {
	rsp, err := c.SearchBatchOperationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchBatchOperationsResponse(rsp)
}

func (c *ClientWithResponses) SearchBatchOperationsWithResponse(ctx context.Context, body SearchBatchOperationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchBatchOperationsResponse, error) {
	rsp, err := c.SearchBatchOperations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchBatchOperationsResponse(rsp)
}

// GetBatchOperationWithResponse request returning *GetBatchOperationResponse
func (c *ClientWithResponses) GetBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, reqEditors ...RequestEditorFn) (*GetBatchOperationResponse, error) {
	rsp, err := c.GetBatchOperation(ctx, batchOperationKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchOperationResponse(rsp)
}

// CancelBatchOperationWithBodyWithResponse request with arbitrary body returning *CancelBatchOperationResponse
func (c *ClientWithResponses) CancelBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelBatchOperationResponse, error) {
	rsp, err := c.CancelBatchOperationWithBody(ctx, batchOperationKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelBatchOperationResponse(rsp)
}

func (c *ClientWithResponses) CancelBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body CancelBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelBatchOperationResponse, error) {
	rsp, err := c.CancelBatchOperation(ctx, batchOperationKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelBatchOperationResponse(rsp)
}

// ResumeBatchOperationWithBodyWithResponse request with arbitrary body returning *ResumeBatchOperationResponse
func (c *ClientWithResponses) ResumeBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeBatchOperationResponse, error) {
	rsp, err := c.ResumeBatchOperationWithBody(ctx, batchOperationKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeBatchOperationResponse(rsp)
}

func (c *ClientWithResponses) ResumeBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body ResumeBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeBatchOperationResponse, error) {
	rsp, err := c.ResumeBatchOperation(ctx, batchOperationKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeBatchOperationResponse(rsp)
}

// SuspendBatchOperationWithBodyWithResponse request with arbitrary body returning *SuspendBatchOperationResponse
func (c *ClientWithResponses) SuspendBatchOperationWithBodyWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SuspendBatchOperationResponse, error) {
	rsp, err := c.SuspendBatchOperationWithBody(ctx, batchOperationKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendBatchOperationResponse(rsp)
}

func (c *ClientWithResponses) SuspendBatchOperationWithResponse(ctx context.Context, batchOperationKey BatchOperationKey, body SuspendBatchOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SuspendBatchOperationResponse, error) {
	rsp, err := c.SuspendBatchOperation(ctx, batchOperationKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendBatchOperationResponse(rsp)
}

// PinInternalClockAlphaWithBodyWithResponse request with arbitrary body returning *PinInternalClockAlphaResponse
func (c *ClientWithResponses) PinInternalClockAlphaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PinInternalClockAlphaResponse, error) {
	rsp, err := c.PinInternalClockAlphaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePinInternalClockAlphaResponse(rsp)
}

func (c *ClientWithResponses) PinInternalClockAlphaWithResponse(ctx context.Context, body PinInternalClockAlphaJSONRequestBody, reqEditors ...RequestEditorFn) (*PinInternalClockAlphaResponse, error) {
	rsp, err := c.PinInternalClockAlpha(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePinInternalClockAlphaResponse(rsp)
}

// ResetInternalClockAlphaWithResponse request returning *ResetInternalClockAlphaResponse
func (c *ClientWithResponses) ResetInternalClockAlphaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetInternalClockAlphaResponse, error) {
	rsp, err := c.ResetInternalClockAlpha(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetInternalClockAlphaResponse(rsp)
}

// EvaluateDecisionWithBodyWithResponse request with arbitrary body returning *EvaluateDecisionResponse
func (c *ClientWithResponses) EvaluateDecisionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error) {
	rsp, err := c.EvaluateDecisionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateDecisionResponse(rsp)
}

func (c *ClientWithResponses) EvaluateDecisionWithResponse(ctx context.Context, body EvaluateDecisionJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateDecisionResponse, error) {
	rsp, err := c.EvaluateDecision(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateDecisionResponse(rsp)
}

// SearchDecisionDefinitionsWithBodyWithResponse request with arbitrary body returning *SearchDecisionDefinitionsResponse
func (c *ClientWithResponses) SearchDecisionDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error) {
	rsp, err := c.SearchDecisionDefinitionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionDefinitionsResponse(rsp)
}

func (c *ClientWithResponses) SearchDecisionDefinitionsWithResponse(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error) {
	rsp, err := c.SearchDecisionDefinitions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionDefinitionsResponse(rsp)
}

// GetDecisionDefinitionWithResponse request returning *GetDecisionDefinitionResponse
func (c *ClientWithResponses) GetDecisionDefinitionWithResponse(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionResponse, error) {
	rsp, err := c.GetDecisionDefinition(ctx, decisionDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionDefinitionResponse(rsp)
}

// GetDecisionDefinitionXmlWithResponse request returning *GetDecisionDefinitionXmlResponse
func (c *ClientWithResponses) GetDecisionDefinitionXmlWithResponse(ctx context.Context, decisionDefinitionKey string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionXmlResponse, error) {
	rsp, err := c.GetDecisionDefinitionXml(ctx, decisionDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionDefinitionXmlResponse(rsp)
}

// SearchDecisionInstancesWithBodyWithResponse request with arbitrary body returning *SearchDecisionInstancesResponse
func (c *ClientWithResponses) SearchDecisionInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error) {
	rsp, err := c.SearchDecisionInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchDecisionInstancesWithResponse(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error) {
	rsp, err := c.SearchDecisionInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionInstancesResponse(rsp)
}

// GetDecisionInstanceWithResponse request returning *GetDecisionInstanceResponse
func (c *ClientWithResponses) GetDecisionInstanceWithResponse(ctx context.Context, decisionEvaluationInstanceKey string, reqEditors ...RequestEditorFn) (*GetDecisionInstanceResponse, error) {
	rsp, err := c.GetDecisionInstance(ctx, decisionEvaluationInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionInstanceResponse(rsp)
}

// SearchDecisionRequirementsWithBodyWithResponse request with arbitrary body returning *SearchDecisionRequirementsResponse
func (c *ClientWithResponses) SearchDecisionRequirementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error) {
	rsp, err := c.SearchDecisionRequirementsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionRequirementsResponse(rsp)
}

func (c *ClientWithResponses) SearchDecisionRequirementsWithResponse(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error) {
	rsp, err := c.SearchDecisionRequirements(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionRequirementsResponse(rsp)
}

// GetDecisionRequirementsWithResponse request returning *GetDecisionRequirementsResponse
func (c *ClientWithResponses) GetDecisionRequirementsWithResponse(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsResponse, error) {
	rsp, err := c.GetDecisionRequirements(ctx, decisionRequirementsKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionRequirementsResponse(rsp)
}

// GetDecisionRequirementsXmlWithResponse request returning *GetDecisionRequirementsXmlResponse
func (c *ClientWithResponses) GetDecisionRequirementsXmlWithResponse(ctx context.Context, decisionRequirementsKey string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsXmlResponse, error) {
	rsp, err := c.GetDecisionRequirementsXml(ctx, decisionRequirementsKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionRequirementsXmlResponse(rsp)
}

// DeployResourcesWithBodyWithResponse request with arbitrary body returning *DeployResourcesResponse
func (c *ClientWithResponses) DeployResourcesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployResourcesResponse, error) {
	rsp, err := c.DeployResourcesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployResourcesResponse(rsp)
}

// UploadDocumentWithBodyWithResponse request with arbitrary body returning *UploadDocumentResponse
func (c *ClientWithResponses) UploadDocumentWithBodyWithResponse(ctx context.Context, params *UploadDocumentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadDocumentResponse, error) {
	rsp, err := c.UploadDocumentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadDocumentResponse(rsp)
}

// UploadMultipleDocumentsWithBodyWithResponse request with arbitrary body returning *UploadMultipleDocumentsResponse
func (c *ClientWithResponses) UploadMultipleDocumentsWithBodyWithResponse(ctx context.Context, params *UploadMultipleDocumentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadMultipleDocumentsResponse, error) {
	rsp, err := c.UploadMultipleDocumentsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadMultipleDocumentsResponse(rsp)
}

// DeleteDocumentWithResponse request returning *DeleteDocumentResponse
func (c *ClientWithResponses) DeleteDocumentWithResponse(ctx context.Context, documentId DocumentId, params *DeleteDocumentParams, reqEditors ...RequestEditorFn) (*DeleteDocumentResponse, error) {
	rsp, err := c.DeleteDocument(ctx, documentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDocumentResponse(rsp)
}

// DownloadDocumentWithResponse request returning *DownloadDocumentResponse
func (c *ClientWithResponses) DownloadDocumentWithResponse(ctx context.Context, documentId DocumentId, params *DownloadDocumentParams, reqEditors ...RequestEditorFn) (*DownloadDocumentResponse, error) {
	rsp, err := c.DownloadDocument(ctx, documentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadDocumentResponse(rsp)
}

// CreateDocumentLinkWithBodyWithResponse request with arbitrary body returning *CreateDocumentLinkResponse
func (c *ClientWithResponses) CreateDocumentLinkWithBodyWithResponse(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error) {
	rsp, err := c.CreateDocumentLinkWithBody(ctx, documentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocumentLinkResponse(rsp)
}

func (c *ClientWithResponses) CreateDocumentLinkWithResponse(ctx context.Context, documentId DocumentId, params *CreateDocumentLinkParams, body CreateDocumentLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDocumentLinkResponse, error) {
	rsp, err := c.CreateDocumentLink(ctx, documentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocumentLinkResponse(rsp)
}

// ActivateActivitiesWithinAnAdHocSubProcessWithBodyWithResponse request with arbitrary body returning *ActivateActivitiesWithinAnAdHocSubProcessResponse
func (c *ClientWithResponses) ActivateActivitiesWithinAnAdHocSubProcessWithBodyWithResponse(ctx context.Context, adHocSubProcessInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateActivitiesWithinAnAdHocSubProcessResponse, error) {
	rsp, err := c.ActivateActivitiesWithinAnAdHocSubProcessWithBody(ctx, adHocSubProcessInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateActivitiesWithinAnAdHocSubProcessResponse(rsp)
}

func (c *ClientWithResponses) ActivateActivitiesWithinAnAdHocSubProcessWithResponse(ctx context.Context, adHocSubProcessInstanceKey string, body ActivateActivitiesWithinAnAdHocSubProcessJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateActivitiesWithinAnAdHocSubProcessResponse, error) {
	rsp, err := c.ActivateActivitiesWithinAnAdHocSubProcess(ctx, adHocSubProcessInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateActivitiesWithinAnAdHocSubProcessResponse(rsp)
}

// SearchElementInstancesWithBodyWithResponse request with arbitrary body returning *SearchElementInstancesResponse
func (c *ClientWithResponses) SearchElementInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchElementInstancesResponse, error) {
	rsp, err := c.SearchElementInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchElementInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchElementInstancesWithResponse(ctx context.Context, body SearchElementInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchElementInstancesResponse, error) {
	rsp, err := c.SearchElementInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchElementInstancesResponse(rsp)
}

// GetElementInstanceWithResponse request returning *GetElementInstanceResponse
func (c *ClientWithResponses) GetElementInstanceWithResponse(ctx context.Context, elementInstanceKey string, reqEditors ...RequestEditorFn) (*GetElementInstanceResponse, error) {
	rsp, err := c.GetElementInstance(ctx, elementInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetElementInstanceResponse(rsp)
}

// UpdateElementInstanceVariablesWithBodyWithResponse request with arbitrary body returning *UpdateElementInstanceVariablesResponse
func (c *ClientWithResponses) UpdateElementInstanceVariablesWithBodyWithResponse(ctx context.Context, elementInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateElementInstanceVariablesResponse, error) {
	rsp, err := c.UpdateElementInstanceVariablesWithBody(ctx, elementInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateElementInstanceVariablesResponse(rsp)
}

func (c *ClientWithResponses) UpdateElementInstanceVariablesWithResponse(ctx context.Context, elementInstanceKey string, body UpdateElementInstanceVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateElementInstanceVariablesResponse, error) {
	rsp, err := c.UpdateElementInstanceVariables(ctx, elementInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateElementInstanceVariablesResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// SearchGroupsWithBodyWithResponse request with arbitrary body returning *SearchGroupsResponse
func (c *ClientWithResponses) SearchGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupsResponse, error) {
	rsp, err := c.SearchGroupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupsResponse(rsp)
}

func (c *ClientWithResponses) SearchGroupsWithResponse(ctx context.Context, body SearchGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupsResponse, error) {
	rsp, err := c.SearchGroups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupsResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// UpdateGroupWithBodyWithResponse request with arbitrary body returning *UpdateGroupResponse
func (c *ClientWithResponses) UpdateGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupWithResponse(ctx context.Context, groupId string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

// SearchGroupClientsWithBodyWithResponse request with arbitrary body returning *SearchGroupClientsResponse
func (c *ClientWithResponses) SearchGroupClientsWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupClientsResponse, error) {
	rsp, err := c.SearchGroupClientsWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupClientsResponse(rsp)
}

func (c *ClientWithResponses) SearchGroupClientsWithResponse(ctx context.Context, groupId string, body SearchGroupClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupClientsResponse, error) {
	rsp, err := c.SearchGroupClients(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupClientsResponse(rsp)
}

// UnassignAClientFromAGroupWithResponse request returning *UnassignAClientFromAGroupResponse
func (c *ClientWithResponses) UnassignAClientFromAGroupWithResponse(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*UnassignAClientFromAGroupResponse, error) {
	rsp, err := c.UnassignAClientFromAGroup(ctx, groupId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignAClientFromAGroupResponse(rsp)
}

// AssignAClientToAGroupWithResponse request returning *AssignAClientToAGroupResponse
func (c *ClientWithResponses) AssignAClientToAGroupWithResponse(ctx context.Context, groupId string, clientId string, reqEditors ...RequestEditorFn) (*AssignAClientToAGroupResponse, error) {
	rsp, err := c.AssignAClientToAGroup(ctx, groupId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignAClientToAGroupResponse(rsp)
}

// SearchGroupMappingRulesWithBodyWithResponse request with arbitrary body returning *SearchGroupMappingRulesResponse
func (c *ClientWithResponses) SearchGroupMappingRulesWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupMappingRulesResponse, error) {
	rsp, err := c.SearchGroupMappingRulesWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupMappingRulesResponse(rsp)
}

func (c *ClientWithResponses) SearchGroupMappingRulesWithResponse(ctx context.Context, groupId string, body SearchGroupMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupMappingRulesResponse, error) {
	rsp, err := c.SearchGroupMappingRules(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupMappingRulesResponse(rsp)
}

// UnassignAMappingRuleFromAGroupWithResponse request returning *UnassignAMappingRuleFromAGroupResponse
func (c *ClientWithResponses) UnassignAMappingRuleFromAGroupWithResponse(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignAMappingRuleFromAGroupResponse, error) {
	rsp, err := c.UnassignAMappingRuleFromAGroup(ctx, groupId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignAMappingRuleFromAGroupResponse(rsp)
}

// AssignAMappingRuleToAGroupWithResponse request returning *AssignAMappingRuleToAGroupResponse
func (c *ClientWithResponses) AssignAMappingRuleToAGroupWithResponse(ctx context.Context, groupId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignAMappingRuleToAGroupResponse, error) {
	rsp, err := c.AssignAMappingRuleToAGroup(ctx, groupId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignAMappingRuleToAGroupResponse(rsp)
}

// SearchGroupRolesWithBodyWithResponse request with arbitrary body returning *SearchGroupRolesResponse
func (c *ClientWithResponses) SearchGroupRolesWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupRolesResponse, error) {
	rsp, err := c.SearchGroupRolesWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupRolesResponse(rsp)
}

func (c *ClientWithResponses) SearchGroupRolesWithResponse(ctx context.Context, groupId string, body SearchGroupRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupRolesResponse, error) {
	rsp, err := c.SearchGroupRoles(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupRolesResponse(rsp)
}

// SearchGroupUsersWithBodyWithResponse request with arbitrary body returning *SearchGroupUsersResponse
func (c *ClientWithResponses) SearchGroupUsersWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupUsersResponse, error) {
	rsp, err := c.SearchGroupUsersWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupUsersResponse(rsp)
}

func (c *ClientWithResponses) SearchGroupUsersWithResponse(ctx context.Context, groupId string, body SearchGroupUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupUsersResponse, error) {
	rsp, err := c.SearchGroupUsers(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupUsersResponse(rsp)
}

// UnassignAUserFromAGroupWithResponse request returning *UnassignAUserFromAGroupResponse
func (c *ClientWithResponses) UnassignAUserFromAGroupWithResponse(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*UnassignAUserFromAGroupResponse, error) {
	rsp, err := c.UnassignAUserFromAGroup(ctx, groupId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignAUserFromAGroupResponse(rsp)
}

// AssignAUserToAGroupWithResponse request returning *AssignAUserToAGroupResponse
func (c *ClientWithResponses) AssignAUserToAGroupWithResponse(ctx context.Context, groupId string, username Username, reqEditors ...RequestEditorFn) (*AssignAUserToAGroupResponse, error) {
	rsp, err := c.AssignAUserToAGroup(ctx, groupId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignAUserToAGroupResponse(rsp)
}

// SearchIncidentsWithBodyWithResponse request with arbitrary body returning *SearchIncidentsResponse
func (c *ClientWithResponses) SearchIncidentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error) {
	rsp, err := c.SearchIncidentsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchIncidentsResponse(rsp)
}

func (c *ClientWithResponses) SearchIncidentsWithResponse(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error) {
	rsp, err := c.SearchIncidents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchIncidentsResponse(rsp)
}

// GetIncidentWithResponse request returning *GetIncidentResponse
func (c *ClientWithResponses) GetIncidentWithResponse(ctx context.Context, incidentKey string, reqEditors ...RequestEditorFn) (*GetIncidentResponse, error) {
	rsp, err := c.GetIncident(ctx, incidentKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncidentResponse(rsp)
}

// ResolveIncidentWithBodyWithResponse request with arbitrary body returning *ResolveIncidentResponse
func (c *ClientWithResponses) ResolveIncidentWithBodyWithResponse(ctx context.Context, incidentKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolveIncidentResponse, error) {
	rsp, err := c.ResolveIncidentWithBody(ctx, incidentKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveIncidentResponse(rsp)
}

func (c *ClientWithResponses) ResolveIncidentWithResponse(ctx context.Context, incidentKey string, body ResolveIncidentJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolveIncidentResponse, error) {
	rsp, err := c.ResolveIncident(ctx, incidentKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveIncidentResponse(rsp)
}

// ActivateJobsWithBodyWithResponse request with arbitrary body returning *ActivateJobsResponse
func (c *ClientWithResponses) ActivateJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error) {
	rsp, err := c.ActivateJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateJobsResponse(rsp)
}

func (c *ClientWithResponses) ActivateJobsWithResponse(ctx context.Context, body ActivateJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateJobsResponse, error) {
	rsp, err := c.ActivateJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateJobsResponse(rsp)
}

// SearchJobsWithBodyWithResponse request with arbitrary body returning *SearchJobsResponse
func (c *ClientWithResponses) SearchJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchJobsResponse, error) {
	rsp, err := c.SearchJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchJobsResponse(rsp)
}

func (c *ClientWithResponses) SearchJobsWithResponse(ctx context.Context, body SearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchJobsResponse, error) {
	rsp, err := c.SearchJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchJobsResponse(rsp)
}

// UpdateJobWithBodyWithResponse request with arbitrary body returning *UpdateJobResponse
func (c *ClientWithResponses) UpdateJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

func (c *ClientWithResponses) UpdateJobWithResponse(ctx context.Context, jobKey string, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

// CompleteJobWithBodyWithResponse request with arbitrary body returning *CompleteJobResponse
func (c *ClientWithResponses) CompleteJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error) {
	rsp, err := c.CompleteJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteJobResponse(rsp)
}

func (c *ClientWithResponses) CompleteJobWithResponse(ctx context.Context, jobKey string, body CompleteJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteJobResponse, error) {
	rsp, err := c.CompleteJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteJobResponse(rsp)
}

// ThrowErrorForJobWithBodyWithResponse request with arbitrary body returning *ThrowErrorForJobResponse
func (c *ClientWithResponses) ThrowErrorForJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ThrowErrorForJobResponse, error) {
	rsp, err := c.ThrowErrorForJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThrowErrorForJobResponse(rsp)
}

func (c *ClientWithResponses) ThrowErrorForJobWithResponse(ctx context.Context, jobKey string, body ThrowErrorForJobJSONRequestBody, reqEditors ...RequestEditorFn) (*ThrowErrorForJobResponse, error) {
	rsp, err := c.ThrowErrorForJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThrowErrorForJobResponse(rsp)
}

// FailJobWithBodyWithResponse request with arbitrary body returning *FailJobResponse
func (c *ClientWithResponses) FailJobWithBodyWithResponse(ctx context.Context, jobKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FailJobResponse, error) {
	rsp, err := c.FailJobWithBody(ctx, jobKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFailJobResponse(rsp)
}

func (c *ClientWithResponses) FailJobWithResponse(ctx context.Context, jobKey string, body FailJobJSONRequestBody, reqEditors ...RequestEditorFn) (*FailJobResponse, error) {
	rsp, err := c.FailJob(ctx, jobKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFailJobResponse(rsp)
}

// GetLicenseStatusWithResponse request returning *GetLicenseStatusResponse
func (c *ClientWithResponses) GetLicenseStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseStatusResponse, error) {
	rsp, err := c.GetLicenseStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseStatusResponse(rsp)
}

// CreateMappingRuleWithBodyWithResponse request with arbitrary body returning *CreateMappingRuleResponse
func (c *ClientWithResponses) CreateMappingRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMappingRuleResponse, error) {
	rsp, err := c.CreateMappingRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMappingRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateMappingRuleWithResponse(ctx context.Context, body CreateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMappingRuleResponse, error) {
	rsp, err := c.CreateMappingRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMappingRuleResponse(rsp)
}

// SearchMappingRulesWithBodyWithResponse request with arbitrary body returning *SearchMappingRulesResponse
func (c *ClientWithResponses) SearchMappingRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRulesResponse, error) {
	rsp, err := c.SearchMappingRulesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRulesResponse(rsp)
}

func (c *ClientWithResponses) SearchMappingRulesWithResponse(ctx context.Context, body SearchMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRulesResponse, error) {
	rsp, err := c.SearchMappingRules(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRulesResponse(rsp)
}

// DeleteAMappingRuleWithResponse request returning *DeleteAMappingRuleResponse
func (c *ClientWithResponses) DeleteAMappingRuleWithResponse(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*DeleteAMappingRuleResponse, error) {
	rsp, err := c.DeleteAMappingRule(ctx, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAMappingRuleResponse(rsp)
}

// GetAMappingRuleWithResponse request returning *GetAMappingRuleResponse
func (c *ClientWithResponses) GetAMappingRuleWithResponse(ctx context.Context, mappingRuleId string, reqEditors ...RequestEditorFn) (*GetAMappingRuleResponse, error) {
	rsp, err := c.GetAMappingRule(ctx, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAMappingRuleResponse(rsp)
}

// UpdateMappingRuleWithBodyWithResponse request with arbitrary body returning *UpdateMappingRuleResponse
func (c *ClientWithResponses) UpdateMappingRuleWithBodyWithResponse(ctx context.Context, mappingRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMappingRuleResponse, error) {
	rsp, err := c.UpdateMappingRuleWithBody(ctx, mappingRuleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMappingRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateMappingRuleWithResponse(ctx context.Context, mappingRuleId string, body UpdateMappingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMappingRuleResponse, error) {
	rsp, err := c.UpdateMappingRule(ctx, mappingRuleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMappingRuleResponse(rsp)
}

// SearchMessageSubscriptionsWithBodyWithResponse request with arbitrary body returning *SearchMessageSubscriptionsResponse
func (c *ClientWithResponses) SearchMessageSubscriptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMessageSubscriptionsResponse, error) {
	rsp, err := c.SearchMessageSubscriptionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMessageSubscriptionsResponse(rsp)
}

func (c *ClientWithResponses) SearchMessageSubscriptionsWithResponse(ctx context.Context, body SearchMessageSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMessageSubscriptionsResponse, error) {
	rsp, err := c.SearchMessageSubscriptions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMessageSubscriptionsResponse(rsp)
}

// CorrelateMessageWithBodyWithResponse request with arbitrary body returning *CorrelateMessageResponse
func (c *ClientWithResponses) CorrelateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CorrelateMessageResponse, error) {
	rsp, err := c.CorrelateMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCorrelateMessageResponse(rsp)
}

func (c *ClientWithResponses) CorrelateMessageWithResponse(ctx context.Context, body CorrelateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CorrelateMessageResponse, error) {
	rsp, err := c.CorrelateMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCorrelateMessageResponse(rsp)
}

// PublishMessageWithBodyWithResponse request with arbitrary body returning *PublishMessageResponse
func (c *ClientWithResponses) PublishMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishMessageResponse, error) {
	rsp, err := c.PublishMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishMessageResponse(rsp)
}

func (c *ClientWithResponses) PublishMessageWithResponse(ctx context.Context, body PublishMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishMessageResponse, error) {
	rsp, err := c.PublishMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishMessageResponse(rsp)
}

// SearchProcessDefinitionsWithBodyWithResponse request with arbitrary body returning *SearchProcessDefinitionsResponse
func (c *ClientWithResponses) SearchProcessDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error) {
	rsp, err := c.SearchProcessDefinitionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessDefinitionsResponse(rsp)
}

func (c *ClientWithResponses) SearchProcessDefinitionsWithResponse(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error) {
	rsp, err := c.SearchProcessDefinitions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessDefinitionsResponse(rsp)
}

// GetProcessDefinitionWithResponse request returning *GetProcessDefinitionResponse
func (c *ClientWithResponses) GetProcessDefinitionWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionResponse, error) {
	rsp, err := c.GetProcessDefinition(ctx, processDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionResponse(rsp)
}

// GetProcessStartFormWithResponse request returning *GetProcessStartFormResponse
func (c *ClientWithResponses) GetProcessStartFormWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetProcessStartFormResponse, error) {
	rsp, err := c.GetProcessStartForm(ctx, processDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessStartFormResponse(rsp)
}

// GetProcessDefinitionStatisticsWithBodyWithResponse request with arbitrary body returning *GetProcessDefinitionStatisticsResponse
func (c *ClientWithResponses) GetProcessDefinitionStatisticsWithBodyWithResponse(ctx context.Context, processDefinitionKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetProcessDefinitionStatisticsResponse, error) {
	rsp, err := c.GetProcessDefinitionStatisticsWithBody(ctx, processDefinitionKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionStatisticsResponse(rsp)
}

func (c *ClientWithResponses) GetProcessDefinitionStatisticsWithResponse(ctx context.Context, processDefinitionKey string, body GetProcessDefinitionStatisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetProcessDefinitionStatisticsResponse, error) {
	rsp, err := c.GetProcessDefinitionStatistics(ctx, processDefinitionKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionStatisticsResponse(rsp)
}

// GetProcessDefinitionXmlWithResponse request returning *GetProcessDefinitionXmlResponse
func (c *ClientWithResponses) GetProcessDefinitionXmlWithResponse(ctx context.Context, processDefinitionKey string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionXmlResponse, error) {
	rsp, err := c.GetProcessDefinitionXml(ctx, processDefinitionKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionXmlResponse(rsp)
}

// CreateProcessInstanceWithBodyWithResponse request with arbitrary body returning *CreateProcessInstanceResponse
func (c *ClientWithResponses) CreateProcessInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error) {
	rsp, err := c.CreateProcessInstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) CreateProcessInstanceWithResponse(ctx context.Context, body CreateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProcessInstanceResponse, error) {
	rsp, err := c.CreateProcessInstance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProcessInstanceResponse(rsp)
}

// CreateABatchOperationToCancelProcessInstancesWithBodyWithResponse request with arbitrary body returning *CreateABatchOperationToCancelProcessInstancesResponse
func (c *ClientWithResponses) CreateABatchOperationToCancelProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateABatchOperationToCancelProcessInstancesResponse, error) {
	rsp, err := c.CreateABatchOperationToCancelProcessInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateABatchOperationToCancelProcessInstancesResponse(rsp)
}

func (c *ClientWithResponses) CreateABatchOperationToCancelProcessInstancesWithResponse(ctx context.Context, body CreateABatchOperationToCancelProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateABatchOperationToCancelProcessInstancesResponse, error) {
	rsp, err := c.CreateABatchOperationToCancelProcessInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateABatchOperationToCancelProcessInstancesResponse(rsp)
}

// CreateABatchOperationToResolveIncidentsOfProcessInstancesWithBodyWithResponse request with arbitrary body returning *CreateABatchOperationToResolveIncidentsOfProcessInstancesResponse
func (c *ClientWithResponses) CreateABatchOperationToResolveIncidentsOfProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateABatchOperationToResolveIncidentsOfProcessInstancesResponse, error) {
	rsp, err := c.CreateABatchOperationToResolveIncidentsOfProcessInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateABatchOperationToResolveIncidentsOfProcessInstancesResponse(rsp)
}

func (c *ClientWithResponses) CreateABatchOperationToResolveIncidentsOfProcessInstancesWithResponse(ctx context.Context, body CreateABatchOperationToResolveIncidentsOfProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateABatchOperationToResolveIncidentsOfProcessInstancesResponse, error) {
	rsp, err := c.CreateABatchOperationToResolveIncidentsOfProcessInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateABatchOperationToResolveIncidentsOfProcessInstancesResponse(rsp)
}

// CreateABatchOperationToMigrateProcessInstancesWithBodyWithResponse request with arbitrary body returning *CreateABatchOperationToMigrateProcessInstancesResponse
func (c *ClientWithResponses) CreateABatchOperationToMigrateProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateABatchOperationToMigrateProcessInstancesResponse, error) {
	rsp, err := c.CreateABatchOperationToMigrateProcessInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateABatchOperationToMigrateProcessInstancesResponse(rsp)
}

func (c *ClientWithResponses) CreateABatchOperationToMigrateProcessInstancesWithResponse(ctx context.Context, body CreateABatchOperationToMigrateProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateABatchOperationToMigrateProcessInstancesResponse, error) {
	rsp, err := c.CreateABatchOperationToMigrateProcessInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateABatchOperationToMigrateProcessInstancesResponse(rsp)
}

// CreateABatchOperationToModifyProcessInstancesWithBodyWithResponse request with arbitrary body returning *CreateABatchOperationToModifyProcessInstancesResponse
func (c *ClientWithResponses) CreateABatchOperationToModifyProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateABatchOperationToModifyProcessInstancesResponse, error) {
	rsp, err := c.CreateABatchOperationToModifyProcessInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateABatchOperationToModifyProcessInstancesResponse(rsp)
}

func (c *ClientWithResponses) CreateABatchOperationToModifyProcessInstancesWithResponse(ctx context.Context, body CreateABatchOperationToModifyProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateABatchOperationToModifyProcessInstancesResponse, error) {
	rsp, err := c.CreateABatchOperationToModifyProcessInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateABatchOperationToModifyProcessInstancesResponse(rsp)
}

// SearchProcessInstancesWithBodyWithResponse request with arbitrary body returning *SearchProcessInstancesResponse
func (c *ClientWithResponses) SearchProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error) {
	rsp, err := c.SearchProcessInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchProcessInstancesWithResponse(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error) {
	rsp, err := c.SearchProcessInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessInstancesResponse(rsp)
}

// GetProcessInstanceWithResponse request returning *GetProcessInstanceResponse
func (c *ClientWithResponses) GetProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceResponse, error) {
	rsp, err := c.GetProcessInstance(ctx, processInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessInstanceResponse(rsp)
}

// GetCallHierarchyForProcessInstanceWithResponse request returning *GetCallHierarchyForProcessInstanceResponse
func (c *ClientWithResponses) GetCallHierarchyForProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetCallHierarchyForProcessInstanceResponse, error) {
	rsp, err := c.GetCallHierarchyForProcessInstance(ctx, processInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCallHierarchyForProcessInstanceResponse(rsp)
}

// CancelProcessInstanceWithBodyWithResponse request with arbitrary body returning *CancelProcessInstanceResponse
func (c *ClientWithResponses) CancelProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error) {
	rsp, err := c.CancelProcessInstanceWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) CancelProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body CancelProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelProcessInstanceResponse, error) {
	rsp, err := c.CancelProcessInstance(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelProcessInstanceResponse(rsp)
}

// SearchForIncidentsAssociatedWithAProcessInstanceWithBodyWithResponse request with arbitrary body returning *SearchForIncidentsAssociatedWithAProcessInstanceResponse
func (c *ClientWithResponses) SearchForIncidentsAssociatedWithAProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForIncidentsAssociatedWithAProcessInstanceResponse, error) {
	rsp, err := c.SearchForIncidentsAssociatedWithAProcessInstanceWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForIncidentsAssociatedWithAProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) SearchForIncidentsAssociatedWithAProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body SearchForIncidentsAssociatedWithAProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForIncidentsAssociatedWithAProcessInstanceResponse, error) {
	rsp, err := c.SearchForIncidentsAssociatedWithAProcessInstance(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForIncidentsAssociatedWithAProcessInstanceResponse(rsp)
}

// MigrateProcessInstanceWithBodyWithResponse request with arbitrary body returning *MigrateProcessInstanceResponse
func (c *ClientWithResponses) MigrateProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error) {
	rsp, err := c.MigrateProcessInstanceWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) MigrateProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body MigrateProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateProcessInstanceResponse, error) {
	rsp, err := c.MigrateProcessInstance(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateProcessInstanceResponse(rsp)
}

// ModifyProcessInstanceWithBodyWithResponse request with arbitrary body returning *ModifyProcessInstanceResponse
func (c *ClientWithResponses) ModifyProcessInstanceWithBodyWithResponse(ctx context.Context, processInstanceKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error) {
	rsp, err := c.ModifyProcessInstanceWithBody(ctx, processInstanceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProcessInstanceResponse(rsp)
}

func (c *ClientWithResponses) ModifyProcessInstanceWithResponse(ctx context.Context, processInstanceKey string, body ModifyProcessInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProcessInstanceResponse, error) {
	rsp, err := c.ModifyProcessInstance(ctx, processInstanceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProcessInstanceResponse(rsp)
}

// GetProcessInstanceSequenceFlowsWithResponse request returning *GetProcessInstanceSequenceFlowsResponse
func (c *ClientWithResponses) GetProcessInstanceSequenceFlowsWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceSequenceFlowsResponse, error) {
	rsp, err := c.GetProcessInstanceSequenceFlows(ctx, processInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessInstanceSequenceFlowsResponse(rsp)
}

// GetProcessInstanceStatisticsWithResponse request returning *GetProcessInstanceStatisticsResponse
func (c *ClientWithResponses) GetProcessInstanceStatisticsWithResponse(ctx context.Context, processInstanceKey string, reqEditors ...RequestEditorFn) (*GetProcessInstanceStatisticsResponse, error) {
	rsp, err := c.GetProcessInstanceStatistics(ctx, processInstanceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessInstanceStatisticsResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, resourceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetResourceContentWithResponse request returning *GetResourceContentResponse
func (c *ClientWithResponses) GetResourceContentWithResponse(ctx context.Context, resourceKey ResourceKey, reqEditors ...RequestEditorFn) (*GetResourceContentResponse, error) {
	rsp, err := c.GetResourceContent(ctx, resourceKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceContentResponse(rsp)
}

// DeleteResourceWithBodyWithResponse request with arbitrary body returning *DeleteResourceResponse
func (c *ClientWithResponses) DeleteResourceWithBodyWithResponse(ctx context.Context, resourceKey ResourceKey, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResourceWithBody(ctx, resourceKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

func (c *ClientWithResponses) DeleteResourceWithResponse(ctx context.Context, resourceKey ResourceKey, body DeleteResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResource(ctx, resourceKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

// CreateRoleWithBodyWithResponse request with arbitrary body returning *CreateRoleResponse
func (c *ClientWithResponses) CreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleWithResponse(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

// SearchRolesWithBodyWithResponse request with arbitrary body returning *SearchRolesResponse
func (c *ClientWithResponses) SearchRolesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRolesResponse, error) {
	rsp, err := c.SearchRolesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRolesResponse(rsp)
}

func (c *ClientWithResponses) SearchRolesWithResponse(ctx context.Context, body SearchRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRolesResponse, error) {
	rsp, err := c.SearchRoles(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRolesResponse(rsp)
}

// DeleteRoleWithResponse request returning *DeleteRoleResponse
func (c *ClientWithResponses) DeleteRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error) {
	rsp, err := c.DeleteRole(ctx, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// UpdateRoleWithBodyWithResponse request with arbitrary body returning *UpdateRoleResponse
func (c *ClientWithResponses) UpdateRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRoleWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleWithResponse(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRole(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

// SearchRoleClientsWithBodyWithResponse request with arbitrary body returning *SearchRoleClientsResponse
func (c *ClientWithResponses) SearchRoleClientsWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRoleClientsResponse, error) {
	rsp, err := c.SearchRoleClientsWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRoleClientsResponse(rsp)
}

func (c *ClientWithResponses) SearchRoleClientsWithResponse(ctx context.Context, roleId string, body SearchRoleClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRoleClientsResponse, error) {
	rsp, err := c.SearchRoleClients(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRoleClientsResponse(rsp)
}

// UnassignARoleFromAClientWithResponse request returning *UnassignARoleFromAClientResponse
func (c *ClientWithResponses) UnassignARoleFromAClientWithResponse(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*UnassignARoleFromAClientResponse, error) {
	rsp, err := c.UnassignARoleFromAClient(ctx, roleId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignARoleFromAClientResponse(rsp)
}

// AssignARoleToAClientWithResponse request returning *AssignARoleToAClientResponse
func (c *ClientWithResponses) AssignARoleToAClientWithResponse(ctx context.Context, roleId string, clientId string, reqEditors ...RequestEditorFn) (*AssignARoleToAClientResponse, error) {
	rsp, err := c.AssignARoleToAClient(ctx, roleId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignARoleToAClientResponse(rsp)
}

// SearchRoleGroupsWithBodyWithResponse request with arbitrary body returning *SearchRoleGroupsResponse
func (c *ClientWithResponses) SearchRoleGroupsWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRoleGroupsResponse, error) {
	rsp, err := c.SearchRoleGroupsWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRoleGroupsResponse(rsp)
}

func (c *ClientWithResponses) SearchRoleGroupsWithResponse(ctx context.Context, roleId string, body SearchRoleGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRoleGroupsResponse, error) {
	rsp, err := c.SearchRoleGroups(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRoleGroupsResponse(rsp)
}

// UnassignARoleFromAGroupWithResponse request returning *UnassignARoleFromAGroupResponse
func (c *ClientWithResponses) UnassignARoleFromAGroupWithResponse(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*UnassignARoleFromAGroupResponse, error) {
	rsp, err := c.UnassignARoleFromAGroup(ctx, roleId, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignARoleFromAGroupResponse(rsp)
}

// AssignARoleToAGroupWithResponse request returning *AssignARoleToAGroupResponse
func (c *ClientWithResponses) AssignARoleToAGroupWithResponse(ctx context.Context, roleId string, groupId string, reqEditors ...RequestEditorFn) (*AssignARoleToAGroupResponse, error) {
	rsp, err := c.AssignARoleToAGroup(ctx, roleId, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignARoleToAGroupResponse(rsp)
}

// SearchRoleMappingRulesWithBodyWithResponse request with arbitrary body returning *SearchRoleMappingRulesResponse
func (c *ClientWithResponses) SearchRoleMappingRulesWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRoleMappingRulesResponse, error) {
	rsp, err := c.SearchRoleMappingRulesWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRoleMappingRulesResponse(rsp)
}

func (c *ClientWithResponses) SearchRoleMappingRulesWithResponse(ctx context.Context, roleId string, body SearchRoleMappingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRoleMappingRulesResponse, error) {
	rsp, err := c.SearchRoleMappingRules(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRoleMappingRulesResponse(rsp)
}

// UnassignARoleFromAMappingRuleWithResponse request returning *UnassignARoleFromAMappingRuleResponse
func (c *ClientWithResponses) UnassignARoleFromAMappingRuleWithResponse(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignARoleFromAMappingRuleResponse, error) {
	rsp, err := c.UnassignARoleFromAMappingRule(ctx, roleId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignARoleFromAMappingRuleResponse(rsp)
}

// AssignARoleToAMappingRuleWithResponse request returning *AssignARoleToAMappingRuleResponse
func (c *ClientWithResponses) AssignARoleToAMappingRuleWithResponse(ctx context.Context, roleId string, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignARoleToAMappingRuleResponse, error) {
	rsp, err := c.AssignARoleToAMappingRule(ctx, roleId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignARoleToAMappingRuleResponse(rsp)
}

// SearchRoleUsersWithBodyWithResponse request with arbitrary body returning *SearchRoleUsersResponse
func (c *ClientWithResponses) SearchRoleUsersWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRoleUsersResponse, error) {
	rsp, err := c.SearchRoleUsersWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRoleUsersResponse(rsp)
}

func (c *ClientWithResponses) SearchRoleUsersWithResponse(ctx context.Context, roleId string, body SearchRoleUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRoleUsersResponse, error) {
	rsp, err := c.SearchRoleUsers(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRoleUsersResponse(rsp)
}

// UnassignARoleFromAUserWithResponse request returning *UnassignARoleFromAUserResponse
func (c *ClientWithResponses) UnassignARoleFromAUserWithResponse(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*UnassignARoleFromAUserResponse, error) {
	rsp, err := c.UnassignARoleFromAUser(ctx, roleId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignARoleFromAUserResponse(rsp)
}

// AssignARoleToAUserWithResponse request returning *AssignARoleToAUserResponse
func (c *ClientWithResponses) AssignARoleToAUserWithResponse(ctx context.Context, roleId string, username Username, reqEditors ...RequestEditorFn) (*AssignARoleToAUserResponse, error) {
	rsp, err := c.AssignARoleToAUser(ctx, roleId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignARoleToAUserResponse(rsp)
}

// CreateAdminUserWithBodyWithResponse request with arbitrary body returning *CreateAdminUserResponse
func (c *ClientWithResponses) CreateAdminUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminUserResponse, error) {
	rsp, err := c.CreateAdminUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminUserResponse(rsp)
}

func (c *ClientWithResponses) CreateAdminUserWithResponse(ctx context.Context, body CreateAdminUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminUserResponse, error) {
	rsp, err := c.CreateAdminUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminUserResponse(rsp)
}

// BroadcastSignalWithBodyWithResponse request with arbitrary body returning *BroadcastSignalResponse
func (c *ClientWithResponses) BroadcastSignalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error) {
	rsp, err := c.BroadcastSignalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBroadcastSignalResponse(rsp)
}

func (c *ClientWithResponses) BroadcastSignalWithResponse(ctx context.Context, body BroadcastSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*BroadcastSignalResponse, error) {
	rsp, err := c.BroadcastSignal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBroadcastSignalResponse(rsp)
}

// GetClusterStatusWithResponse request returning *GetClusterStatusResponse
func (c *ClientWithResponses) GetClusterStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterStatusResponse, error) {
	rsp, err := c.GetClusterStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterStatusResponse(rsp)
}

// GetUsageMetricsWithResponse request returning *GetUsageMetricsResponse
func (c *ClientWithResponses) GetUsageMetricsWithResponse(ctx context.Context, params *GetUsageMetricsParams, reqEditors ...RequestEditorFn) (*GetUsageMetricsResponse, error) {
	rsp, err := c.GetUsageMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageMetricsResponse(rsp)
}

// CreateTenantWithBodyWithResponse request with arbitrary body returning *CreateTenantResponse
func (c *ClientWithResponses) CreateTenantWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error) {
	rsp, err := c.CreateTenantWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantResponse(rsp)
}

func (c *ClientWithResponses) CreateTenantWithResponse(ctx context.Context, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error) {
	rsp, err := c.CreateTenant(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantResponse(rsp)
}

// SearchTenantsWithBodyWithResponse request with arbitrary body returning *SearchTenantsResponse
func (c *ClientWithResponses) SearchTenantsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTenantsResponse, error) {
	rsp, err := c.SearchTenantsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTenantsResponse(rsp)
}

func (c *ClientWithResponses) SearchTenantsWithResponse(ctx context.Context, body SearchTenantsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTenantsResponse, error) {
	rsp, err := c.SearchTenants(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTenantsResponse(rsp)
}

// DeleteTenantWithResponse request returning *DeleteTenantResponse
func (c *ClientWithResponses) DeleteTenantWithResponse(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*DeleteTenantResponse, error) {
	rsp, err := c.DeleteTenant(ctx, tenantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTenantResponse(rsp)
}

// GetTenantWithResponse request returning *GetTenantResponse
func (c *ClientWithResponses) GetTenantWithResponse(ctx context.Context, tenantId TenantId, reqEditors ...RequestEditorFn) (*GetTenantResponse, error) {
	rsp, err := c.GetTenant(ctx, tenantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantResponse(rsp)
}

// UpdateTenantWithBodyWithResponse request with arbitrary body returning *UpdateTenantResponse
func (c *ClientWithResponses) UpdateTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error) {
	rsp, err := c.UpdateTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTenantResponse(rsp)
}

func (c *ClientWithResponses) UpdateTenantWithResponse(ctx context.Context, tenantId TenantId, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error) {
	rsp, err := c.UpdateTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTenantResponse(rsp)
}

// SearchClientsForTenantWithBodyWithResponse request with arbitrary body returning *SearchClientsForTenantResponse
func (c *ClientWithResponses) SearchClientsForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchClientsForTenantResponse, error) {
	rsp, err := c.SearchClientsForTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsForTenantResponse(rsp)
}

func (c *ClientWithResponses) SearchClientsForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchClientsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchClientsForTenantResponse, error) {
	rsp, err := c.SearchClientsForTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchClientsForTenantResponse(rsp)
}

// UnassignAClientFromATenantWithResponse request returning *UnassignAClientFromATenantResponse
func (c *ClientWithResponses) UnassignAClientFromATenantWithResponse(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*UnassignAClientFromATenantResponse, error) {
	rsp, err := c.UnassignAClientFromATenant(ctx, tenantId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignAClientFromATenantResponse(rsp)
}

// AssignAClientToATenantWithResponse request returning *AssignAClientToATenantResponse
func (c *ClientWithResponses) AssignAClientToATenantWithResponse(ctx context.Context, tenantId TenantId, clientId string, reqEditors ...RequestEditorFn) (*AssignAClientToATenantResponse, error) {
	rsp, err := c.AssignAClientToATenant(ctx, tenantId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignAClientToATenantResponse(rsp)
}

// SearchGroupsForTenantWithBodyWithResponse request with arbitrary body returning *SearchGroupsForTenantResponse
func (c *ClientWithResponses) SearchGroupsForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupsForTenantResponse, error) {
	rsp, err := c.SearchGroupsForTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupsForTenantResponse(rsp)
}

func (c *ClientWithResponses) SearchGroupsForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchGroupsForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupsForTenantResponse, error) {
	rsp, err := c.SearchGroupsForTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupsForTenantResponse(rsp)
}

// UnassignAGroupFromATenantWithResponse request returning *UnassignAGroupFromATenantResponse
func (c *ClientWithResponses) UnassignAGroupFromATenantWithResponse(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*UnassignAGroupFromATenantResponse, error) {
	rsp, err := c.UnassignAGroupFromATenant(ctx, tenantId, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignAGroupFromATenantResponse(rsp)
}

// AssignAGroupToATenantWithResponse request returning *AssignAGroupToATenantResponse
func (c *ClientWithResponses) AssignAGroupToATenantWithResponse(ctx context.Context, tenantId TenantId, groupId string, reqEditors ...RequestEditorFn) (*AssignAGroupToATenantResponse, error) {
	rsp, err := c.AssignAGroupToATenant(ctx, tenantId, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignAGroupToATenantResponse(rsp)
}

// SearchMappingRulesForTenantWithBodyWithResponse request with arbitrary body returning *SearchMappingRulesForTenantResponse
func (c *ClientWithResponses) SearchMappingRulesForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchMappingRulesForTenantResponse, error) {
	rsp, err := c.SearchMappingRulesForTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRulesForTenantResponse(rsp)
}

func (c *ClientWithResponses) SearchMappingRulesForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchMappingRulesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchMappingRulesForTenantResponse, error) {
	rsp, err := c.SearchMappingRulesForTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMappingRulesForTenantResponse(rsp)
}

// UnassignAMappingRuleFromATenantWithResponse request returning *UnassignAMappingRuleFromATenantResponse
func (c *ClientWithResponses) UnassignAMappingRuleFromATenantWithResponse(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*UnassignAMappingRuleFromATenantResponse, error) {
	rsp, err := c.UnassignAMappingRuleFromATenant(ctx, tenantId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignAMappingRuleFromATenantResponse(rsp)
}

// AssignAMappingRuleToATenantWithResponse request returning *AssignAMappingRuleToATenantResponse
func (c *ClientWithResponses) AssignAMappingRuleToATenantWithResponse(ctx context.Context, tenantId TenantId, mappingRuleId string, reqEditors ...RequestEditorFn) (*AssignAMappingRuleToATenantResponse, error) {
	rsp, err := c.AssignAMappingRuleToATenant(ctx, tenantId, mappingRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignAMappingRuleToATenantResponse(rsp)
}

// SearchRolesForTenantWithBodyWithResponse request with arbitrary body returning *SearchRolesForTenantResponse
func (c *ClientWithResponses) SearchRolesForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRolesForTenantResponse, error) {
	rsp, err := c.SearchRolesForTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRolesForTenantResponse(rsp)
}

func (c *ClientWithResponses) SearchRolesForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchRolesForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRolesForTenantResponse, error) {
	rsp, err := c.SearchRolesForTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRolesForTenantResponse(rsp)
}

// UnassignARoleFromATenantWithResponse request returning *UnassignARoleFromATenantResponse
func (c *ClientWithResponses) UnassignARoleFromATenantWithResponse(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*UnassignARoleFromATenantResponse, error) {
	rsp, err := c.UnassignARoleFromATenant(ctx, tenantId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignARoleFromATenantResponse(rsp)
}

// AssignARoleToATenantWithResponse request returning *AssignARoleToATenantResponse
func (c *ClientWithResponses) AssignARoleToATenantWithResponse(ctx context.Context, tenantId TenantId, roleId string, reqEditors ...RequestEditorFn) (*AssignARoleToATenantResponse, error) {
	rsp, err := c.AssignARoleToATenant(ctx, tenantId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignARoleToATenantResponse(rsp)
}

// SearchUsersForTenantWithBodyWithResponse request with arbitrary body returning *SearchUsersForTenantResponse
func (c *ClientWithResponses) SearchUsersForTenantWithBodyWithResponse(ctx context.Context, tenantId TenantId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersForTenantResponse, error) {
	rsp, err := c.SearchUsersForTenantWithBody(ctx, tenantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersForTenantResponse(rsp)
}

func (c *ClientWithResponses) SearchUsersForTenantWithResponse(ctx context.Context, tenantId TenantId, body SearchUsersForTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersForTenantResponse, error) {
	rsp, err := c.SearchUsersForTenant(ctx, tenantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersForTenantResponse(rsp)
}

// UnassignAUserFromATenantWithResponse request returning *UnassignAUserFromATenantResponse
func (c *ClientWithResponses) UnassignAUserFromATenantWithResponse(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*UnassignAUserFromATenantResponse, error) {
	rsp, err := c.UnassignAUserFromATenant(ctx, tenantId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignAUserFromATenantResponse(rsp)
}

// AssignAUserToATenantWithResponse request returning *AssignAUserToATenantResponse
func (c *ClientWithResponses) AssignAUserToATenantWithResponse(ctx context.Context, tenantId TenantId, username Username, reqEditors ...RequestEditorFn) (*AssignAUserToATenantResponse, error) {
	rsp, err := c.AssignAUserToATenant(ctx, tenantId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignAUserToATenantResponse(rsp)
}

// GetClusterTopologyWithResponse request returning *GetClusterTopologyResponse
func (c *ClientWithResponses) GetClusterTopologyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterTopologyResponse, error) {
	rsp, err := c.GetClusterTopology(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterTopologyResponse(rsp)
}

// SearchUserTasksWithBodyWithResponse request with arbitrary body returning *SearchUserTasksResponse
func (c *ClientWithResponses) SearchUserTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUserTasksResponse, error) {
	rsp, err := c.SearchUserTasksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUserTasksResponse(rsp)
}

func (c *ClientWithResponses) SearchUserTasksWithResponse(ctx context.Context, body SearchUserTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUserTasksResponse, error) {
	rsp, err := c.SearchUserTasks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUserTasksResponse(rsp)
}

// GetUserTaskWithResponse request returning *GetUserTaskResponse
func (c *ClientWithResponses) GetUserTaskWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*GetUserTaskResponse, error) {
	rsp, err := c.GetUserTask(ctx, userTaskKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserTaskResponse(rsp)
}

// UpdateUserTaskWithBodyWithResponse request with arbitrary body returning *UpdateUserTaskResponse
func (c *ClientWithResponses) UpdateUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error) {
	rsp, err := c.UpdateUserTaskWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserTaskWithResponse(ctx context.Context, userTaskKey string, body UpdateUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserTaskResponse, error) {
	rsp, err := c.UpdateUserTask(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserTaskResponse(rsp)
}

// UnassignUserTaskWithResponse request returning *UnassignUserTaskResponse
func (c *ClientWithResponses) UnassignUserTaskWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*UnassignUserTaskResponse, error) {
	rsp, err := c.UnassignUserTask(ctx, userTaskKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignUserTaskResponse(rsp)
}

// AssignUserTaskWithBodyWithResponse request with arbitrary body returning *AssignUserTaskResponse
func (c *ClientWithResponses) AssignUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error) {
	rsp, err := c.AssignUserTaskWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserTaskResponse(rsp)
}

func (c *ClientWithResponses) AssignUserTaskWithResponse(ctx context.Context, userTaskKey string, body AssignUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignUserTaskResponse, error) {
	rsp, err := c.AssignUserTask(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserTaskResponse(rsp)
}

// CompleteUserTaskWithBodyWithResponse request with arbitrary body returning *CompleteUserTaskResponse
func (c *ClientWithResponses) CompleteUserTaskWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error) {
	rsp, err := c.CompleteUserTaskWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteUserTaskResponse(rsp)
}

func (c *ClientWithResponses) CompleteUserTaskWithResponse(ctx context.Context, userTaskKey string, body CompleteUserTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteUserTaskResponse, error) {
	rsp, err := c.CompleteUserTask(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteUserTaskResponse(rsp)
}

// GetUserTaskFormWithResponse request returning *GetUserTaskFormResponse
func (c *ClientWithResponses) GetUserTaskFormWithResponse(ctx context.Context, userTaskKey string, reqEditors ...RequestEditorFn) (*GetUserTaskFormResponse, error) {
	rsp, err := c.GetUserTaskForm(ctx, userTaskKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserTaskFormResponse(rsp)
}

// SearchUserTaskVariablesWithBodyWithResponse request with arbitrary body returning *SearchUserTaskVariablesResponse
func (c *ClientWithResponses) SearchUserTaskVariablesWithBodyWithResponse(ctx context.Context, userTaskKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUserTaskVariablesResponse, error) {
	rsp, err := c.SearchUserTaskVariablesWithBody(ctx, userTaskKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUserTaskVariablesResponse(rsp)
}

func (c *ClientWithResponses) SearchUserTaskVariablesWithResponse(ctx context.Context, userTaskKey string, body SearchUserTaskVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUserTaskVariablesResponse, error) {
	rsp, err := c.SearchUserTaskVariables(ctx, userTaskKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUserTaskVariablesResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// SearchUsersWithBodyWithResponse request with arbitrary body returning *SearchUsersResponse
func (c *ClientWithResponses) SearchUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error) {
	rsp, err := c.SearchUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersResponse(rsp)
}

func (c *ClientWithResponses) SearchUsersWithResponse(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error) {
	rsp, err := c.SearchUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, username, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, username Username, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, username, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// SearchVariablesWithBodyWithResponse request with arbitrary body returning *SearchVariablesResponse
func (c *ClientWithResponses) SearchVariablesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchVariablesResponse, error) {
	rsp, err := c.SearchVariablesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchVariablesResponse(rsp)
}

func (c *ClientWithResponses) SearchVariablesWithResponse(ctx context.Context, body SearchVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchVariablesResponse, error) {
	rsp, err := c.SearchVariables(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchVariablesResponse(rsp)
}

// GetVariableWithResponse request returning *GetVariableResponse
func (c *ClientWithResponses) GetVariableWithResponse(ctx context.Context, variableKey string, reqEditors ...RequestEditorFn) (*GetVariableResponse, error) {
	rsp, err := c.GetVariable(ctx, variableKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableResponse(rsp)
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CamundaUserResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateAuthorizationResponse parses an HTTP response from a CreateAuthorizationWithResponse call
func ParseCreateAuthorizationResponse(rsp *http.Response) (*CreateAuthorizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthorizationCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchAuthorizationsResponse parses an HTTP response from a SearchAuthorizationsWithResponse call
func ParseSearchAuthorizationsResponse(rsp *http.Response) (*SearchAuthorizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchAuthorizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorizationSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAuthorizationResponse parses an HTTP response from a DeleteAuthorizationWithResponse call
func ParseDeleteAuthorizationResponse(rsp *http.Response) (*DeleteAuthorizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetAuthorizationResponse parses an HTTP response from a GetAuthorizationWithResponse call
func ParseGetAuthorizationResponse(rsp *http.Response) (*GetAuthorizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorizationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAuthorizationResponse parses an HTTP response from a UpdateAuthorizationWithResponse call
func ParseUpdateAuthorizationResponse(rsp *http.Response) (*UpdateAuthorizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchBatchOperationItemsResponse parses an HTTP response from a SearchBatchOperationItemsWithResponse call
func ParseSearchBatchOperationItemsResponse(rsp *http.Response) (*SearchBatchOperationItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchBatchOperationItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationItemSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchBatchOperationsResponse parses an HTTP response from a SearchBatchOperationsWithResponse call
func ParseSearchBatchOperationsResponse(rsp *http.Response) (*SearchBatchOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchBatchOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetBatchOperationResponse parses an HTTP response from a GetBatchOperationWithResponse call
func ParseGetBatchOperationResponse(rsp *http.Response) (*GetBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCancelBatchOperationResponse parses an HTTP response from a CancelBatchOperationWithResponse call
func ParseCancelBatchOperationResponse(rsp *http.Response) (*CancelBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseResumeBatchOperationResponse parses an HTTP response from a ResumeBatchOperationWithResponse call
func ParseResumeBatchOperationResponse(rsp *http.Response) (*ResumeBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSuspendBatchOperationResponse parses an HTTP response from a SuspendBatchOperationWithResponse call
func ParseSuspendBatchOperationResponse(rsp *http.Response) (*SuspendBatchOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SuspendBatchOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParsePinInternalClockAlphaResponse parses an HTTP response from a PinInternalClockAlphaWithResponse call
func ParsePinInternalClockAlphaResponse(rsp *http.Response) (*PinInternalClockAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PinInternalClockAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseResetInternalClockAlphaResponse parses an HTTP response from a ResetInternalClockAlphaWithResponse call
func ParseResetInternalClockAlphaResponse(rsp *http.Response) (*ResetInternalClockAlphaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetInternalClockAlphaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseEvaluateDecisionResponse parses an HTTP response from a EvaluateDecisionWithResponse call
func ParseEvaluateDecisionResponse(rsp *http.Response) (*EvaluateDecisionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EvaluateDecisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvaluateDecisionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchDecisionDefinitionsResponse parses an HTTP response from a SearchDecisionDefinitionsWithResponse call
func ParseSearchDecisionDefinitionsResponse(rsp *http.Response) (*SearchDecisionDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDecisionDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionDefinitionSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionDefinitionResponse parses an HTTP response from a GetDecisionDefinitionWithResponse call
func ParseGetDecisionDefinitionResponse(rsp *http.Response) (*GetDecisionDefinitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionDefinitionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionDefinitionXmlResponse parses an HTTP response from a GetDecisionDefinitionXmlWithResponse call
func ParseGetDecisionDefinitionXmlResponse(rsp *http.Response) (*GetDecisionDefinitionXmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionDefinitionXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseSearchDecisionInstancesResponse parses an HTTP response from a SearchDecisionInstancesWithResponse call
func ParseSearchDecisionInstancesResponse(rsp *http.Response) (*SearchDecisionInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDecisionInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionInstanceResponse parses an HTTP response from a GetDecisionInstanceWithResponse call
func ParseGetDecisionInstanceResponse(rsp *http.Response) (*GetDecisionInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionInstanceGetQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchDecisionRequirementsResponse parses an HTTP response from a SearchDecisionRequirementsWithResponse call
func ParseSearchDecisionRequirementsResponse(rsp *http.Response) (*SearchDecisionRequirementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDecisionRequirementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionRequirementsSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionRequirementsResponse parses an HTTP response from a GetDecisionRequirementsWithResponse call
func ParseGetDecisionRequirementsResponse(rsp *http.Response) (*GetDecisionRequirementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionRequirementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionRequirementsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionRequirementsXmlResponse parses an HTTP response from a GetDecisionRequirementsXmlWithResponse call
func ParseGetDecisionRequirementsXmlResponse(rsp *http.Response) (*GetDecisionRequirementsXmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionRequirementsXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseDeployResourcesResponse parses an HTTP response from a DeployResourcesWithResponse call
func ParseDeployResourcesResponse(rsp *http.Response) (*DeployResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeployResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseUploadDocumentResponse parses an HTTP response from a UploadDocumentWithResponse call
func ParseUploadDocumentResponse(rsp *http.Response) (*UploadDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DocumentReference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseUploadMultipleDocumentsResponse parses an HTTP response from a UploadMultipleDocumentsWithResponse call
func ParseUploadMultipleDocumentsResponse(rsp *http.Response) (*UploadMultipleDocumentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadMultipleDocumentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DocumentCreationBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest DocumentCreationBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseDeleteDocumentResponse parses an HTTP response from a DeleteDocumentWithResponse call
func ParseDeleteDocumentResponse(rsp *http.Response) (*DeleteDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDownloadDocumentResponse parses an HTTP response from a DownloadDocumentWithResponse call
func ParseDownloadDocumentResponse(rsp *http.Response) (*DownloadDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDocumentLinkResponse parses an HTTP response from a CreateDocumentLinkWithResponse call
func ParseCreateDocumentLinkResponse(rsp *http.Response) (*CreateDocumentLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDocumentLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DocumentLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseActivateActivitiesWithinAnAdHocSubProcessResponse parses an HTTP response from a ActivateActivitiesWithinAnAdHocSubProcessWithResponse call
func ParseActivateActivitiesWithinAnAdHocSubProcessResponse(rsp *http.Response) (*ActivateActivitiesWithinAnAdHocSubProcessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateActivitiesWithinAnAdHocSubProcessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchElementInstancesResponse parses an HTTP response from a SearchElementInstancesWithResponse call
func ParseSearchElementInstancesResponse(rsp *http.Response) (*SearchElementInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchElementInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElementInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetElementInstanceResponse parses an HTTP response from a GetElementInstanceWithResponse call
func ParseGetElementInstanceResponse(rsp *http.Response) (*GetElementInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetElementInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElementInstanceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateElementInstanceVariablesResponse parses an HTTP response from a UpdateElementInstanceVariablesWithResponse call
func ParseUpdateElementInstanceVariablesResponse(rsp *http.Response) (*UpdateElementInstanceVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateElementInstanceVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GroupCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchGroupsResponse parses an HTTP response from a SearchGroupsWithResponse call
func ParseSearchGroupsResponse(rsp *http.Response) (*SearchGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGroupResponse parses an HTTP response from a UpdateGroupWithResponse call
func ParseUpdateGroupResponse(rsp *http.Response) (*UpdateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchGroupClientsResponse parses an HTTP response from a SearchGroupClientsWithResponse call
func ParseSearchGroupClientsResponse(rsp *http.Response) (*SearchGroupClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGroupClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupClientSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignAClientFromAGroupResponse parses an HTTP response from a UnassignAClientFromAGroupWithResponse call
func ParseUnassignAClientFromAGroupResponse(rsp *http.Response) (*UnassignAClientFromAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignAClientFromAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignAClientToAGroupResponse parses an HTTP response from a AssignAClientToAGroupWithResponse call
func ParseAssignAClientToAGroupResponse(rsp *http.Response) (*AssignAClientToAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignAClientToAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchGroupMappingRulesResponse parses an HTTP response from a SearchGroupMappingRulesWithResponse call
func ParseSearchGroupMappingRulesResponse(rsp *http.Response) (*SearchGroupMappingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGroupMappingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignAMappingRuleFromAGroupResponse parses an HTTP response from a UnassignAMappingRuleFromAGroupWithResponse call
func ParseUnassignAMappingRuleFromAGroupResponse(rsp *http.Response) (*UnassignAMappingRuleFromAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignAMappingRuleFromAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignAMappingRuleToAGroupResponse parses an HTTP response from a AssignAMappingRuleToAGroupWithResponse call
func ParseAssignAMappingRuleToAGroupResponse(rsp *http.Response) (*AssignAMappingRuleToAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignAMappingRuleToAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchGroupRolesResponse parses an HTTP response from a SearchGroupRolesWithResponse call
func ParseSearchGroupRolesResponse(rsp *http.Response) (*SearchGroupRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGroupRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchGroupUsersResponse parses an HTTP response from a SearchGroupUsersWithResponse call
func ParseSearchGroupUsersResponse(rsp *http.Response) (*SearchGroupUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGroupUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupUserSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignAUserFromAGroupResponse parses an HTTP response from a UnassignAUserFromAGroupWithResponse call
func ParseUnassignAUserFromAGroupResponse(rsp *http.Response) (*UnassignAUserFromAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignAUserFromAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignAUserToAGroupResponse parses an HTTP response from a AssignAUserToAGroupWithResponse call
func ParseAssignAUserToAGroupResponse(rsp *http.Response) (*AssignAUserToAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignAUserToAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchIncidentsResponse parses an HTTP response from a SearchIncidentsWithResponse call
func ParseSearchIncidentsResponse(rsp *http.Response) (*SearchIncidentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchIncidentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIncidentResponse parses an HTTP response from a GetIncidentWithResponse call
func ParseGetIncidentResponse(rsp *http.Response) (*GetIncidentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncidentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseResolveIncidentResponse parses an HTTP response from a ResolveIncidentWithResponse call
func ParseResolveIncidentResponse(rsp *http.Response) (*ResolveIncidentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolveIncidentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseActivateJobsResponse parses an HTTP response from a ActivateJobsWithResponse call
func ParseActivateJobsResponse(rsp *http.Response) (*ActivateJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobActivationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchJobsResponse parses an HTTP response from a SearchJobsWithResponse call
func ParseSearchJobsResponse(rsp *http.Response) (*SearchJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateJobResponse parses an HTTP response from a UpdateJobWithResponse call
func ParseUpdateJobResponse(rsp *http.Response) (*UpdateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCompleteJobResponse parses an HTTP response from a CompleteJobWithResponse call
func ParseCompleteJobResponse(rsp *http.Response) (*CompleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseThrowErrorForJobResponse parses an HTTP response from a ThrowErrorForJobWithResponse call
func ParseThrowErrorForJobResponse(rsp *http.Response) (*ThrowErrorForJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThrowErrorForJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseFailJobResponse parses an HTTP response from a FailJobWithResponse call
func ParseFailJobResponse(rsp *http.Response) (*FailJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FailJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetLicenseStatusResponse parses an HTTP response from a GetLicenseStatusWithResponse call
func ParseGetLicenseStatusResponse(rsp *http.Response) (*GetLicenseStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LicenseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateMappingRuleResponse parses an HTTP response from a CreateMappingRuleWithResponse call
func ParseCreateMappingRuleResponse(rsp *http.Response) (*CreateMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MappingRuleCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchMappingRulesResponse parses an HTTP response from a SearchMappingRulesWithResponse call
func ParseSearchMappingRulesResponse(rsp *http.Response) (*SearchMappingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMappingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAMappingRuleResponse parses an HTTP response from a DeleteAMappingRuleWithResponse call
func ParseDeleteAMappingRuleResponse(rsp *http.Response) (*DeleteAMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetAMappingRuleResponse parses an HTTP response from a GetAMappingRuleWithResponse call
func ParseGetAMappingRuleResponse(rsp *http.Response) (*GetAMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateMappingRuleResponse parses an HTTP response from a UpdateMappingRuleWithResponse call
func ParseUpdateMappingRuleResponse(rsp *http.Response) (*UpdateMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchMessageSubscriptionsResponse parses an HTTP response from a SearchMessageSubscriptionsWithResponse call
func ParseSearchMessageSubscriptionsResponse(rsp *http.Response) (*SearchMessageSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMessageSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageSubscriptionSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCorrelateMessageResponse parses an HTTP response from a CorrelateMessageWithResponse call
func ParseCorrelateMessageResponse(rsp *http.Response) (*CorrelateMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CorrelateMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageCorrelationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParsePublishMessageResponse parses an HTTP response from a PublishMessageWithResponse call
func ParsePublishMessageResponse(rsp *http.Response) (*PublishMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagePublicationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchProcessDefinitionsResponse parses an HTTP response from a SearchProcessDefinitionsWithResponse call
func ParseSearchProcessDefinitionsResponse(rsp *http.Response) (*SearchProcessDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchProcessDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessDefinitionSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessDefinitionResponse parses an HTTP response from a GetProcessDefinitionWithResponse call
func ParseGetProcessDefinitionResponse(rsp *http.Response) (*GetProcessDefinitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessDefinitionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessStartFormResponse parses an HTTP response from a GetProcessStartFormWithResponse call
func ParseGetProcessStartFormResponse(rsp *http.Response) (*GetProcessStartFormResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessStartFormResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FormResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessDefinitionStatisticsResponse parses an HTTP response from a GetProcessDefinitionStatisticsWithResponse call
func ParseGetProcessDefinitionStatisticsResponse(rsp *http.Response) (*GetProcessDefinitionStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefinitionStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessDefinitionElementStatisticsQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessDefinitionXmlResponse parses an HTTP response from a GetProcessDefinitionXmlWithResponse call
func ParseGetProcessDefinitionXmlResponse(rsp *http.Response) (*GetProcessDefinitionXmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefinitionXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseCreateProcessInstanceResponse parses an HTTP response from a CreateProcessInstanceWithResponse call
func ParseCreateProcessInstanceResponse(rsp *http.Response) (*CreateProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateProcessInstanceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON504 = &dest

	}

	return response, nil
}

// ParseCreateABatchOperationToCancelProcessInstancesResponse parses an HTTP response from a CreateABatchOperationToCancelProcessInstancesWithResponse call
func ParseCreateABatchOperationToCancelProcessInstancesResponse(rsp *http.Response) (*CreateABatchOperationToCancelProcessInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateABatchOperationToCancelProcessInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationCreatedResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateABatchOperationToResolveIncidentsOfProcessInstancesResponse parses an HTTP response from a CreateABatchOperationToResolveIncidentsOfProcessInstancesWithResponse call
func ParseCreateABatchOperationToResolveIncidentsOfProcessInstancesResponse(rsp *http.Response) (*CreateABatchOperationToResolveIncidentsOfProcessInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateABatchOperationToResolveIncidentsOfProcessInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationCreatedResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateABatchOperationToMigrateProcessInstancesResponse parses an HTTP response from a CreateABatchOperationToMigrateProcessInstancesWithResponse call
func ParseCreateABatchOperationToMigrateProcessInstancesResponse(rsp *http.Response) (*CreateABatchOperationToMigrateProcessInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateABatchOperationToMigrateProcessInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationCreatedResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateABatchOperationToModifyProcessInstancesResponse parses an HTTP response from a CreateABatchOperationToModifyProcessInstancesWithResponse call
func ParseCreateABatchOperationToModifyProcessInstancesResponse(rsp *http.Response) (*CreateABatchOperationToModifyProcessInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateABatchOperationToModifyProcessInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchOperationCreatedResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchProcessInstancesResponse parses an HTTP response from a SearchProcessInstancesWithResponse call
func ParseSearchProcessInstancesResponse(rsp *http.Response) (*SearchProcessInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchProcessInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessInstanceResponse parses an HTTP response from a GetProcessInstanceWithResponse call
func ParseGetProcessInstanceResponse(rsp *http.Response) (*GetProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetCallHierarchyForProcessInstanceResponse parses an HTTP response from a GetCallHierarchyForProcessInstanceWithResponse call
func ParseGetCallHierarchyForProcessInstanceResponse(rsp *http.Response) (*GetCallHierarchyForProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCallHierarchyForProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProcessInstanceCallHierarchyEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCancelProcessInstanceResponse parses an HTTP response from a CancelProcessInstanceWithResponse call
func ParseCancelProcessInstanceResponse(rsp *http.Response) (*CancelProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchForIncidentsAssociatedWithAProcessInstanceResponse parses an HTTP response from a SearchForIncidentsAssociatedWithAProcessInstanceWithResponse call
func ParseSearchForIncidentsAssociatedWithAProcessInstanceResponse(rsp *http.Response) (*SearchForIncidentsAssociatedWithAProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForIncidentsAssociatedWithAProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncidentSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseMigrateProcessInstanceResponse parses an HTTP response from a MigrateProcessInstanceWithResponse call
func ParseMigrateProcessInstanceResponse(rsp *http.Response) (*MigrateProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrateProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseModifyProcessInstanceResponse parses an HTTP response from a ModifyProcessInstanceWithResponse call
func ParseModifyProcessInstanceResponse(rsp *http.Response) (*ModifyProcessInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyProcessInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetProcessInstanceSequenceFlowsResponse parses an HTTP response from a GetProcessInstanceSequenceFlowsWithResponse call
func ParseGetProcessInstanceSequenceFlowsResponse(rsp *http.Response) (*GetProcessInstanceSequenceFlowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessInstanceSequenceFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceSequenceFlowsQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessInstanceStatisticsResponse parses an HTTP response from a GetProcessInstanceStatisticsWithResponse call
func ParseGetProcessInstanceStatisticsResponse(rsp *http.Response) (*GetProcessInstanceStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessInstanceStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceElementStatisticsQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceContentResponse parses an HTTP response from a GetResourceContentWithResponse call
func ParseGetResourceContentResponse(rsp *http.Response) (*GetResourceContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteResourceResponse parses an HTTP response from a DeleteResourceWithResponse call
func ParseDeleteResourceResponse(rsp *http.Response) (*DeleteResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCreateRoleResponse parses an HTTP response from a CreateRoleWithResponse call
func ParseCreateRoleResponse(rsp *http.Response) (*CreateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RoleCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchRolesResponse parses an HTTP response from a SearchRolesWithResponse call
func ParseSearchRolesResponse(rsp *http.Response) (*SearchRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleResponse parses an HTTP response from a DeleteRoleWithResponse call
func ParseDeleteRoleResponse(rsp *http.Response) (*DeleteRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleResponse parses an HTTP response from a UpdateRoleWithResponse call
func ParseUpdateRoleResponse(rsp *http.Response) (*UpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchRoleClientsResponse parses an HTTP response from a SearchRoleClientsWithResponse call
func ParseSearchRoleClientsResponse(rsp *http.Response) (*SearchRoleClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRoleClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleClientSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignARoleFromAClientResponse parses an HTTP response from a UnassignARoleFromAClientWithResponse call
func ParseUnassignARoleFromAClientResponse(rsp *http.Response) (*UnassignARoleFromAClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignARoleFromAClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignARoleToAClientResponse parses an HTTP response from a AssignARoleToAClientWithResponse call
func ParseAssignARoleToAClientResponse(rsp *http.Response) (*AssignARoleToAClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignARoleToAClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchRoleGroupsResponse parses an HTTP response from a SearchRoleGroupsWithResponse call
func ParseSearchRoleGroupsResponse(rsp *http.Response) (*SearchRoleGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRoleGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleGroupSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignARoleFromAGroupResponse parses an HTTP response from a UnassignARoleFromAGroupWithResponse call
func ParseUnassignARoleFromAGroupResponse(rsp *http.Response) (*UnassignARoleFromAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignARoleFromAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignARoleToAGroupResponse parses an HTTP response from a AssignARoleToAGroupWithResponse call
func ParseAssignARoleToAGroupResponse(rsp *http.Response) (*AssignARoleToAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignARoleToAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchRoleMappingRulesResponse parses an HTTP response from a SearchRoleMappingRulesWithResponse call
func ParseSearchRoleMappingRulesResponse(rsp *http.Response) (*SearchRoleMappingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRoleMappingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignARoleFromAMappingRuleResponse parses an HTTP response from a UnassignARoleFromAMappingRuleWithResponse call
func ParseUnassignARoleFromAMappingRuleResponse(rsp *http.Response) (*UnassignARoleFromAMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignARoleFromAMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignARoleToAMappingRuleResponse parses an HTTP response from a AssignARoleToAMappingRuleWithResponse call
func ParseAssignARoleToAMappingRuleResponse(rsp *http.Response) (*AssignARoleToAMappingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignARoleToAMappingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchRoleUsersResponse parses an HTTP response from a SearchRoleUsersWithResponse call
func ParseSearchRoleUsersResponse(rsp *http.Response) (*SearchRoleUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRoleUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleUserSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignARoleFromAUserResponse parses an HTTP response from a UnassignARoleFromAUserWithResponse call
func ParseUnassignARoleFromAUserResponse(rsp *http.Response) (*UnassignARoleFromAUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignARoleFromAUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignARoleToAUserResponse parses an HTTP response from a AssignARoleToAUserWithResponse call
func ParseAssignARoleToAUserResponse(rsp *http.Response) (*AssignARoleToAUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignARoleToAUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCreateAdminUserResponse parses an HTTP response from a CreateAdminUserWithResponse call
func ParseCreateAdminUserResponse(rsp *http.Response) (*CreateAdminUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAdminUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseBroadcastSignalResponse parses an HTTP response from a BroadcastSignalWithResponse call
func ParseBroadcastSignalResponse(rsp *http.Response) (*BroadcastSignalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BroadcastSignalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SignalBroadcastResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetClusterStatusResponse parses an HTTP response from a GetClusterStatusWithResponse call
func ParseGetClusterStatusResponse(rsp *http.Response) (*GetClusterStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsageMetricsResponse parses an HTTP response from a GetUsageMetricsWithResponse call
func ParseGetUsageMetricsResponse(rsp *http.Response) (*GetUsageMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateTenantResponse parses an HTTP response from a CreateTenantWithResponse call
func ParseCreateTenantResponse(rsp *http.Response) (*CreateTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TenantCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchTenantsResponse parses an HTTP response from a SearchTenantsWithResponse call
func ParseSearchTenantsResponse(rsp *http.Response) (*SearchTenantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTenantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTenantResponse parses an HTTP response from a DeleteTenantWithResponse call
func ParseDeleteTenantResponse(rsp *http.Response) (*DeleteTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetTenantResponse parses an HTTP response from a GetTenantWithResponse call
func ParseGetTenantResponse(rsp *http.Response) (*GetTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTenantResponse parses an HTTP response from a UpdateTenantWithResponse call
func ParseUpdateTenantResponse(rsp *http.Response) (*UpdateTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchClientsForTenantResponse parses an HTTP response from a SearchClientsForTenantWithResponse call
func ParseSearchClientsForTenantResponse(rsp *http.Response) (*SearchClientsForTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchClientsForTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantClientSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnassignAClientFromATenantResponse parses an HTTP response from a UnassignAClientFromATenantWithResponse call
func ParseUnassignAClientFromATenantResponse(rsp *http.Response) (*UnassignAClientFromATenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignAClientFromATenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignAClientToATenantResponse parses an HTTP response from a AssignAClientToATenantWithResponse call
func ParseAssignAClientToATenantResponse(rsp *http.Response) (*AssignAClientToATenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignAClientToATenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchGroupsForTenantResponse parses an HTTP response from a SearchGroupsForTenantWithResponse call
func ParseSearchGroupsForTenantResponse(rsp *http.Response) (*SearchGroupsForTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGroupsForTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantGroupSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnassignAGroupFromATenantResponse parses an HTTP response from a UnassignAGroupFromATenantWithResponse call
func ParseUnassignAGroupFromATenantResponse(rsp *http.Response) (*UnassignAGroupFromATenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignAGroupFromATenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignAGroupToATenantResponse parses an HTTP response from a AssignAGroupToATenantWithResponse call
func ParseAssignAGroupToATenantResponse(rsp *http.Response) (*AssignAGroupToATenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignAGroupToATenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchMappingRulesForTenantResponse parses an HTTP response from a SearchMappingRulesForTenantWithResponse call
func ParseSearchMappingRulesForTenantResponse(rsp *http.Response) (*SearchMappingRulesForTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMappingRulesForTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingRuleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnassignAMappingRuleFromATenantResponse parses an HTTP response from a UnassignAMappingRuleFromATenantWithResponse call
func ParseUnassignAMappingRuleFromATenantResponse(rsp *http.Response) (*UnassignAMappingRuleFromATenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignAMappingRuleFromATenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignAMappingRuleToATenantResponse parses an HTTP response from a AssignAMappingRuleToATenantWithResponse call
func ParseAssignAMappingRuleToATenantResponse(rsp *http.Response) (*AssignAMappingRuleToATenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignAMappingRuleToATenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchRolesForTenantResponse parses an HTTP response from a SearchRolesForTenantWithResponse call
func ParseSearchRolesForTenantResponse(rsp *http.Response) (*SearchRolesForTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRolesForTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnassignARoleFromATenantResponse parses an HTTP response from a UnassignARoleFromATenantWithResponse call
func ParseUnassignARoleFromATenantResponse(rsp *http.Response) (*UnassignARoleFromATenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignARoleFromATenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignARoleToATenantResponse parses an HTTP response from a AssignARoleToATenantWithResponse call
func ParseAssignARoleToATenantResponse(rsp *http.Response) (*AssignARoleToATenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignARoleToATenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchUsersForTenantResponse parses an HTTP response from a SearchUsersForTenantWithResponse call
func ParseSearchUsersForTenantResponse(rsp *http.Response) (*SearchUsersForTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUsersForTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantUserSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnassignAUserFromATenantResponse parses an HTTP response from a UnassignAUserFromATenantWithResponse call
func ParseUnassignAUserFromATenantResponse(rsp *http.Response) (*UnassignAUserFromATenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignAUserFromATenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignAUserToATenantResponse parses an HTTP response from a AssignAUserToATenantWithResponse call
func ParseAssignAUserToATenantResponse(rsp *http.Response) (*AssignAUserToATenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignAUserToATenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetClusterTopologyResponse parses an HTTP response from a GetClusterTopologyWithResponse call
func ParseGetClusterTopologyResponse(rsp *http.Response) (*GetClusterTopologyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterTopologyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopologyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchUserTasksResponse parses an HTTP response from a SearchUserTasksWithResponse call
func ParseSearchUserTasksResponse(rsp *http.Response) (*SearchUserTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUserTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserTaskSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserTaskResponse parses an HTTP response from a GetUserTaskWithResponse call
func ParseGetUserTaskResponse(rsp *http.Response) (*GetUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserTaskResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserTaskResponse parses an HTTP response from a UpdateUserTaskWithResponse call
func ParseUpdateUserTaskResponse(rsp *http.Response) (*UpdateUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseUnassignUserTaskResponse parses an HTTP response from a UnassignUserTaskWithResponse call
func ParseUnassignUserTaskResponse(rsp *http.Response) (*UnassignUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseAssignUserTaskResponse parses an HTTP response from a AssignUserTaskWithResponse call
func ParseAssignUserTaskResponse(rsp *http.Response) (*AssignUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCompleteUserTaskResponse parses an HTTP response from a CompleteUserTaskWithResponse call
func ParseCompleteUserTaskResponse(rsp *http.Response) (*CompleteUserTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteUserTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetUserTaskFormResponse parses an HTTP response from a GetUserTaskFormWithResponse call
func ParseGetUserTaskFormResponse(rsp *http.Response) (*GetUserTaskFormResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserTaskFormResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FormResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchUserTaskVariablesResponse parses an HTTP response from a SearchUserTaskVariablesWithResponse call
func ParseSearchUserTaskVariablesResponse(rsp *http.Response) (*SearchUserTaskVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUserTaskVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VariableSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserCreateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchUsersResponse parses an HTTP response from a SearchUsersWithResponse call
func ParseSearchUsersResponse(rsp *http.Response) (*SearchUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseSearchVariablesResponse parses an HTTP response from a SearchVariablesWithResponse call
func ParseSearchVariablesResponse(rsp *http.Response) (*SearchVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VariableSearchQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetVariableResponse parses an HTTP response from a GetVariableWithResponse call
func ParseGetVariableResponse(rsp *http.Response) (*GetVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VariableResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"23++/U8AAAD//46KfSwuGgUA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
