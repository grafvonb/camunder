// Package c88operate provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package v88

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	Bearer_keyScopes = "bearer_key.Scopes"
	CookieScopes     = "cookie.Scopes"
)

// Defines values for DecisionInstanceDecisionType.
const (
	DecisionInstanceDecisionTypeDECISIONTABLE     DecisionInstanceDecisionType = "DECISION_TABLE"
	DecisionInstanceDecisionTypeLITERALEXPRESSION DecisionInstanceDecisionType = "LITERAL_EXPRESSION"
	DecisionInstanceDecisionTypeUNKNOWN           DecisionInstanceDecisionType = "UNKNOWN"
	DecisionInstanceDecisionTypeUNSPECIFIED       DecisionInstanceDecisionType = "UNSPECIFIED"
)

// Defines values for DecisionInstanceState.
const (
	DecisionInstanceStateEVALUATED   DecisionInstanceState = "EVALUATED"
	DecisionInstanceStateFAILED      DecisionInstanceState = "FAILED"
	DecisionInstanceStateUNKNOWN     DecisionInstanceState = "UNKNOWN"
	DecisionInstanceStateUNSPECIFIED DecisionInstanceState = "UNSPECIFIED"
)

// Defines values for FlowNodeInstanceState.
const (
	FlowNodeInstanceStateACTIVE     FlowNodeInstanceState = "ACTIVE"
	FlowNodeInstanceStateCOMPLETED  FlowNodeInstanceState = "COMPLETED"
	FlowNodeInstanceStateTERMINATED FlowNodeInstanceState = "TERMINATED"
)

// Defines values for FlowNodeInstanceType.
const (
	FlowNodeInstanceTypeBOUNDARYEVENT          FlowNodeInstanceType = "BOUNDARY_EVENT"
	FlowNodeInstanceTypeBUSINESSRULETASK       FlowNodeInstanceType = "BUSINESS_RULE_TASK"
	FlowNodeInstanceTypeCALLACTIVITY           FlowNodeInstanceType = "CALL_ACTIVITY"
	FlowNodeInstanceTypeENDEVENT               FlowNodeInstanceType = "END_EVENT"
	FlowNodeInstanceTypeEVENTBASEDGATEWAY      FlowNodeInstanceType = "EVENT_BASED_GATEWAY"
	FlowNodeInstanceTypeEVENTSUBPROCESS        FlowNodeInstanceType = "EVENT_SUB_PROCESS"
	FlowNodeInstanceTypeEXCLUSIVEGATEWAY       FlowNodeInstanceType = "EXCLUSIVE_GATEWAY"
	FlowNodeInstanceTypeINCLUSIVEGATEWAY       FlowNodeInstanceType = "INCLUSIVE_GATEWAY"
	FlowNodeInstanceTypeINTERMEDIATECATCHEVENT FlowNodeInstanceType = "INTERMEDIATE_CATCH_EVENT"
	FlowNodeInstanceTypeINTERMEDIATETHROWEVENT FlowNodeInstanceType = "INTERMEDIATE_THROW_EVENT"
	FlowNodeInstanceTypeMANUALTASK             FlowNodeInstanceType = "MANUAL_TASK"
	FlowNodeInstanceTypeMULTIINSTANCEBODY      FlowNodeInstanceType = "MULTI_INSTANCE_BODY"
	FlowNodeInstanceTypePARALLELGATEWAY        FlowNodeInstanceType = "PARALLEL_GATEWAY"
	FlowNodeInstanceTypePROCESS                FlowNodeInstanceType = "PROCESS"
	FlowNodeInstanceTypeRECEIVETASK            FlowNodeInstanceType = "RECEIVE_TASK"
	FlowNodeInstanceTypeSCRIPTTASK             FlowNodeInstanceType = "SCRIPT_TASK"
	FlowNodeInstanceTypeSENDTASK               FlowNodeInstanceType = "SEND_TASK"
	FlowNodeInstanceTypeSEQUENCEFLOW           FlowNodeInstanceType = "SEQUENCE_FLOW"
	FlowNodeInstanceTypeSERVICETASK            FlowNodeInstanceType = "SERVICE_TASK"
	FlowNodeInstanceTypeSTARTEVENT             FlowNodeInstanceType = "START_EVENT"
	FlowNodeInstanceTypeSUBPROCESS             FlowNodeInstanceType = "SUB_PROCESS"
	FlowNodeInstanceTypeTASK                   FlowNodeInstanceType = "TASK"
	FlowNodeInstanceTypeUNKNOWN                FlowNodeInstanceType = "UNKNOWN"
	FlowNodeInstanceTypeUNSPECIFIED            FlowNodeInstanceType = "UNSPECIFIED"
	FlowNodeInstanceTypeUSERTASK               FlowNodeInstanceType = "USER_TASK"
)

// Defines values for IncidentState.
const (
	IncidentStateACTIVE   IncidentState = "ACTIVE"
	IncidentStateMIGRATED IncidentState = "MIGRATED"
	IncidentStatePENDING  IncidentState = "PENDING"
	IncidentStateRESOLVED IncidentState = "RESOLVED"
)

// Defines values for IncidentType.
const (
	IncidentTypeCALLEDDECISIONERROR        IncidentType = "CALLED_DECISION_ERROR"
	IncidentTypeCALLEDELEMENTERROR         IncidentType = "CALLED_ELEMENT_ERROR"
	IncidentTypeCONDITIONERROR             IncidentType = "CONDITION_ERROR"
	IncidentTypeDECISIONEVALUATIONERROR    IncidentType = "DECISION_EVALUATION_ERROR"
	IncidentTypeEXECUTIONLISTENERNORETRIES IncidentType = "EXECUTION_LISTENER_NO_RETRIES"
	IncidentTypeEXTRACTVALUEERROR          IncidentType = "EXTRACT_VALUE_ERROR"
	IncidentTypeFORMNOTFOUND               IncidentType = "FORM_NOT_FOUND"
	IncidentTypeIOMAPPINGERROR             IncidentType = "IO_MAPPING_ERROR"
	IncidentTypeJOBNORETRIES               IncidentType = "JOB_NO_RETRIES"
	IncidentTypeMESSAGESIZEEXCEEDED        IncidentType = "MESSAGE_SIZE_EXCEEDED"
	IncidentTypeUNHANDLEDERROREVENT        IncidentType = "UNHANDLED_ERROR_EVENT"
	IncidentTypeUNKNOWN                    IncidentType = "UNKNOWN"
	IncidentTypeUNSPECIFIED                IncidentType = "UNSPECIFIED"
)

// Defines values for ProcessInstanceState.
const (
	ACTIVE    ProcessInstanceState = "ACTIVE"
	CANCELED  ProcessInstanceState = "CANCELED"
	COMPLETED ProcessInstanceState = "COMPLETED"
)

// Defines values for SortOrder.
const (
	ASC  SortOrder = "ASC"
	DESC SortOrder = "DESC"
)

// ChangeStatus defines model for ChangeStatus.
type ChangeStatus struct {
	Deleted *int64  `json:"deleted,omitempty"`
	Message *string `json:"message,omitempty"`
}

// DecisionDefinition defines model for DecisionDefinition.
type DecisionDefinition struct {
	DecisionId                  *string `json:"decisionId,omitempty"`
	DecisionRequirementsId      *string `json:"decisionRequirementsId,omitempty"`
	DecisionRequirementsKey     *int64  `json:"decisionRequirementsKey,omitempty"`
	DecisionRequirementsName    *string `json:"decisionRequirementsName,omitempty"`
	DecisionRequirementsVersion *int32  `json:"decisionRequirementsVersion,omitempty"`
	Id                          *string `json:"id,omitempty"`
	Key                         *int64  `json:"key,omitempty"`
	Name                        *string `json:"name,omitempty"`
	TenantId                    *string `json:"tenantId,omitempty"`
	Version                     *int32  `json:"version,omitempty"`
}

// DecisionInstance defines model for DecisionInstance.
type DecisionInstance struct {
	DecisionDefinitionId *string                       `json:"decisionDefinitionId,omitempty"`
	DecisionId           *string                       `json:"decisionId,omitempty"`
	DecisionName         *string                       `json:"decisionName,omitempty"`
	DecisionType         *DecisionInstanceDecisionType `json:"decisionType,omitempty"`
	DecisionVersion      *int32                        `json:"decisionVersion,omitempty"`
	EvaluatedInputs      *[]DecisionInstanceInput      `json:"evaluatedInputs,omitempty"`
	EvaluatedOutputs     *[]DecisionInstanceOutput     `json:"evaluatedOutputs,omitempty"`
	EvaluationDate       *string                       `json:"evaluationDate,omitempty"`
	EvaluationFailure    *string                       `json:"evaluationFailure,omitempty"`
	Id                   *string                       `json:"id,omitempty"`
	Key                  *int64                        `json:"key,omitempty"`
	ProcessDefinitionKey *int64                        `json:"processDefinitionKey,omitempty"`
	ProcessInstanceKey   *int64                        `json:"processInstanceKey,omitempty"`
	Result               *string                       `json:"result,omitempty"`
	State                *DecisionInstanceState        `json:"state,omitempty"`
	TenantId             *string                       `json:"tenantId,omitempty"`
}

// DecisionInstanceDecisionType defines model for DecisionInstance.DecisionType.
type DecisionInstanceDecisionType string

// DecisionInstanceState defines model for DecisionInstance.State.
type DecisionInstanceState string

// DecisionInstanceInput defines model for DecisionInstanceInput.
type DecisionInstanceInput struct {
	Id    *string `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// DecisionInstanceOutput defines model for DecisionInstanceOutput.
type DecisionInstanceOutput struct {
	Id        *string `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
	RuleId    *string `json:"ruleId,omitempty"`
	RuleIndex *int32  `json:"ruleIndex,omitempty"`
	Value     *string `json:"value,omitempty"`
}

// DecisionRequirements defines model for DecisionRequirements.
type DecisionRequirements struct {
	DecisionRequirementsId *string `json:"decisionRequirementsId,omitempty"`
	Id                     *string `json:"id,omitempty"`
	Key                    *int64  `json:"key,omitempty"`
	Name                   *string `json:"name,omitempty"`
	ResourceName           *string `json:"resourceName,omitempty"`
	TenantId               *string `json:"tenantId,omitempty"`
	Version                *int32  `json:"version,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Instance *string `json:"instance,omitempty"`
	Message  *string `json:"message,omitempty"`
	Status   *int32  `json:"status,omitempty"`
	Type     *string `json:"type,omitempty"`
}

// FlowNodeInstance defines model for FlowNodeInstance.
type FlowNodeInstance struct {
	EndDate              *string                `json:"endDate,omitempty"`
	FlowNodeId           *string                `json:"flowNodeId,omitempty"`
	FlowNodeName         *string                `json:"flowNodeName,omitempty"`
	Incident             *bool                  `json:"incident,omitempty"`
	IncidentKey          *int64                 `json:"incidentKey,omitempty"`
	Key                  *int64                 `json:"key,omitempty"`
	ProcessDefinitionKey *int64                 `json:"processDefinitionKey,omitempty"`
	ProcessInstanceKey   *int64                 `json:"processInstanceKey,omitempty"`
	StartDate            *string                `json:"startDate,omitempty"`
	State                *FlowNodeInstanceState `json:"state,omitempty"`
	TenantId             *string                `json:"tenantId,omitempty"`
	Type                 *FlowNodeInstanceType  `json:"type,omitempty"`
}

// FlowNodeInstanceState defines model for FlowNodeInstance.State.
type FlowNodeInstanceState string

// FlowNodeInstanceType defines model for FlowNodeInstance.Type.
type FlowNodeInstanceType string

// FlowNodeStatistics defines model for FlowNodeStatistics.
type FlowNodeStatistics struct {
	// Active The total number of active instances of the flow node
	Active *int64 `json:"active,omitempty"`

	// ActivityId The id of the flow node for which the results are aggregated
	ActivityId *string `json:"activityId,omitempty"`

	// Canceled The total number of canceled instances of the flow node
	Canceled *int64 `json:"canceled,omitempty"`

	// Completed The total number of completed instances of the flow node
	Completed *int64 `json:"completed,omitempty"`

	// Incidents The total number of incidents for the flow node
	Incidents *int64 `json:"incidents,omitempty"`
}

// Incident defines model for Incident.
type Incident struct {
	CreationTime         *string        `json:"creationTime,omitempty"`
	JobKey               *int64         `json:"jobKey,omitempty"`
	Key                  *int64         `json:"key,omitempty"`
	Message              *string        `json:"message,omitempty"`
	ProcessDefinitionKey *int64         `json:"processDefinitionKey,omitempty"`
	ProcessInstanceKey   *int64         `json:"processInstanceKey,omitempty"`
	State                *IncidentState `json:"state,omitempty"`
	TenantId             *string        `json:"tenantId,omitempty"`
	Type                 *IncidentType  `json:"type,omitempty"`
}

// IncidentState defines model for Incident.State.
type IncidentState string

// IncidentType defines model for Incident.Type.
type IncidentType string

// ProcessDefinition defines model for ProcessDefinition.
type ProcessDefinition struct {
	BpmnProcessId *string `json:"bpmnProcessId,omitempty"`
	Key           *int64  `json:"key,omitempty"`
	Name          *string `json:"name,omitempty"`
	TenantId      *string `json:"tenantId,omitempty"`
	Version       *int32  `json:"version,omitempty"`
	VersionTag    *string `json:"versionTag,omitempty"`
}

// ProcessInstance defines model for ProcessInstance.
type ProcessInstance struct {
	BpmnProcessId             *string               `json:"bpmnProcessId,omitempty"`
	EndDate                   *string               `json:"endDate,omitempty"`
	Incident                  *bool                 `json:"incident,omitempty"`
	Key                       *int64                `json:"key,omitempty"`
	ParentFlowNodeInstanceKey *int64                `json:"parentFlowNodeInstanceKey,omitempty"`
	ParentKey                 *int64                `json:"parentKey,omitempty"`
	ParentProcessInstanceKey  *ProcessInstance      `json:"parentProcessInstanceKey,omitempty"`
	ProcessDefinitionKey      *int64                `json:"processDefinitionKey,omitempty"`
	ProcessVersion            *int32                `json:"processVersion,omitempty"`
	ProcessVersionTag         *string               `json:"processVersionTag,omitempty"`
	StartDate                 *string               `json:"startDate,omitempty"`
	State                     *ProcessInstanceState `json:"state,omitempty"`
	TenantId                  *string               `json:"tenantId,omitempty"`
}

// ProcessInstanceState defines model for ProcessInstance.State.
type ProcessInstanceState string

// QueryDecisionDefinition defines model for QueryDecisionDefinition.
type QueryDecisionDefinition struct {
	Filter      *DecisionDefinition       `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryDecisionInstance defines model for QueryDecisionInstance.
type QueryDecisionInstance struct {
	Filter      *DecisionInstance         `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryDecisionRequirements defines model for QueryDecisionRequirements.
type QueryDecisionRequirements struct {
	Filter      *DecisionRequirements     `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryFlowNodeInstance defines model for QueryFlowNodeInstance.
type QueryFlowNodeInstance struct {
	Filter      *FlowNodeInstance         `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryIncident defines model for QueryIncident.
type QueryIncident struct {
	Filter      *Incident                 `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryProcessDefinition defines model for QueryProcessDefinition.
type QueryProcessDefinition struct {
	Filter      *ProcessDefinition        `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryProcessInstance defines model for QueryProcessInstance.
type QueryProcessInstance struct {
	Filter      *ProcessInstance          `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// QueryVariable defines model for QueryVariable.
type QueryVariable struct {
	Filter      *Variable                 `json:"filter,omitempty"`
	SearchAfter *[]map[string]interface{} `json:"searchAfter,omitempty"`
	Size        *int32                    `json:"size,omitempty"`
	Sort        *[]Sort                   `json:"sort,omitempty"`
}

// ResultsDecisionDefinition defines model for ResultsDecisionDefinition.
type ResultsDecisionDefinition struct {
	Items      *[]DecisionDefinition                        `json:"items,omitempty"`
	SortValues *[]ResultsDecisionDefinition_SortValues_Item `json:"sortValues,omitempty"`
	Total      *int64                                       `json:"total,omitempty"`
}

// ResultsDecisionDefinitionSortValues0 defines model for .
type ResultsDecisionDefinitionSortValues0 = string

// ResultsDecisionDefinitionSortValues1 defines model for .
type ResultsDecisionDefinitionSortValues1 = int

// ResultsDecisionDefinitionSortValues2 defines model for .
type ResultsDecisionDefinitionSortValues2 = float32

// ResultsDecisionDefinition_SortValues_Item defines model for ResultsDecisionDefinition.sortValues.Item.
type ResultsDecisionDefinition_SortValues_Item struct {
	union json.RawMessage
}

// ResultsDecisionInstance defines model for ResultsDecisionInstance.
type ResultsDecisionInstance struct {
	Items      *[]DecisionInstance                        `json:"items,omitempty"`
	SortValues *[]ResultsDecisionInstance_SortValues_Item `json:"sortValues,omitempty"`
	Total      *int64                                     `json:"total,omitempty"`
}

// ResultsDecisionInstanceSortValues0 defines model for .
type ResultsDecisionInstanceSortValues0 = string

// ResultsDecisionInstanceSortValues1 defines model for .
type ResultsDecisionInstanceSortValues1 = int

// ResultsDecisionInstanceSortValues2 defines model for .
type ResultsDecisionInstanceSortValues2 = float32

// ResultsDecisionInstance_SortValues_Item defines model for ResultsDecisionInstance.sortValues.Item.
type ResultsDecisionInstance_SortValues_Item struct {
	union json.RawMessage
}

// ResultsDecisionRequirements defines model for ResultsDecisionRequirements.
type ResultsDecisionRequirements struct {
	Items      *[]DecisionRequirements                        `json:"items,omitempty"`
	SortValues *[]ResultsDecisionRequirements_SortValues_Item `json:"sortValues,omitempty"`
	Total      *int64                                         `json:"total,omitempty"`
}

// ResultsDecisionRequirementsSortValues0 defines model for .
type ResultsDecisionRequirementsSortValues0 = string

// ResultsDecisionRequirementsSortValues1 defines model for .
type ResultsDecisionRequirementsSortValues1 = int

// ResultsDecisionRequirementsSortValues2 defines model for .
type ResultsDecisionRequirementsSortValues2 = float32

// ResultsDecisionRequirements_SortValues_Item defines model for ResultsDecisionRequirements.sortValues.Item.
type ResultsDecisionRequirements_SortValues_Item struct {
	union json.RawMessage
}

// ResultsFlowNodeInstance defines model for ResultsFlowNodeInstance.
type ResultsFlowNodeInstance struct {
	Items      *[]FlowNodeInstance                        `json:"items,omitempty"`
	SortValues *[]ResultsFlowNodeInstance_SortValues_Item `json:"sortValues,omitempty"`
	Total      *int64                                     `json:"total,omitempty"`
}

// ResultsFlowNodeInstanceSortValues0 defines model for .
type ResultsFlowNodeInstanceSortValues0 = string

// ResultsFlowNodeInstanceSortValues1 defines model for .
type ResultsFlowNodeInstanceSortValues1 = int

// ResultsFlowNodeInstanceSortValues2 defines model for .
type ResultsFlowNodeInstanceSortValues2 = float32

// ResultsFlowNodeInstance_SortValues_Item defines model for ResultsFlowNodeInstance.sortValues.Item.
type ResultsFlowNodeInstance_SortValues_Item struct {
	union json.RawMessage
}

// ResultsIncident defines model for ResultsIncident.
type ResultsIncident struct {
	Items      *[]Incident                        `json:"items,omitempty"`
	SortValues *[]ResultsIncident_SortValues_Item `json:"sortValues,omitempty"`
	Total      *int64                             `json:"total,omitempty"`
}

// ResultsIncidentSortValues0 defines model for .
type ResultsIncidentSortValues0 = string

// ResultsIncidentSortValues1 defines model for .
type ResultsIncidentSortValues1 = int

// ResultsIncidentSortValues2 defines model for .
type ResultsIncidentSortValues2 = float32

// ResultsIncident_SortValues_Item defines model for ResultsIncident.sortValues.Item.
type ResultsIncident_SortValues_Item struct {
	union json.RawMessage
}

// ResultsProcessDefinition defines model for ResultsProcessDefinition.
type ResultsProcessDefinition struct {
	Items      *[]ProcessDefinition                        `json:"items,omitempty"`
	SortValues *[]ResultsProcessDefinition_SortValues_Item `json:"sortValues,omitempty"`
	Total      *int64                                      `json:"total,omitempty"`
}

// ResultsProcessDefinitionSortValues0 defines model for .
type ResultsProcessDefinitionSortValues0 = string

// ResultsProcessDefinitionSortValues1 defines model for .
type ResultsProcessDefinitionSortValues1 = int

// ResultsProcessDefinitionSortValues2 defines model for .
type ResultsProcessDefinitionSortValues2 = float32

// ResultsProcessDefinition_SortValues_Item defines model for ResultsProcessDefinition.sortValues.Item.
type ResultsProcessDefinition_SortValues_Item struct {
	union json.RawMessage
}

// ResultsProcessInstance defines model for ResultsProcessInstance.
type ResultsProcessInstance struct {
	Items      *[]ProcessInstance                        `json:"items,omitempty"`
	SortValues *[]ResultsProcessInstance_SortValues_Item `json:"sortValues,omitempty"`
	Total      *int64                                    `json:"total,omitempty"`
}

// ResultsProcessInstanceSortValues0 defines model for .
type ResultsProcessInstanceSortValues0 = string

// ResultsProcessInstanceSortValues1 defines model for .
type ResultsProcessInstanceSortValues1 = int

// ResultsProcessInstanceSortValues2 defines model for .
type ResultsProcessInstanceSortValues2 = float32

// ResultsProcessInstance_SortValues_Item defines model for ResultsProcessInstance.sortValues.Item.
type ResultsProcessInstance_SortValues_Item struct {
	union json.RawMessage
}

// ResultsVariable defines model for ResultsVariable.
type ResultsVariable struct {
	Items      *[]Variable                        `json:"items,omitempty"`
	SortValues *[]ResultsVariable_SortValues_Item `json:"sortValues,omitempty"`
	Total      *int64                             `json:"total,omitempty"`
}

// ResultsVariableSortValues0 defines model for .
type ResultsVariableSortValues0 = string

// ResultsVariableSortValues1 defines model for .
type ResultsVariableSortValues1 = int

// ResultsVariableSortValues2 defines model for .
type ResultsVariableSortValues2 = float32

// ResultsVariable_SortValues_Item defines model for ResultsVariable.sortValues.Item.
type ResultsVariable_SortValues_Item struct {
	union json.RawMessage
}

// Sort defines model for Sort.
type Sort struct {
	Field *string    `json:"field,omitempty"`
	Order *SortOrder `json:"order,omitempty"`
}

// SortOrder defines model for Sort.Order.
type SortOrder string

// Variable defines model for Variable.
type Variable struct {
	Key                *int64  `json:"key,omitempty"`
	Name               *string `json:"name,omitempty"`
	ProcessInstanceKey *int64  `json:"processInstanceKey,omitempty"`
	ScopeKey           *int64  `json:"scopeKey,omitempty"`
	TenantId           *string `json:"tenantId,omitempty"`
	Truncated          *bool   `json:"truncated,omitempty"`
	Value              *string `json:"value,omitempty"`
}

// SearchDecisionDefinitionsJSONRequestBody defines body for SearchDecisionDefinitions for application/json ContentType.
type SearchDecisionDefinitionsJSONRequestBody = QueryDecisionDefinition

// SearchDecisionInstancesJSONRequestBody defines body for SearchDecisionInstances for application/json ContentType.
type SearchDecisionInstancesJSONRequestBody = QueryDecisionInstance

// SearchDecisionRequirementsJSONRequestBody defines body for SearchDecisionRequirements for application/json ContentType.
type SearchDecisionRequirementsJSONRequestBody = QueryDecisionRequirements

// SearchFlownodeInstancesJSONRequestBody defines body for SearchFlownodeInstances for application/json ContentType.
type SearchFlownodeInstancesJSONRequestBody = QueryFlowNodeInstance

// SearchIncidentsJSONRequestBody defines body for SearchIncidents for application/json ContentType.
type SearchIncidentsJSONRequestBody = QueryIncident

// SearchProcessDefinitionsJSONRequestBody defines body for SearchProcessDefinitions for application/json ContentType.
type SearchProcessDefinitionsJSONRequestBody = QueryProcessDefinition

// SearchProcessInstancesJSONRequestBody defines body for SearchProcessInstances for application/json ContentType.
type SearchProcessInstancesJSONRequestBody = QueryProcessInstance

// SearchVariablesForProcessInstancesJSONRequestBody defines body for SearchVariablesForProcessInstances for application/json ContentType.
type SearchVariablesForProcessInstancesJSONRequestBody = QueryVariable

// AsResultsDecisionDefinitionSortValues0 returns the union data inside the ResultsDecisionDefinition_SortValues_Item as a ResultsDecisionDefinitionSortValues0
func (t ResultsDecisionDefinition_SortValues_Item) AsResultsDecisionDefinitionSortValues0() (ResultsDecisionDefinitionSortValues0, error) {
	var body ResultsDecisionDefinitionSortValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsDecisionDefinitionSortValues0 overwrites any union data inside the ResultsDecisionDefinition_SortValues_Item as the provided ResultsDecisionDefinitionSortValues0
func (t *ResultsDecisionDefinition_SortValues_Item) FromResultsDecisionDefinitionSortValues0(v ResultsDecisionDefinitionSortValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsDecisionDefinitionSortValues0 performs a merge with any union data inside the ResultsDecisionDefinition_SortValues_Item, using the provided ResultsDecisionDefinitionSortValues0
func (t *ResultsDecisionDefinition_SortValues_Item) MergeResultsDecisionDefinitionSortValues0(v ResultsDecisionDefinitionSortValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsDecisionDefinitionSortValues1 returns the union data inside the ResultsDecisionDefinition_SortValues_Item as a ResultsDecisionDefinitionSortValues1
func (t ResultsDecisionDefinition_SortValues_Item) AsResultsDecisionDefinitionSortValues1() (ResultsDecisionDefinitionSortValues1, error) {
	var body ResultsDecisionDefinitionSortValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsDecisionDefinitionSortValues1 overwrites any union data inside the ResultsDecisionDefinition_SortValues_Item as the provided ResultsDecisionDefinitionSortValues1
func (t *ResultsDecisionDefinition_SortValues_Item) FromResultsDecisionDefinitionSortValues1(v ResultsDecisionDefinitionSortValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsDecisionDefinitionSortValues1 performs a merge with any union data inside the ResultsDecisionDefinition_SortValues_Item, using the provided ResultsDecisionDefinitionSortValues1
func (t *ResultsDecisionDefinition_SortValues_Item) MergeResultsDecisionDefinitionSortValues1(v ResultsDecisionDefinitionSortValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsDecisionDefinitionSortValues2 returns the union data inside the ResultsDecisionDefinition_SortValues_Item as a ResultsDecisionDefinitionSortValues2
func (t ResultsDecisionDefinition_SortValues_Item) AsResultsDecisionDefinitionSortValues2() (ResultsDecisionDefinitionSortValues2, error) {
	var body ResultsDecisionDefinitionSortValues2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsDecisionDefinitionSortValues2 overwrites any union data inside the ResultsDecisionDefinition_SortValues_Item as the provided ResultsDecisionDefinitionSortValues2
func (t *ResultsDecisionDefinition_SortValues_Item) FromResultsDecisionDefinitionSortValues2(v ResultsDecisionDefinitionSortValues2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsDecisionDefinitionSortValues2 performs a merge with any union data inside the ResultsDecisionDefinition_SortValues_Item, using the provided ResultsDecisionDefinitionSortValues2
func (t *ResultsDecisionDefinition_SortValues_Item) MergeResultsDecisionDefinitionSortValues2(v ResultsDecisionDefinitionSortValues2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResultsDecisionDefinition_SortValues_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResultsDecisionDefinition_SortValues_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResultsDecisionInstanceSortValues0 returns the union data inside the ResultsDecisionInstance_SortValues_Item as a ResultsDecisionInstanceSortValues0
func (t ResultsDecisionInstance_SortValues_Item) AsResultsDecisionInstanceSortValues0() (ResultsDecisionInstanceSortValues0, error) {
	var body ResultsDecisionInstanceSortValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsDecisionInstanceSortValues0 overwrites any union data inside the ResultsDecisionInstance_SortValues_Item as the provided ResultsDecisionInstanceSortValues0
func (t *ResultsDecisionInstance_SortValues_Item) FromResultsDecisionInstanceSortValues0(v ResultsDecisionInstanceSortValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsDecisionInstanceSortValues0 performs a merge with any union data inside the ResultsDecisionInstance_SortValues_Item, using the provided ResultsDecisionInstanceSortValues0
func (t *ResultsDecisionInstance_SortValues_Item) MergeResultsDecisionInstanceSortValues0(v ResultsDecisionInstanceSortValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsDecisionInstanceSortValues1 returns the union data inside the ResultsDecisionInstance_SortValues_Item as a ResultsDecisionInstanceSortValues1
func (t ResultsDecisionInstance_SortValues_Item) AsResultsDecisionInstanceSortValues1() (ResultsDecisionInstanceSortValues1, error) {
	var body ResultsDecisionInstanceSortValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsDecisionInstanceSortValues1 overwrites any union data inside the ResultsDecisionInstance_SortValues_Item as the provided ResultsDecisionInstanceSortValues1
func (t *ResultsDecisionInstance_SortValues_Item) FromResultsDecisionInstanceSortValues1(v ResultsDecisionInstanceSortValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsDecisionInstanceSortValues1 performs a merge with any union data inside the ResultsDecisionInstance_SortValues_Item, using the provided ResultsDecisionInstanceSortValues1
func (t *ResultsDecisionInstance_SortValues_Item) MergeResultsDecisionInstanceSortValues1(v ResultsDecisionInstanceSortValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsDecisionInstanceSortValues2 returns the union data inside the ResultsDecisionInstance_SortValues_Item as a ResultsDecisionInstanceSortValues2
func (t ResultsDecisionInstance_SortValues_Item) AsResultsDecisionInstanceSortValues2() (ResultsDecisionInstanceSortValues2, error) {
	var body ResultsDecisionInstanceSortValues2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsDecisionInstanceSortValues2 overwrites any union data inside the ResultsDecisionInstance_SortValues_Item as the provided ResultsDecisionInstanceSortValues2
func (t *ResultsDecisionInstance_SortValues_Item) FromResultsDecisionInstanceSortValues2(v ResultsDecisionInstanceSortValues2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsDecisionInstanceSortValues2 performs a merge with any union data inside the ResultsDecisionInstance_SortValues_Item, using the provided ResultsDecisionInstanceSortValues2
func (t *ResultsDecisionInstance_SortValues_Item) MergeResultsDecisionInstanceSortValues2(v ResultsDecisionInstanceSortValues2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResultsDecisionInstance_SortValues_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResultsDecisionInstance_SortValues_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResultsDecisionRequirementsSortValues0 returns the union data inside the ResultsDecisionRequirements_SortValues_Item as a ResultsDecisionRequirementsSortValues0
func (t ResultsDecisionRequirements_SortValues_Item) AsResultsDecisionRequirementsSortValues0() (ResultsDecisionRequirementsSortValues0, error) {
	var body ResultsDecisionRequirementsSortValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsDecisionRequirementsSortValues0 overwrites any union data inside the ResultsDecisionRequirements_SortValues_Item as the provided ResultsDecisionRequirementsSortValues0
func (t *ResultsDecisionRequirements_SortValues_Item) FromResultsDecisionRequirementsSortValues0(v ResultsDecisionRequirementsSortValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsDecisionRequirementsSortValues0 performs a merge with any union data inside the ResultsDecisionRequirements_SortValues_Item, using the provided ResultsDecisionRequirementsSortValues0
func (t *ResultsDecisionRequirements_SortValues_Item) MergeResultsDecisionRequirementsSortValues0(v ResultsDecisionRequirementsSortValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsDecisionRequirementsSortValues1 returns the union data inside the ResultsDecisionRequirements_SortValues_Item as a ResultsDecisionRequirementsSortValues1
func (t ResultsDecisionRequirements_SortValues_Item) AsResultsDecisionRequirementsSortValues1() (ResultsDecisionRequirementsSortValues1, error) {
	var body ResultsDecisionRequirementsSortValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsDecisionRequirementsSortValues1 overwrites any union data inside the ResultsDecisionRequirements_SortValues_Item as the provided ResultsDecisionRequirementsSortValues1
func (t *ResultsDecisionRequirements_SortValues_Item) FromResultsDecisionRequirementsSortValues1(v ResultsDecisionRequirementsSortValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsDecisionRequirementsSortValues1 performs a merge with any union data inside the ResultsDecisionRequirements_SortValues_Item, using the provided ResultsDecisionRequirementsSortValues1
func (t *ResultsDecisionRequirements_SortValues_Item) MergeResultsDecisionRequirementsSortValues1(v ResultsDecisionRequirementsSortValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsDecisionRequirementsSortValues2 returns the union data inside the ResultsDecisionRequirements_SortValues_Item as a ResultsDecisionRequirementsSortValues2
func (t ResultsDecisionRequirements_SortValues_Item) AsResultsDecisionRequirementsSortValues2() (ResultsDecisionRequirementsSortValues2, error) {
	var body ResultsDecisionRequirementsSortValues2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsDecisionRequirementsSortValues2 overwrites any union data inside the ResultsDecisionRequirements_SortValues_Item as the provided ResultsDecisionRequirementsSortValues2
func (t *ResultsDecisionRequirements_SortValues_Item) FromResultsDecisionRequirementsSortValues2(v ResultsDecisionRequirementsSortValues2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsDecisionRequirementsSortValues2 performs a merge with any union data inside the ResultsDecisionRequirements_SortValues_Item, using the provided ResultsDecisionRequirementsSortValues2
func (t *ResultsDecisionRequirements_SortValues_Item) MergeResultsDecisionRequirementsSortValues2(v ResultsDecisionRequirementsSortValues2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResultsDecisionRequirements_SortValues_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResultsDecisionRequirements_SortValues_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResultsFlowNodeInstanceSortValues0 returns the union data inside the ResultsFlowNodeInstance_SortValues_Item as a ResultsFlowNodeInstanceSortValues0
func (t ResultsFlowNodeInstance_SortValues_Item) AsResultsFlowNodeInstanceSortValues0() (ResultsFlowNodeInstanceSortValues0, error) {
	var body ResultsFlowNodeInstanceSortValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsFlowNodeInstanceSortValues0 overwrites any union data inside the ResultsFlowNodeInstance_SortValues_Item as the provided ResultsFlowNodeInstanceSortValues0
func (t *ResultsFlowNodeInstance_SortValues_Item) FromResultsFlowNodeInstanceSortValues0(v ResultsFlowNodeInstanceSortValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsFlowNodeInstanceSortValues0 performs a merge with any union data inside the ResultsFlowNodeInstance_SortValues_Item, using the provided ResultsFlowNodeInstanceSortValues0
func (t *ResultsFlowNodeInstance_SortValues_Item) MergeResultsFlowNodeInstanceSortValues0(v ResultsFlowNodeInstanceSortValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsFlowNodeInstanceSortValues1 returns the union data inside the ResultsFlowNodeInstance_SortValues_Item as a ResultsFlowNodeInstanceSortValues1
func (t ResultsFlowNodeInstance_SortValues_Item) AsResultsFlowNodeInstanceSortValues1() (ResultsFlowNodeInstanceSortValues1, error) {
	var body ResultsFlowNodeInstanceSortValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsFlowNodeInstanceSortValues1 overwrites any union data inside the ResultsFlowNodeInstance_SortValues_Item as the provided ResultsFlowNodeInstanceSortValues1
func (t *ResultsFlowNodeInstance_SortValues_Item) FromResultsFlowNodeInstanceSortValues1(v ResultsFlowNodeInstanceSortValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsFlowNodeInstanceSortValues1 performs a merge with any union data inside the ResultsFlowNodeInstance_SortValues_Item, using the provided ResultsFlowNodeInstanceSortValues1
func (t *ResultsFlowNodeInstance_SortValues_Item) MergeResultsFlowNodeInstanceSortValues1(v ResultsFlowNodeInstanceSortValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsFlowNodeInstanceSortValues2 returns the union data inside the ResultsFlowNodeInstance_SortValues_Item as a ResultsFlowNodeInstanceSortValues2
func (t ResultsFlowNodeInstance_SortValues_Item) AsResultsFlowNodeInstanceSortValues2() (ResultsFlowNodeInstanceSortValues2, error) {
	var body ResultsFlowNodeInstanceSortValues2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsFlowNodeInstanceSortValues2 overwrites any union data inside the ResultsFlowNodeInstance_SortValues_Item as the provided ResultsFlowNodeInstanceSortValues2
func (t *ResultsFlowNodeInstance_SortValues_Item) FromResultsFlowNodeInstanceSortValues2(v ResultsFlowNodeInstanceSortValues2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsFlowNodeInstanceSortValues2 performs a merge with any union data inside the ResultsFlowNodeInstance_SortValues_Item, using the provided ResultsFlowNodeInstanceSortValues2
func (t *ResultsFlowNodeInstance_SortValues_Item) MergeResultsFlowNodeInstanceSortValues2(v ResultsFlowNodeInstanceSortValues2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResultsFlowNodeInstance_SortValues_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResultsFlowNodeInstance_SortValues_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResultsIncidentSortValues0 returns the union data inside the ResultsIncident_SortValues_Item as a ResultsIncidentSortValues0
func (t ResultsIncident_SortValues_Item) AsResultsIncidentSortValues0() (ResultsIncidentSortValues0, error) {
	var body ResultsIncidentSortValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsIncidentSortValues0 overwrites any union data inside the ResultsIncident_SortValues_Item as the provided ResultsIncidentSortValues0
func (t *ResultsIncident_SortValues_Item) FromResultsIncidentSortValues0(v ResultsIncidentSortValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsIncidentSortValues0 performs a merge with any union data inside the ResultsIncident_SortValues_Item, using the provided ResultsIncidentSortValues0
func (t *ResultsIncident_SortValues_Item) MergeResultsIncidentSortValues0(v ResultsIncidentSortValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsIncidentSortValues1 returns the union data inside the ResultsIncident_SortValues_Item as a ResultsIncidentSortValues1
func (t ResultsIncident_SortValues_Item) AsResultsIncidentSortValues1() (ResultsIncidentSortValues1, error) {
	var body ResultsIncidentSortValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsIncidentSortValues1 overwrites any union data inside the ResultsIncident_SortValues_Item as the provided ResultsIncidentSortValues1
func (t *ResultsIncident_SortValues_Item) FromResultsIncidentSortValues1(v ResultsIncidentSortValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsIncidentSortValues1 performs a merge with any union data inside the ResultsIncident_SortValues_Item, using the provided ResultsIncidentSortValues1
func (t *ResultsIncident_SortValues_Item) MergeResultsIncidentSortValues1(v ResultsIncidentSortValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsIncidentSortValues2 returns the union data inside the ResultsIncident_SortValues_Item as a ResultsIncidentSortValues2
func (t ResultsIncident_SortValues_Item) AsResultsIncidentSortValues2() (ResultsIncidentSortValues2, error) {
	var body ResultsIncidentSortValues2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsIncidentSortValues2 overwrites any union data inside the ResultsIncident_SortValues_Item as the provided ResultsIncidentSortValues2
func (t *ResultsIncident_SortValues_Item) FromResultsIncidentSortValues2(v ResultsIncidentSortValues2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsIncidentSortValues2 performs a merge with any union data inside the ResultsIncident_SortValues_Item, using the provided ResultsIncidentSortValues2
func (t *ResultsIncident_SortValues_Item) MergeResultsIncidentSortValues2(v ResultsIncidentSortValues2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResultsIncident_SortValues_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResultsIncident_SortValues_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResultsProcessDefinitionSortValues0 returns the union data inside the ResultsProcessDefinition_SortValues_Item as a ResultsProcessDefinitionSortValues0
func (t ResultsProcessDefinition_SortValues_Item) AsResultsProcessDefinitionSortValues0() (ResultsProcessDefinitionSortValues0, error) {
	var body ResultsProcessDefinitionSortValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsProcessDefinitionSortValues0 overwrites any union data inside the ResultsProcessDefinition_SortValues_Item as the provided ResultsProcessDefinitionSortValues0
func (t *ResultsProcessDefinition_SortValues_Item) FromResultsProcessDefinitionSortValues0(v ResultsProcessDefinitionSortValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsProcessDefinitionSortValues0 performs a merge with any union data inside the ResultsProcessDefinition_SortValues_Item, using the provided ResultsProcessDefinitionSortValues0
func (t *ResultsProcessDefinition_SortValues_Item) MergeResultsProcessDefinitionSortValues0(v ResultsProcessDefinitionSortValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsProcessDefinitionSortValues1 returns the union data inside the ResultsProcessDefinition_SortValues_Item as a ResultsProcessDefinitionSortValues1
func (t ResultsProcessDefinition_SortValues_Item) AsResultsProcessDefinitionSortValues1() (ResultsProcessDefinitionSortValues1, error) {
	var body ResultsProcessDefinitionSortValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsProcessDefinitionSortValues1 overwrites any union data inside the ResultsProcessDefinition_SortValues_Item as the provided ResultsProcessDefinitionSortValues1
func (t *ResultsProcessDefinition_SortValues_Item) FromResultsProcessDefinitionSortValues1(v ResultsProcessDefinitionSortValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsProcessDefinitionSortValues1 performs a merge with any union data inside the ResultsProcessDefinition_SortValues_Item, using the provided ResultsProcessDefinitionSortValues1
func (t *ResultsProcessDefinition_SortValues_Item) MergeResultsProcessDefinitionSortValues1(v ResultsProcessDefinitionSortValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsProcessDefinitionSortValues2 returns the union data inside the ResultsProcessDefinition_SortValues_Item as a ResultsProcessDefinitionSortValues2
func (t ResultsProcessDefinition_SortValues_Item) AsResultsProcessDefinitionSortValues2() (ResultsProcessDefinitionSortValues2, error) {
	var body ResultsProcessDefinitionSortValues2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsProcessDefinitionSortValues2 overwrites any union data inside the ResultsProcessDefinition_SortValues_Item as the provided ResultsProcessDefinitionSortValues2
func (t *ResultsProcessDefinition_SortValues_Item) FromResultsProcessDefinitionSortValues2(v ResultsProcessDefinitionSortValues2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsProcessDefinitionSortValues2 performs a merge with any union data inside the ResultsProcessDefinition_SortValues_Item, using the provided ResultsProcessDefinitionSortValues2
func (t *ResultsProcessDefinition_SortValues_Item) MergeResultsProcessDefinitionSortValues2(v ResultsProcessDefinitionSortValues2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResultsProcessDefinition_SortValues_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResultsProcessDefinition_SortValues_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResultsProcessInstanceSortValues0 returns the union data inside the ResultsProcessInstance_SortValues_Item as a ResultsProcessInstanceSortValues0
func (t ResultsProcessInstance_SortValues_Item) AsResultsProcessInstanceSortValues0() (ResultsProcessInstanceSortValues0, error) {
	var body ResultsProcessInstanceSortValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsProcessInstanceSortValues0 overwrites any union data inside the ResultsProcessInstance_SortValues_Item as the provided ResultsProcessInstanceSortValues0
func (t *ResultsProcessInstance_SortValues_Item) FromResultsProcessInstanceSortValues0(v ResultsProcessInstanceSortValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsProcessInstanceSortValues0 performs a merge with any union data inside the ResultsProcessInstance_SortValues_Item, using the provided ResultsProcessInstanceSortValues0
func (t *ResultsProcessInstance_SortValues_Item) MergeResultsProcessInstanceSortValues0(v ResultsProcessInstanceSortValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsProcessInstanceSortValues1 returns the union data inside the ResultsProcessInstance_SortValues_Item as a ResultsProcessInstanceSortValues1
func (t ResultsProcessInstance_SortValues_Item) AsResultsProcessInstanceSortValues1() (ResultsProcessInstanceSortValues1, error) {
	var body ResultsProcessInstanceSortValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsProcessInstanceSortValues1 overwrites any union data inside the ResultsProcessInstance_SortValues_Item as the provided ResultsProcessInstanceSortValues1
func (t *ResultsProcessInstance_SortValues_Item) FromResultsProcessInstanceSortValues1(v ResultsProcessInstanceSortValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsProcessInstanceSortValues1 performs a merge with any union data inside the ResultsProcessInstance_SortValues_Item, using the provided ResultsProcessInstanceSortValues1
func (t *ResultsProcessInstance_SortValues_Item) MergeResultsProcessInstanceSortValues1(v ResultsProcessInstanceSortValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsProcessInstanceSortValues2 returns the union data inside the ResultsProcessInstance_SortValues_Item as a ResultsProcessInstanceSortValues2
func (t ResultsProcessInstance_SortValues_Item) AsResultsProcessInstanceSortValues2() (ResultsProcessInstanceSortValues2, error) {
	var body ResultsProcessInstanceSortValues2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsProcessInstanceSortValues2 overwrites any union data inside the ResultsProcessInstance_SortValues_Item as the provided ResultsProcessInstanceSortValues2
func (t *ResultsProcessInstance_SortValues_Item) FromResultsProcessInstanceSortValues2(v ResultsProcessInstanceSortValues2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsProcessInstanceSortValues2 performs a merge with any union data inside the ResultsProcessInstance_SortValues_Item, using the provided ResultsProcessInstanceSortValues2
func (t *ResultsProcessInstance_SortValues_Item) MergeResultsProcessInstanceSortValues2(v ResultsProcessInstanceSortValues2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResultsProcessInstance_SortValues_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResultsProcessInstance_SortValues_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResultsVariableSortValues0 returns the union data inside the ResultsVariable_SortValues_Item as a ResultsVariableSortValues0
func (t ResultsVariable_SortValues_Item) AsResultsVariableSortValues0() (ResultsVariableSortValues0, error) {
	var body ResultsVariableSortValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsVariableSortValues0 overwrites any union data inside the ResultsVariable_SortValues_Item as the provided ResultsVariableSortValues0
func (t *ResultsVariable_SortValues_Item) FromResultsVariableSortValues0(v ResultsVariableSortValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsVariableSortValues0 performs a merge with any union data inside the ResultsVariable_SortValues_Item, using the provided ResultsVariableSortValues0
func (t *ResultsVariable_SortValues_Item) MergeResultsVariableSortValues0(v ResultsVariableSortValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsVariableSortValues1 returns the union data inside the ResultsVariable_SortValues_Item as a ResultsVariableSortValues1
func (t ResultsVariable_SortValues_Item) AsResultsVariableSortValues1() (ResultsVariableSortValues1, error) {
	var body ResultsVariableSortValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsVariableSortValues1 overwrites any union data inside the ResultsVariable_SortValues_Item as the provided ResultsVariableSortValues1
func (t *ResultsVariable_SortValues_Item) FromResultsVariableSortValues1(v ResultsVariableSortValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsVariableSortValues1 performs a merge with any union data inside the ResultsVariable_SortValues_Item, using the provided ResultsVariableSortValues1
func (t *ResultsVariable_SortValues_Item) MergeResultsVariableSortValues1(v ResultsVariableSortValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsVariableSortValues2 returns the union data inside the ResultsVariable_SortValues_Item as a ResultsVariableSortValues2
func (t ResultsVariable_SortValues_Item) AsResultsVariableSortValues2() (ResultsVariableSortValues2, error) {
	var body ResultsVariableSortValues2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsVariableSortValues2 overwrites any union data inside the ResultsVariable_SortValues_Item as the provided ResultsVariableSortValues2
func (t *ResultsVariable_SortValues_Item) FromResultsVariableSortValues2(v ResultsVariableSortValues2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsVariableSortValues2 performs a merge with any union data inside the ResultsVariable_SortValues_Item, using the provided ResultsVariableSortValues2
func (t *ResultsVariable_SortValues_Item) MergeResultsVariableSortValues2(v ResultsVariableSortValues2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResultsVariable_SortValues_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResultsVariable_SortValues_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SearchDecisionDefinitionsWithBody request with any body
	SearchDecisionDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDecisionDefinitions(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionDefinitionByKey request
	GetDecisionDefinitionByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDecisionInstancesWithBody request with any body
	SearchDecisionInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDecisionInstances(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionInstanceById request
	GetDecisionInstanceById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDecisionRequirementsWithBody request with any body
	SearchDecisionRequirementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDecisionRequirements(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionRequirementsByKey request
	GetDecisionRequirementsByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionRequirementsAsXmlByKey request
	GetDecisionRequirementsAsXmlByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchFlownodeInstancesWithBody request with any body
	SearchFlownodeInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchFlownodeInstances(ctx context.Context, body SearchFlownodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowNodeInstanceByKey request
	GetFlowNodeInstanceByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchIncidentsWithBody request with any body
	SearchIncidentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchIncidents(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncidentByKey request
	GetIncidentByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchProcessDefinitionsWithBody request with any body
	SearchProcessDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchProcessDefinitions(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefinitionByKey request
	GetProcessDefinitionByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefinitionAsXmlByKey request
	GetProcessDefinitionAsXmlByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchProcessInstancesWithBody request with any body
	SearchProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchProcessInstances(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProcessInstanceAndAllDependantDataByKey request
	DeleteProcessInstanceAndAllDependantDataByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessInstanceByKey request
	GetProcessInstanceByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSequenceFlowsOfProcessInstanceByKey request
	GetSequenceFlowsOfProcessInstanceByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowNodeStatisticByProcessInstanceId request
	GetFlowNodeStatisticByProcessInstanceId(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchVariablesForProcessInstancesWithBody request with any body
	SearchVariablesForProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchVariablesForProcessInstances(ctx context.Context, body SearchVariablesForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariableByKey request
	GetVariableByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SearchDecisionDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionDefinitionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionDefinitions(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionDefinitionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionDefinitionByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionDefinitionByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionInstances(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionInstanceById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionInstanceByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionRequirementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionRequirementsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDecisionRequirements(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDecisionRequirementsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionRequirementsByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionRequirementsByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionRequirementsAsXmlByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionRequirementsAsXmlByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchFlownodeInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchFlownodeInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchFlownodeInstances(ctx context.Context, body SearchFlownodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchFlownodeInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowNodeInstanceByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowNodeInstanceByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchIncidentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchIncidentsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchIncidents(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchIncidentsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncidentByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncidentByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessDefinitionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessDefinitions(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessDefinitionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinitionByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinitionAsXmlByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionAsXmlByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchProcessInstances(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchProcessInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProcessInstanceAndAllDependantDataByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProcessInstanceAndAllDependantDataByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessInstanceByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessInstanceByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSequenceFlowsOfProcessInstanceByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSequenceFlowsOfProcessInstanceByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowNodeStatisticByProcessInstanceId(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowNodeStatisticByProcessInstanceIdRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchVariablesForProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchVariablesForProcessInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchVariablesForProcessInstances(ctx context.Context, body SearchVariablesForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchVariablesForProcessInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariableByKey(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSearchDecisionDefinitionsRequest calls the generic SearchDecisionDefinitions builder with application/json body
func NewSearchDecisionDefinitionsRequest(server string, body SearchDecisionDefinitionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDecisionDefinitionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchDecisionDefinitionsRequestWithBody generates requests for SearchDecisionDefinitions with any type of body
func NewSearchDecisionDefinitionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/decision-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionDefinitionByKeyRequest generates requests for GetDecisionDefinitionByKey
func NewGetDecisionDefinitionByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/decision-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDecisionInstancesRequest calls the generic SearchDecisionInstances builder with application/json body
func NewSearchDecisionInstancesRequest(server string, body SearchDecisionInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDecisionInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchDecisionInstancesRequestWithBody generates requests for SearchDecisionInstances with any type of body
func NewSearchDecisionInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/decision-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionInstanceByIdRequest generates requests for GetDecisionInstanceById
func NewGetDecisionInstanceByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/decision-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDecisionRequirementsRequest calls the generic SearchDecisionRequirements builder with application/json body
func NewSearchDecisionRequirementsRequest(server string, body SearchDecisionRequirementsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDecisionRequirementsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchDecisionRequirementsRequestWithBody generates requests for SearchDecisionRequirements with any type of body
func NewSearchDecisionRequirementsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/drd/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionRequirementsByKeyRequest generates requests for GetDecisionRequirementsByKey
func NewGetDecisionRequirementsByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/drd/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDecisionRequirementsAsXmlByKeyRequest generates requests for GetDecisionRequirementsAsXmlByKey
func NewGetDecisionRequirementsAsXmlByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/drd/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchFlownodeInstancesRequest calls the generic SearchFlownodeInstances builder with application/json body
func NewSearchFlownodeInstancesRequest(server string, body SearchFlownodeInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchFlownodeInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchFlownodeInstancesRequestWithBody generates requests for SearchFlownodeInstances with any type of body
func NewSearchFlownodeInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/flownode-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFlowNodeInstanceByKeyRequest generates requests for GetFlowNodeInstanceByKey
func NewGetFlowNodeInstanceByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/flownode-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchIncidentsRequest calls the generic SearchIncidents builder with application/json body
func NewSearchIncidentsRequest(server string, body SearchIncidentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchIncidentsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchIncidentsRequestWithBody generates requests for SearchIncidents with any type of body
func NewSearchIncidentsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/incidents/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIncidentByKeyRequest generates requests for GetIncidentByKey
func NewGetIncidentByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/incidents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchProcessDefinitionsRequest calls the generic SearchProcessDefinitions builder with application/json body
func NewSearchProcessDefinitionsRequest(server string, body SearchProcessDefinitionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchProcessDefinitionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchProcessDefinitionsRequestWithBody generates requests for SearchProcessDefinitions with any type of body
func NewSearchProcessDefinitionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessDefinitionByKeyRequest generates requests for GetProcessDefinitionByKey
func NewGetProcessDefinitionByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessDefinitionAsXmlByKeyRequest generates requests for GetProcessDefinitionAsXmlByKey
func NewGetProcessDefinitionAsXmlByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-definitions/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchProcessInstancesRequest calls the generic SearchProcessInstances builder with application/json body
func NewSearchProcessInstancesRequest(server string, body SearchProcessInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchProcessInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchProcessInstancesRequestWithBody generates requests for SearchProcessInstances with any type of body
func NewSearchProcessInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProcessInstanceAndAllDependantDataByKeyRequest generates requests for DeleteProcessInstanceAndAllDependantDataByKey
func NewDeleteProcessInstanceAndAllDependantDataByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessInstanceByKeyRequest generates requests for GetProcessInstanceByKey
func NewGetProcessInstanceByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSequenceFlowsOfProcessInstanceByKeyRequest generates requests for GetSequenceFlowsOfProcessInstanceByKey
func NewGetSequenceFlowsOfProcessInstanceByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-instances/%s/sequence-flows", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowNodeStatisticByProcessInstanceIdRequest generates requests for GetFlowNodeStatisticByProcessInstanceId
func NewGetFlowNodeStatisticByProcessInstanceIdRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/process-instances/%s/statistics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchVariablesForProcessInstancesRequest calls the generic SearchVariablesForProcessInstances builder with application/json body
func NewSearchVariablesForProcessInstancesRequest(server string, body SearchVariablesForProcessInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchVariablesForProcessInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchVariablesForProcessInstancesRequestWithBody generates requests for SearchVariablesForProcessInstances with any type of body
func NewSearchVariablesForProcessInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/variables/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVariableByKeyRequest generates requests for GetVariableByKey
func NewGetVariableByKeyRequest(server string, key int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SearchDecisionDefinitionsWithBodyWithResponse request with any body
	SearchDecisionDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error)

	SearchDecisionDefinitionsWithResponse(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error)

	// GetDecisionDefinitionByKeyWithResponse request
	GetDecisionDefinitionByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionByKeyResponse, error)

	// SearchDecisionInstancesWithBodyWithResponse request with any body
	SearchDecisionInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error)

	SearchDecisionInstancesWithResponse(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error)

	// GetDecisionInstanceByIdWithResponse request
	GetDecisionInstanceByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDecisionInstanceByIdResponse, error)

	// SearchDecisionRequirementsWithBodyWithResponse request with any body
	SearchDecisionRequirementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error)

	SearchDecisionRequirementsWithResponse(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error)

	// GetDecisionRequirementsByKeyWithResponse request
	GetDecisionRequirementsByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsByKeyResponse, error)

	// GetDecisionRequirementsAsXmlByKeyWithResponse request
	GetDecisionRequirementsAsXmlByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsAsXmlByKeyResponse, error)

	// SearchFlownodeInstancesWithBodyWithResponse request with any body
	SearchFlownodeInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchFlownodeInstancesResponse, error)

	SearchFlownodeInstancesWithResponse(ctx context.Context, body SearchFlownodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchFlownodeInstancesResponse, error)

	// GetFlowNodeInstanceByKeyWithResponse request
	GetFlowNodeInstanceByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetFlowNodeInstanceByKeyResponse, error)

	// SearchIncidentsWithBodyWithResponse request with any body
	SearchIncidentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error)

	SearchIncidentsWithResponse(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error)

	// GetIncidentByKeyWithResponse request
	GetIncidentByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetIncidentByKeyResponse, error)

	// SearchProcessDefinitionsWithBodyWithResponse request with any body
	SearchProcessDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error)

	SearchProcessDefinitionsWithResponse(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error)

	// GetProcessDefinitionByKeyWithResponse request
	GetProcessDefinitionByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetProcessDefinitionByKeyResponse, error)

	// GetProcessDefinitionAsXmlByKeyWithResponse request
	GetProcessDefinitionAsXmlByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetProcessDefinitionAsXmlByKeyResponse, error)

	// SearchProcessInstancesWithBodyWithResponse request with any body
	SearchProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error)

	SearchProcessInstancesWithResponse(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error)

	// DeleteProcessInstanceAndAllDependantDataByKeyWithResponse request
	DeleteProcessInstanceAndAllDependantDataByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*DeleteProcessInstanceAndAllDependantDataByKeyResponse, error)

	// GetProcessInstanceByKeyWithResponse request
	GetProcessInstanceByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetProcessInstanceByKeyResponse, error)

	// GetSequenceFlowsOfProcessInstanceByKeyWithResponse request
	GetSequenceFlowsOfProcessInstanceByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetSequenceFlowsOfProcessInstanceByKeyResponse, error)

	// GetFlowNodeStatisticByProcessInstanceIdWithResponse request
	GetFlowNodeStatisticByProcessInstanceIdWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetFlowNodeStatisticByProcessInstanceIdResponse, error)

	// SearchVariablesForProcessInstancesWithBodyWithResponse request with any body
	SearchVariablesForProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchVariablesForProcessInstancesResponse, error)

	SearchVariablesForProcessInstancesWithResponse(ctx context.Context, body SearchVariablesForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchVariablesForProcessInstancesResponse, error)

	// GetVariableByKeyWithResponse request
	GetVariableByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetVariableByKeyResponse, error)
}

type SearchDecisionDefinitionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsDecisionDefinition
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SearchDecisionDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDecisionDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionDefinitionByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionDefinition
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetDecisionDefinitionByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionDefinitionByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDecisionInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsDecisionInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SearchDecisionInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDecisionInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionInstanceByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetDecisionInstanceByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionInstanceByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDecisionRequirementsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsDecisionRequirements
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SearchDecisionRequirementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDecisionRequirementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionRequirementsByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *DecisionRequirements
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetDecisionRequirementsByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionRequirementsByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionRequirementsAsXmlByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetDecisionRequirementsAsXmlByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionRequirementsAsXmlByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchFlownodeInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsFlowNodeInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SearchFlownodeInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchFlownodeInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowNodeInstanceByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *FlowNodeInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetFlowNodeInstanceByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowNodeInstanceByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchIncidentsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsIncident
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SearchIncidentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchIncidentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncidentByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Incident
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIncidentByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncidentByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchProcessDefinitionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsProcessDefinition
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SearchProcessDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchProcessDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefinitionByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessDefinition
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetProcessDefinitionByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefinitionByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefinitionAsXmlByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	XML200                    *string
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetProcessDefinitionAsXmlByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefinitionAsXmlByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchProcessInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsProcessInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SearchProcessInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchProcessInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProcessInstanceAndAllDependantDataByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ChangeStatus
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteProcessInstanceAndAllDependantDataByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProcessInstanceAndAllDependantDataByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessInstanceByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstance
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetProcessInstanceByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessInstanceByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSequenceFlowsOfProcessInstanceByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSequenceFlowsOfProcessInstanceByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSequenceFlowsOfProcessInstanceByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowNodeStatisticByProcessInstanceIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]FlowNodeStatistics
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetFlowNodeStatisticByProcessInstanceIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowNodeStatisticByProcessInstanceIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchVariablesForProcessInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ResultsVariable
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SearchVariablesForProcessInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchVariablesForProcessInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Variable
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetVariableByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SearchDecisionDefinitionsWithBodyWithResponse request with arbitrary body returning *SearchDecisionDefinitionsResponse
func (c *ClientWithResponses) SearchDecisionDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error) {
	rsp, err := c.SearchDecisionDefinitionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionDefinitionsResponse(rsp)
}

func (c *ClientWithResponses) SearchDecisionDefinitionsWithResponse(ctx context.Context, body SearchDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionDefinitionsResponse, error) {
	rsp, err := c.SearchDecisionDefinitions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionDefinitionsResponse(rsp)
}

// GetDecisionDefinitionByKeyWithResponse request returning *GetDecisionDefinitionByKeyResponse
func (c *ClientWithResponses) GetDecisionDefinitionByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionByKeyResponse, error) {
	rsp, err := c.GetDecisionDefinitionByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionDefinitionByKeyResponse(rsp)
}

// SearchDecisionInstancesWithBodyWithResponse request with arbitrary body returning *SearchDecisionInstancesResponse
func (c *ClientWithResponses) SearchDecisionInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error) {
	rsp, err := c.SearchDecisionInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchDecisionInstancesWithResponse(ctx context.Context, body SearchDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionInstancesResponse, error) {
	rsp, err := c.SearchDecisionInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionInstancesResponse(rsp)
}

// GetDecisionInstanceByIdWithResponse request returning *GetDecisionInstanceByIdResponse
func (c *ClientWithResponses) GetDecisionInstanceByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDecisionInstanceByIdResponse, error) {
	rsp, err := c.GetDecisionInstanceById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionInstanceByIdResponse(rsp)
}

// SearchDecisionRequirementsWithBodyWithResponse request with arbitrary body returning *SearchDecisionRequirementsResponse
func (c *ClientWithResponses) SearchDecisionRequirementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error) {
	rsp, err := c.SearchDecisionRequirementsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionRequirementsResponse(rsp)
}

func (c *ClientWithResponses) SearchDecisionRequirementsWithResponse(ctx context.Context, body SearchDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDecisionRequirementsResponse, error) {
	rsp, err := c.SearchDecisionRequirements(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDecisionRequirementsResponse(rsp)
}

// GetDecisionRequirementsByKeyWithResponse request returning *GetDecisionRequirementsByKeyResponse
func (c *ClientWithResponses) GetDecisionRequirementsByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsByKeyResponse, error) {
	rsp, err := c.GetDecisionRequirementsByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionRequirementsByKeyResponse(rsp)
}

// GetDecisionRequirementsAsXmlByKeyWithResponse request returning *GetDecisionRequirementsAsXmlByKeyResponse
func (c *ClientWithResponses) GetDecisionRequirementsAsXmlByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsAsXmlByKeyResponse, error) {
	rsp, err := c.GetDecisionRequirementsAsXmlByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionRequirementsAsXmlByKeyResponse(rsp)
}

// SearchFlownodeInstancesWithBodyWithResponse request with arbitrary body returning *SearchFlownodeInstancesResponse
func (c *ClientWithResponses) SearchFlownodeInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchFlownodeInstancesResponse, error) {
	rsp, err := c.SearchFlownodeInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchFlownodeInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchFlownodeInstancesWithResponse(ctx context.Context, body SearchFlownodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchFlownodeInstancesResponse, error) {
	rsp, err := c.SearchFlownodeInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchFlownodeInstancesResponse(rsp)
}

// GetFlowNodeInstanceByKeyWithResponse request returning *GetFlowNodeInstanceByKeyResponse
func (c *ClientWithResponses) GetFlowNodeInstanceByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetFlowNodeInstanceByKeyResponse, error) {
	rsp, err := c.GetFlowNodeInstanceByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowNodeInstanceByKeyResponse(rsp)
}

// SearchIncidentsWithBodyWithResponse request with arbitrary body returning *SearchIncidentsResponse
func (c *ClientWithResponses) SearchIncidentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error) {
	rsp, err := c.SearchIncidentsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchIncidentsResponse(rsp)
}

func (c *ClientWithResponses) SearchIncidentsWithResponse(ctx context.Context, body SearchIncidentsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchIncidentsResponse, error) {
	rsp, err := c.SearchIncidents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchIncidentsResponse(rsp)
}

// GetIncidentByKeyWithResponse request returning *GetIncidentByKeyResponse
func (c *ClientWithResponses) GetIncidentByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetIncidentByKeyResponse, error) {
	rsp, err := c.GetIncidentByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncidentByKeyResponse(rsp)
}

// SearchProcessDefinitionsWithBodyWithResponse request with arbitrary body returning *SearchProcessDefinitionsResponse
func (c *ClientWithResponses) SearchProcessDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error) {
	rsp, err := c.SearchProcessDefinitionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessDefinitionsResponse(rsp)
}

func (c *ClientWithResponses) SearchProcessDefinitionsWithResponse(ctx context.Context, body SearchProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessDefinitionsResponse, error) {
	rsp, err := c.SearchProcessDefinitions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessDefinitionsResponse(rsp)
}

// GetProcessDefinitionByKeyWithResponse request returning *GetProcessDefinitionByKeyResponse
func (c *ClientWithResponses) GetProcessDefinitionByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetProcessDefinitionByKeyResponse, error) {
	rsp, err := c.GetProcessDefinitionByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionByKeyResponse(rsp)
}

// GetProcessDefinitionAsXmlByKeyWithResponse request returning *GetProcessDefinitionAsXmlByKeyResponse
func (c *ClientWithResponses) GetProcessDefinitionAsXmlByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetProcessDefinitionAsXmlByKeyResponse, error) {
	rsp, err := c.GetProcessDefinitionAsXmlByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionAsXmlByKeyResponse(rsp)
}

// SearchProcessInstancesWithBodyWithResponse request with arbitrary body returning *SearchProcessInstancesResponse
func (c *ClientWithResponses) SearchProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error) {
	rsp, err := c.SearchProcessInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchProcessInstancesWithResponse(ctx context.Context, body SearchProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchProcessInstancesResponse, error) {
	rsp, err := c.SearchProcessInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchProcessInstancesResponse(rsp)
}

// DeleteProcessInstanceAndAllDependantDataByKeyWithResponse request returning *DeleteProcessInstanceAndAllDependantDataByKeyResponse
func (c *ClientWithResponses) DeleteProcessInstanceAndAllDependantDataByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*DeleteProcessInstanceAndAllDependantDataByKeyResponse, error) {
	rsp, err := c.DeleteProcessInstanceAndAllDependantDataByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProcessInstanceAndAllDependantDataByKeyResponse(rsp)
}

// GetProcessInstanceByKeyWithResponse request returning *GetProcessInstanceByKeyResponse
func (c *ClientWithResponses) GetProcessInstanceByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetProcessInstanceByKeyResponse, error) {
	rsp, err := c.GetProcessInstanceByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessInstanceByKeyResponse(rsp)
}

// GetSequenceFlowsOfProcessInstanceByKeyWithResponse request returning *GetSequenceFlowsOfProcessInstanceByKeyResponse
func (c *ClientWithResponses) GetSequenceFlowsOfProcessInstanceByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetSequenceFlowsOfProcessInstanceByKeyResponse, error) {
	rsp, err := c.GetSequenceFlowsOfProcessInstanceByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSequenceFlowsOfProcessInstanceByKeyResponse(rsp)
}

// GetFlowNodeStatisticByProcessInstanceIdWithResponse request returning *GetFlowNodeStatisticByProcessInstanceIdResponse
func (c *ClientWithResponses) GetFlowNodeStatisticByProcessInstanceIdWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetFlowNodeStatisticByProcessInstanceIdResponse, error) {
	rsp, err := c.GetFlowNodeStatisticByProcessInstanceId(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowNodeStatisticByProcessInstanceIdResponse(rsp)
}

// SearchVariablesForProcessInstancesWithBodyWithResponse request with arbitrary body returning *SearchVariablesForProcessInstancesResponse
func (c *ClientWithResponses) SearchVariablesForProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchVariablesForProcessInstancesResponse, error) {
	rsp, err := c.SearchVariablesForProcessInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchVariablesForProcessInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchVariablesForProcessInstancesWithResponse(ctx context.Context, body SearchVariablesForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchVariablesForProcessInstancesResponse, error) {
	rsp, err := c.SearchVariablesForProcessInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchVariablesForProcessInstancesResponse(rsp)
}

// GetVariableByKeyWithResponse request returning *GetVariableByKeyResponse
func (c *ClientWithResponses) GetVariableByKeyWithResponse(ctx context.Context, key int64, reqEditors ...RequestEditorFn) (*GetVariableByKeyResponse, error) {
	rsp, err := c.GetVariableByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableByKeyResponse(rsp)
}

// ParseSearchDecisionDefinitionsResponse parses an HTTP response from a SearchDecisionDefinitionsWithResponse call
func ParseSearchDecisionDefinitionsResponse(rsp *http.Response) (*SearchDecisionDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDecisionDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsDecisionDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionDefinitionByKeyResponse parses an HTTP response from a GetDecisionDefinitionByKeyWithResponse call
func ParseGetDecisionDefinitionByKeyResponse(rsp *http.Response) (*GetDecisionDefinitionByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionDefinitionByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchDecisionInstancesResponse parses an HTTP response from a SearchDecisionInstancesWithResponse call
func ParseSearchDecisionInstancesResponse(rsp *http.Response) (*SearchDecisionInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDecisionInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsDecisionInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionInstanceByIdResponse parses an HTTP response from a GetDecisionInstanceByIdWithResponse call
func ParseGetDecisionInstanceByIdResponse(rsp *http.Response) (*GetDecisionInstanceByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionInstanceByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchDecisionRequirementsResponse parses an HTTP response from a SearchDecisionRequirementsWithResponse call
func ParseSearchDecisionRequirementsResponse(rsp *http.Response) (*SearchDecisionRequirementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDecisionRequirementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsDecisionRequirements
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionRequirementsByKeyResponse parses an HTTP response from a GetDecisionRequirementsByKeyWithResponse call
func ParseGetDecisionRequirementsByKeyResponse(rsp *http.Response) (*GetDecisionRequirementsByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionRequirementsByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecisionRequirements
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetDecisionRequirementsAsXmlByKeyResponse parses an HTTP response from a GetDecisionRequirementsAsXmlByKeyWithResponse call
func ParseGetDecisionRequirementsAsXmlByKeyResponse(rsp *http.Response) (*GetDecisionRequirementsAsXmlByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionRequirementsAsXmlByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseSearchFlownodeInstancesResponse parses an HTTP response from a SearchFlownodeInstancesWithResponse call
func ParseSearchFlownodeInstancesResponse(rsp *http.Response) (*SearchFlownodeInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchFlownodeInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsFlowNodeInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetFlowNodeInstanceByKeyResponse parses an HTTP response from a GetFlowNodeInstanceByKeyWithResponse call
func ParseGetFlowNodeInstanceByKeyResponse(rsp *http.Response) (*GetFlowNodeInstanceByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowNodeInstanceByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlowNodeInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchIncidentsResponse parses an HTTP response from a SearchIncidentsWithResponse call
func ParseSearchIncidentsResponse(rsp *http.Response) (*SearchIncidentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchIncidentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsIncident
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIncidentByKeyResponse parses an HTTP response from a GetIncidentByKeyWithResponse call
func ParseGetIncidentByKeyResponse(rsp *http.Response) (*GetIncidentByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncidentByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Incident
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchProcessDefinitionsResponse parses an HTTP response from a SearchProcessDefinitionsWithResponse call
func ParseSearchProcessDefinitionsResponse(rsp *http.Response) (*SearchProcessDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchProcessDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsProcessDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessDefinitionByKeyResponse parses an HTTP response from a GetProcessDefinitionByKeyWithResponse call
func ParseGetProcessDefinitionByKeyResponse(rsp *http.Response) (*GetProcessDefinitionByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefinitionByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessDefinitionAsXmlByKeyResponse parses an HTTP response from a GetProcessDefinitionAsXmlByKeyWithResponse call
func ParseGetProcessDefinitionAsXmlByKeyResponse(rsp *http.Response) (*GetProcessDefinitionAsXmlByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefinitionAsXmlByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseSearchProcessInstancesResponse parses an HTTP response from a SearchProcessInstancesWithResponse call
func ParseSearchProcessInstancesResponse(rsp *http.Response) (*SearchProcessInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchProcessInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsProcessInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProcessInstanceAndAllDependantDataByKeyResponse parses an HTTP response from a DeleteProcessInstanceAndAllDependantDataByKeyWithResponse call
func ParseDeleteProcessInstanceAndAllDependantDataByKeyResponse(rsp *http.Response) (*DeleteProcessInstanceAndAllDependantDataByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProcessInstanceAndAllDependantDataByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChangeStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessInstanceByKeyResponse parses an HTTP response from a GetProcessInstanceByKeyWithResponse call
func ParseGetProcessInstanceByKeyResponse(rsp *http.Response) (*GetProcessInstanceByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessInstanceByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSequenceFlowsOfProcessInstanceByKeyResponse parses an HTTP response from a GetSequenceFlowsOfProcessInstanceByKeyWithResponse call
func ParseGetSequenceFlowsOfProcessInstanceByKeyResponse(rsp *http.Response) (*GetSequenceFlowsOfProcessInstanceByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSequenceFlowsOfProcessInstanceByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetFlowNodeStatisticByProcessInstanceIdResponse parses an HTTP response from a GetFlowNodeStatisticByProcessInstanceIdWithResponse call
func ParseGetFlowNodeStatisticByProcessInstanceIdResponse(rsp *http.Response) (*GetFlowNodeStatisticByProcessInstanceIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowNodeStatisticByProcessInstanceIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FlowNodeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchVariablesForProcessInstancesResponse parses an HTTP response from a SearchVariablesForProcessInstancesWithResponse call
func ParseSearchVariablesForProcessInstancesResponse(rsp *http.Response) (*SearchVariablesForProcessInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchVariablesForProcessInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetVariableByKeyResponse parses an HTTP response from a GetVariableByKeyWithResponse call
func ParseGetVariableByKeyResponse(rsp *http.Response) (*GetVariableByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Variable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xdfXPiOJP/KirfVbH7HAPk/eU/B5xZP0OAB5PM7M2mKGML8I6xWFlOhkvx3a8kv9uy",
	"sSFkgOKvBFuWWq3u1q9bLelN0NBsjixoEVu4fRNsbQpnKvu3OVWtCVSIShz2e47RHGJiQPZLhyYkUKf/",
	"jhGeqUS4FQyLXJ4LVYEs5tD9CScQC8uqMIO2rU4gLe29tAk2rImwXAbF0ehvqBFaugU1wzaQ1YJjwzKI",
	"gSxe+24ZWedUWg1e9+E/joHhjPavRNEvcFGwZ7yvO+oMFm7qCWLb62G0ubNTbnMGvw8/CtNrZdFGoKVa",
	"JINHLyWIzBtR2bKJamkwezzDMV8xXCterxyDAXvxJkDLmQm334WW1JQVudsZDsS7tiRUhbY8kPpieyh9",
	"6/Ulhb4SqsJjR+lJTflellrs15dO92tHeK5mt1NufOGLajoqgbpszR1XJQ0CZ+yf/8ZwLNwK/1UPVbbu",
	"6Ws9yWD2uRAOhYqxuog10HXIRi243+c0QQdTJfxBCIvcq4bpYH6pjYV9jpEGbTuUqS9lP/V7W/xDDG3H",
	"JFzCbeLxw5e5e1FuM0GSnsT2oziICVVc2HgilqOyRZTQlZGUJmZwPdNw0KGEa5LgCdHGNGDHhBkGgb2y",
	"dPizoAau052oPc82bQXmou2Zdwxt5GANdn6J/ZcwRpgzzJHpINVmNmZwNclFJQVGlHiWvsCA3pvotYN0",
	"mD1PQUvPtGpj/2s993XmEBiWZujQihqPEUImVK3o2+KmaLcNpU1UTDJ5mbKVYnMgP9F5udl96LUl11YO",
	"pP6D3GGGs6SBDMXCbyA+tff63aakKEJVUB7vhuEv6UnqDIbxZ8pA7A+G7I1QFeQOpUpqyeJAGjbFQfMP",
	"/qvBH/3u1+DVXfex0xL7fwYPpE4r+F+R+k9yUxoOROWLUBX6UlOSn4Kfj4rU9/9/EDuPYtv/5f2RvjXb",
	"jwr94rM4kL6KfzJS0s96Yl9st6V25JHb3TtRkVqRp4r0n0ep05SG9+3uV9rqY3sgD+WOMhDp07tui5Zq",
	"iu32kA2bPKC/7x4VuSMpyrD/2A6IV5p9uTcIftFe+93KBFd5mkv9FcMmhsYxxKpGjBfommRbw8bcdS2E",
	"wRQCgohqAsuZjSAGaAzcssC3UDZ9RqYQUCUGFtKhUC0i5KwagyxcGUw3a+ipisEYYfA6NbQpe+7iCRuo",
	"GAJ1MsFwQtGbwJF2jRJqQr1YB/3SG3eRYsXAFyzQrl9844Z9g2gXazgozhhcuj2e0MkRgx0XNQ1DBm8H",
	"Roat/xuNtmHI8ybNX2TkM8z4g/y57yHevqR020+u2ZU6Lbnz+b2teYip5e7wQez15M7nodTvd/tCVfh3",
	"927Y6Q770qAvS8zGf5OajwPqC7ZlZSB1pH78fbPbacnsvV+F9G3QF5uDIYXxUvCUGkCpNZTa0gO1ov7j",
	"x84fYqfF3tAngZV/kBRF/CwNFfl/paH0rSlJLUa8V03goPr1hA9c7yH67r7bfxh2uoPhPZ1XCtrQXlJA",
	"0nI9ms8sr5i8+6GIoPRAnRREgL24pK/DgTyImA/xSgA2FUOLJOHql5Lfly3f45qBvKhBkp3vYobKhVTi",
	"H/El4X3QaJOin/b7OOv/cSBeFAmEjg2TQFw0ehOpiXYLqlibimOvgiAOlKImGeKxjf+DBdlvI0wKB5kU",
	"WjjV3kr+ZGtrOe5ExfRQeJMfmyjHn1hdB8Cj1e5+Mf6k6jkA3mRj22I8Cb4/AF4UAEbFmJKu6HC4s6kS",
	"caDCvnPmScWGOjLXZknw/X7zou+GMIqgmaDlUmtScX1KMQBh8qSaTqIFZMHuWLj9noZ7b2nWBI/ceIKw",
	"fOY0xCIOhaBsAS5lq9N6PIrq1WFwKB/ZrMelJMLZb06txjfluMTDOfvNoWyUU44zUbSz3xwpgHXKsYaL",
	"eQ6CR++lVhzks9/8ycY95RgTxT97yhHFg1RJ+AdNfvAQYd0FeEGkSWmyWK/SLBjFzWb+O4Rm118I0NC8",
	"RPH8WD92LE31VpzSUdTiGRwMVmsONshCoSLnRXihiiH+5HHL/XXvk/zvrwOh6qZJsmbZ27ALU0Lm7qIY",
	"+mFAN8dBuPV/+owVuj2pLw6kT0qQWOZL3dygTFouWax4jNhaErKIqjEpcrDpNWLf1uuvr681TZ05lq7W",
	"NDRzs85iy2AIqBodL385U7X0yAKcN5iRhTjDAt05xCpxVyFnyDIIotxjXxKMnJEJ7SlChHK0KpiGBi2b",
	"9dPrWdt7Uk3QqiPNDog1EPtdx3AMMbQ0WPcqsutsfA1iMi55pPSckWloQOzJQiT+L5zUGrUG05k5tNS5",
	"IdwKZ7VG7USoCnOVTNlY1l9O6n7+zSc9mILsuutOMR1BNuMtYq15mYWCwt6nHQxbqAoY/uNAm9whfeGP",
	"jwch1PncNDRWS/1v25074U+VMpyRI5pmerFSNE3g0wgiNILfdDhWHZMA6sIBwwYnjd+FUL6pjNwzP5KN",
	"DjWIIF27V2K0AB7nwsKjBYhkU0YUJ/ROA26fBJ7kRcN3FL8HhkyI1ePZMGa6ls+UTIV2AI0BhsTBFtSB",
	"abhMj9PqMp3PDEq1+zn7mNbG2HIRJdyjcBkxvOVaYHxRbQ1aOpX60QIwuY42key6V4DTaVaXpYO5tyJb",
	"mJRqBh3VKBdorSEXan9ZAwQmkLCVbQv+JKxAFWhovmDPWA/oB5Vw6qwAwyIIVCLBhYpbsPaXxei351Az",
	"xp5MA3uKHFMHM5V42QmRD+NFazGeRWMX31nanA7Z9y3DngpV4fT04uTq5ub65Ozy+vLiokGnOm8sq+tw",
	"3I95lOU4LZ/D8pWCt5pYNpFTapfeLKKuAkFZK0GsCm4HA4vj5v3NEbWstJnTRqOAwSpGVnZQh0eYw6Yh",
	"StB5Lg1zjEYmnP1POVrc9EJOuy2VqMCwXlTT0N3GzxKN/6v+r3do5x7hkaHr0HIbOd9KIx1EwD1yLNaT",
	"i49ko9iTQaR6AL2CIXxiIh8FTt+fKbz2YdD35yXVaGc2U/EiXxMpFlIntm8nErLF1DxzUn/7ARdL2ssJ",
	"5EzpnyFJ13i3oHiLLXCrM0ggtllX4v3/AhdU7TnkClUX4FHAEcK7H6xK7MaSdOGWYAdG1X21J/G8Rc3d",
	"bZWVXW0FHsj6hVq7xU723c5B2k03LxtYiIDxYWj3Z0h4ukKnVFczSil44J2UxOy+j7ptxB56T++M1xM7",
	"iErh9tTuo1+C30PWbAe9x+tPY+bYZrA8DJ8ouDGWDwirrqDqQBC9bL0gQ4Ogaaq2HXxRGtgXH4ZiAD85",
	"DHF4nzkO68D8DNI3hPthSHinwH4uWUeof4T6OVDfiEzLSRwQyFUeCngz9EIY36/sbsEmtVyAL+sxfB/s",
	"S+Oie0PPBffJqPNHQPldVMgjkD8sIO8rBZ06mQoU0F6slwTtsfyL7eJ2HGnqI0PtiW3A7xJ2T9X5bhA+",
	"xqXtoPhUE78wCB+l5cCj8D5mv3Nsw4K2DXwdtH9ZQJ7D/Z2PyMczxnYKpq8k7QjVj1A9B6rj+GScnO9j",
	"4hWb8wvH4aNVrBWJT5C4t7H4XVXVI4g/LBAfw1qZ8fgVml3/OTPLardof5uZe6ziBP4kfr+zff2j3h71",
	"dvt6q9rg20O7rPqOTfRqIR2WXlC79z7c4oJan6F5G6imCXw6eQtrUdQf8dRr+a56nqde8XfkV4DrcUA9",
	"4XNUgq3hlRrfWw839VPLs+S4HOHuco7fUY2QEyQG8/nD4Y1LBtTjnSlGadi27+tmOsqlKQjZqWZwM2hN",
	"B2OMZmCO4YuBHDvuGrt+cFHGx1zck8vzy5vGeeP64vzmpnrTaFyd3NycXpxfnZ+dXl8/Fxyn0JvtUV/f",
	"07pMBrkdGi0AdasnYaeCuEu6d+A3lmz+ew00pwjZEKgWgD8Nm9AKfsBFgj1uJ6ENCAIELwCZGnaOox91",
	"5a+uri9YV1xqwWkDBJnz/O7M1J+slH94Ti3tY582Ald/LQnma513ikYlN+zjH7WxsTef3tmU6cmn7ehH",
	"+PSFCDz680d/Pu3PcwQ2xAzJyT0XL6z065NSWgbwpyzDPvrzu6ymR5/gIHyC8KDA6Ipc3BPI1upgIi8I",
	"/uXgkL2tgv7wcL5tYn1qClzYWeGdQlXJ8gCip/llQWv+sVbxhZSTy6vQIHFPh+M5D7GzBDfzHyJnIEZB",
	"O+NLDdzTj0HFO0OwAjTVqhAwgsCxKUZH2PsqZDaXE17/+MfcreNz5FG96Whu7oS838Bv6LyslpOtOzD7",
	"4oWEElVARHI9kFVML+eGhMcIZLof4amnH+B15NJz9DaO3kba2zAigMGHI4EYcWDISp/C/7iMLxEEhvbQ",
	"hdhFnTu6DgfhOvhqkXYY0hrqwZo1Ns2nDnzZUiZf+viCD8jiix//u1HyXrKqTXP20vx413w9fvU+X7ad",
	"oZdqvRptOfg+OC4/TMkDf1mAl5T3q3LyclLymqppQh14QpFIw7s6vT7ZahpemsVZKXgRpxyNPzbtjnOa",
	"1E7k3BWj6wiZj5A5DZl9xePvgk9LVu4cvRJPp+orA6zTpO4jxN5pZT1i7YPA2mlNSaPudVR7VfJdqs7S",
	"mXe7pOPHtLuj7u6E7mbl3BVQ4bL5donjQLe88pbjRWeswHE9aqgH7iDU8wP5Fw2eqxFd2olf2UJt0ik3",
	"mayAM568MuZ0Y5/coyNYNno1yDTDsYr2+oznQDPvsDIyJk8q9pp1V6R+wAW4vLq4OLu5OT8/aVxcXF81",
	"VrMA8Lef7aCnG+uyUE12NXBzzzYZo9XrQOkhKSVmpUlby9ctkJOW6scHurzHjLSjw7umw8tLSEtKVc50",
	"Gri6OjShez9XfD5tseeJGkVLF02zBefQ0lWLUFFZBx3vc5Zac6paE3ZVqnPcbXaEz++p4a7KpbSEgRqV",
	"Hb/g6R3QqY3OwtMR9a+ucnXXSTY9BC3e4fn3qMgH5QdnJ5qWna3rNmWapcFPYxO92nmBLMUreU8LdscH",
	"oewpkU9e45W80Di4Vuuo2kfVfk/V9vWQpZPbPC15D2WPXca/atNIcHX/XdLzXX2A255N66Vu21JCLha3",
	"CzXgxzjCQQguvp8YL9BKMasKJhg5cy9w4u8yOFqYo4XZcJ9KIIGR2G5oZmJnyWWamBfvVqOiQXT/FiT7",
	"HuGPDagHlK4XSM/ZycJvhcWfK+mLmSqgEt01cHJyc1nhhjeTqVup4HnstichWSl3z0pmKlJPnVCAk9k3",
	"FrQOO0ctFrdv8U3ltLlKDfzWRPNFRpCbUebOEcGGBhbG/B1s2vl4aNueqaYpxHZsnJw2Gs+lErZylxNO",
	"GxEO8XdClAs0h/esZUaYgwY/IrKcS88xpHwMKadDynGTkRdgDoSLM7esTJ7yPy7jfvrV72OMaRc18YgP",
	"DwIf+mqR9jOjGsrawC++grmXCr65FC9v6/W3KbLJ8vZtjjBZsrnQn6du34Qp8tPlGQ4TbgUTaarJHqfu",
	"SpxCQF+w/GY0Zn4S7bfbeo1dfhmgMr+668Z1g1sTLZpRSzgWYT3s2khePW5hbk1M8T2WJS2Ph3hBmJbi",
	"3Z7oGR3enbzJOvzTpDIr4d6+nlmLj6P4dUTuvk3tx/DPheDXkNrqnq7Bl6f4h5HLZbPYx28xfV1vZqej",
	"J3HxO564cDx1ML2/Yyf2cbhF7Hn5/wEAAP//yxdz3cKdAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
