// Package c87operatev1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package c87operatev1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for SortOrder.
const (
	ASC  SortOrder = "ASC"
	DESC SortOrder = "DESC"
)

// Problem defines model for Problem.
type Problem struct {
	Instance *string `json:"instance,omitempty"`
	Message  *string `json:"message,omitempty"`
	Status   *int32  `json:"status,omitempty"`
	Type     *string `json:"type,omitempty"`
}

// ProcessDefinitionFilter defines model for ProcessDefinitionFilter.
type ProcessDefinitionFilter struct {
	BpmnProcessId *string `json:"bpmnProcessId,omitempty"`
	Key           *int64  `json:"key,omitempty"`
	Name          *string `json:"name,omitempty"`
	TenantId      *string `json:"tenantId,omitempty"`
	Version       *int32  `json:"version,omitempty"`
	VersionTag    *string `json:"versionTag,omitempty"`
}

// ProcessDefinitionItem defines model for ProcessDefinitionItem.
type ProcessDefinitionItem struct {
	BpmnProcessId *string `json:"bpmnProcessId,omitempty"`
	Key           *int64  `json:"key,omitempty"`
	Name          *string `json:"name,omitempty"`
	TenantId      *string `json:"tenantId,omitempty"`
	Version       *int32  `json:"version,omitempty"`
	VersionTag    *string `json:"versionTag,omitempty"`
}

// ProcessDefinitionSearchRequest defines model for ProcessDefinitionSearchRequest.
type ProcessDefinitionSearchRequest struct {
	Filter      *ProcessDefinitionFilter `json:"filter,omitempty"`
	SearchAfter *[]interface{}           `json:"searchAfter,omitempty"`
	Size        *int32                   `json:"size,omitempty"`
	Sort        *[]SortInstruction       `json:"sort,omitempty"`
}

// ProcessDefinitionSearchResponse defines model for ProcessDefinitionSearchResponse.
type ProcessDefinitionSearchResponse struct {
	Items      *[]ProcessDefinitionItem `json:"items,omitempty"`
	SortValues *[]interface{}           `json:"sortValues,omitempty"`
	Total      *int64                   `json:"total,omitempty"`
}

// ProcessInstanceDeleteResponse defines model for ProcessInstanceDeleteResponse.
type ProcessInstanceDeleteResponse struct {
	Deleted int64  `json:"deleted"`
	Message string `json:"message"`
}

// SortInstruction defines model for SortInstruction.
type SortInstruction struct {
	Field *string    `json:"field,omitempty"`
	Order *SortOrder `json:"order,omitempty"`
}

// SortOrder defines model for SortOrder.
type SortOrder string

// SearchForDecisionDefinitionsJSONBody defines parameters for SearchForDecisionDefinitions.
type SearchForDecisionDefinitionsJSONBody = map[string]interface{}

// SearchForDecisionInstancesJSONBody defines parameters for SearchForDecisionInstances.
type SearchForDecisionInstancesJSONBody = map[string]interface{}

// SearchForDecisionRequirementsJSONBody defines parameters for SearchForDecisionRequirements.
type SearchForDecisionRequirementsJSONBody = map[string]interface{}

// SearchForFlowNodeInstancesJSONBody defines parameters for SearchForFlowNodeInstances.
type SearchForFlowNodeInstancesJSONBody = map[string]interface{}

// SearchForProcessInstancesJSONBody defines parameters for SearchForProcessInstances.
type SearchForProcessInstancesJSONBody = map[string]interface{}

// SearchForVariablesJSONBody defines parameters for SearchForVariables.
type SearchForVariablesJSONBody = map[string]interface{}

// SearchForDecisionDefinitionsJSONRequestBody defines body for SearchForDecisionDefinitions for application/json ContentType.
type SearchForDecisionDefinitionsJSONRequestBody = SearchForDecisionDefinitionsJSONBody

// SearchForDecisionInstancesJSONRequestBody defines body for SearchForDecisionInstances for application/json ContentType.
type SearchForDecisionInstancesJSONRequestBody = SearchForDecisionInstancesJSONBody

// SearchForDecisionRequirementsJSONRequestBody defines body for SearchForDecisionRequirements for application/json ContentType.
type SearchForDecisionRequirementsJSONRequestBody = SearchForDecisionRequirementsJSONBody

// SearchForFlowNodeInstancesJSONRequestBody defines body for SearchForFlowNodeInstances for application/json ContentType.
type SearchForFlowNodeInstancesJSONRequestBody = SearchForFlowNodeInstancesJSONBody

// SearchForProcessDefinitionsJSONRequestBody defines body for SearchForProcessDefinitions for application/json ContentType.
type SearchForProcessDefinitionsJSONRequestBody = ProcessDefinitionSearchRequest

// SearchForProcessInstancesJSONRequestBody defines body for SearchForProcessInstances for application/json ContentType.
type SearchForProcessInstancesJSONRequestBody = SearchForProcessInstancesJSONBody

// SearchForVariablesJSONRequestBody defines body for SearchForVariables for application/json ContentType.
type SearchForVariablesJSONRequestBody = SearchForVariablesJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SearchForDecisionDefinitionsWithBody request with any body
	SearchForDecisionDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForDecisionDefinitions(ctx context.Context, body SearchForDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionDefinitionByKey request
	GetDecisionDefinitionByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForDecisionInstancesWithBody request with any body
	SearchForDecisionInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForDecisionInstances(ctx context.Context, body SearchForDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionInstanceByKey request
	GetDecisionInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForDecisionRequirementsWithBody request with any body
	SearchForDecisionRequirementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForDecisionRequirements(ctx context.Context, body SearchForDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionRequirementsByKey request
	GetDecisionRequirementsByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDecisionRequirementsByKeyAsXml request
	GetDecisionRequirementsByKeyAsXml(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForFlowNodeInstancesWithBody request with any body
	SearchForFlowNodeInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForFlowNodeInstances(ctx context.Context, body SearchForFlowNodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowNodeInstanceByKey request
	GetFlowNodeInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForIncidents request
	SearchForIncidents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncidentByKey request
	GetIncidentByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForProcessDefinitionsWithBody request with any body
	SearchForProcessDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForProcessDefinitions(ctx context.Context, body SearchForProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefinitionByKey request
	GetProcessDefinitionByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessDefintionByKeyAsXml request
	GetProcessDefintionByKeyAsXml(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForProcessInstancesWithBody request with any body
	SearchForProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForProcessInstances(ctx context.Context, body SearchForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProcessInstanceAndDependantDataByKey request
	DeleteProcessInstanceAndDependantDataByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProcessInstanceByKey request
	GetProcessInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchForVariablesWithBody request with any body
	SearchForVariablesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchForVariables(ctx context.Context, body SearchForVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariableByKey request
	GetVariableByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SearchForDecisionDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionDefinitionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForDecisionDefinitions(ctx context.Context, body SearchForDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionDefinitionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionDefinitionByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionDefinitionByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForDecisionInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForDecisionInstances(ctx context.Context, body SearchForDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionInstanceByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForDecisionRequirementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionRequirementsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForDecisionRequirements(ctx context.Context, body SearchForDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForDecisionRequirementsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionRequirementsByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionRequirementsByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDecisionRequirementsByKeyAsXml(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDecisionRequirementsByKeyAsXmlRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForFlowNodeInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForFlowNodeInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForFlowNodeInstances(ctx context.Context, body SearchForFlowNodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForFlowNodeInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowNodeInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowNodeInstanceByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForIncidents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForIncidentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncidentByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncidentByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForProcessDefinitionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForProcessDefinitionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForProcessDefinitions(ctx context.Context, body SearchForProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForProcessDefinitionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefinitionByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefinitionByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessDefintionByKeyAsXml(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessDefintionByKeyAsXmlRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForProcessInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForProcessInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForProcessInstances(ctx context.Context, body SearchForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForProcessInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProcessInstanceAndDependantDataByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProcessInstanceAndDependantDataByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProcessInstanceByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProcessInstanceByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForVariablesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForVariablesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchForVariables(ctx context.Context, body SearchForVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchForVariablesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariableByKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableByKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSearchForDecisionDefinitionsRequest calls the generic SearchForDecisionDefinitions builder with application/json body
func NewSearchForDecisionDefinitionsRequest(server string, body SearchForDecisionDefinitionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForDecisionDefinitionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForDecisionDefinitionsRequestWithBody generates requests for SearchForDecisionDefinitions with any type of body
func NewSearchForDecisionDefinitionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionDefinitionByKeyRequest generates requests for GetDecisionDefinitionByKey
func NewGetDecisionDefinitionByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForDecisionInstancesRequest calls the generic SearchForDecisionInstances builder with application/json body
func NewSearchForDecisionInstancesRequest(server string, body SearchForDecisionInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForDecisionInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForDecisionInstancesRequestWithBody generates requests for SearchForDecisionInstances with any type of body
func NewSearchForDecisionInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionInstanceByKeyRequest generates requests for GetDecisionInstanceByKey
func NewGetDecisionInstanceByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/decision-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForDecisionRequirementsRequest calls the generic SearchForDecisionRequirements builder with application/json body
func NewSearchForDecisionRequirementsRequest(server string, body SearchForDecisionRequirementsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForDecisionRequirementsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForDecisionRequirementsRequestWithBody generates requests for SearchForDecisionRequirements with any type of body
func NewSearchForDecisionRequirementsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/drd/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDecisionRequirementsByKeyRequest generates requests for GetDecisionRequirementsByKey
func NewGetDecisionRequirementsByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/drd/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDecisionRequirementsByKeyAsXmlRequest generates requests for GetDecisionRequirementsByKeyAsXml
func NewGetDecisionRequirementsByKeyAsXmlRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/drd/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForFlowNodeInstancesRequest calls the generic SearchForFlowNodeInstances builder with application/json body
func NewSearchForFlowNodeInstancesRequest(server string, body SearchForFlowNodeInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForFlowNodeInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForFlowNodeInstancesRequestWithBody generates requests for SearchForFlowNodeInstances with any type of body
func NewSearchForFlowNodeInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flownode-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFlowNodeInstanceByKeyRequest generates requests for GetFlowNodeInstanceByKey
func NewGetFlowNodeInstanceByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flownode-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForIncidentsRequest generates requests for SearchForIncidents
func NewSearchForIncidentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIncidentByKeyRequest generates requests for GetIncidentByKey
func NewGetIncidentByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForProcessDefinitionsRequest calls the generic SearchForProcessDefinitions builder with application/json body
func NewSearchForProcessDefinitionsRequest(server string, body SearchForProcessDefinitionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForProcessDefinitionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForProcessDefinitionsRequestWithBody generates requests for SearchForProcessDefinitions with any type of body
func NewSearchForProcessDefinitionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProcessDefinitionByKeyRequest generates requests for GetProcessDefinitionByKey
func NewGetProcessDefinitionByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessDefintionByKeyAsXmlRequest generates requests for GetProcessDefintionByKeyAsXml
func NewGetProcessDefintionByKeyAsXmlRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-definitions/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForProcessInstancesRequest calls the generic SearchForProcessInstances builder with application/json body
func NewSearchForProcessInstancesRequest(server string, body SearchForProcessInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForProcessInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForProcessInstancesRequestWithBody generates requests for SearchForProcessInstances with any type of body
func NewSearchForProcessInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProcessInstanceAndDependantDataByKeyRequest generates requests for DeleteProcessInstanceAndDependantDataByKey
func NewDeleteProcessInstanceAndDependantDataByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProcessInstanceByKeyRequest generates requests for GetProcessInstanceByKey
func NewGetProcessInstanceByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchForVariablesRequest calls the generic SearchForVariables builder with application/json body
func NewSearchForVariablesRequest(server string, body SearchForVariablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchForVariablesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchForVariablesRequestWithBody generates requests for SearchForVariables with any type of body
func NewSearchForVariablesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVariableByKeyRequest generates requests for GetVariableByKey
func NewGetVariableByKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/variables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SearchForDecisionDefinitionsWithBodyWithResponse request with any body
	SearchForDecisionDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionDefinitionsResponse, error)

	SearchForDecisionDefinitionsWithResponse(ctx context.Context, body SearchForDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionDefinitionsResponse, error)

	// GetDecisionDefinitionByKeyWithResponse request
	GetDecisionDefinitionByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionByKeyResponse, error)

	// SearchForDecisionInstancesWithBodyWithResponse request with any body
	SearchForDecisionInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionInstancesResponse, error)

	SearchForDecisionInstancesWithResponse(ctx context.Context, body SearchForDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionInstancesResponse, error)

	// GetDecisionInstanceByKeyWithResponse request
	GetDecisionInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionInstanceByKeyResponse, error)

	// SearchForDecisionRequirementsWithBodyWithResponse request with any body
	SearchForDecisionRequirementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionRequirementsResponse, error)

	SearchForDecisionRequirementsWithResponse(ctx context.Context, body SearchForDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionRequirementsResponse, error)

	// GetDecisionRequirementsByKeyWithResponse request
	GetDecisionRequirementsByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsByKeyResponse, error)

	// GetDecisionRequirementsByKeyAsXmlWithResponse request
	GetDecisionRequirementsByKeyAsXmlWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsByKeyAsXmlResponse, error)

	// SearchForFlowNodeInstancesWithBodyWithResponse request with any body
	SearchForFlowNodeInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForFlowNodeInstancesResponse, error)

	SearchForFlowNodeInstancesWithResponse(ctx context.Context, body SearchForFlowNodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForFlowNodeInstancesResponse, error)

	// GetFlowNodeInstanceByKeyWithResponse request
	GetFlowNodeInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetFlowNodeInstanceByKeyResponse, error)

	// SearchForIncidentsWithResponse request
	SearchForIncidentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchForIncidentsResponse, error)

	// GetIncidentByKeyWithResponse request
	GetIncidentByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetIncidentByKeyResponse, error)

	// SearchForProcessDefinitionsWithBodyWithResponse request with any body
	SearchForProcessDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForProcessDefinitionsResponse, error)

	SearchForProcessDefinitionsWithResponse(ctx context.Context, body SearchForProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForProcessDefinitionsResponse, error)

	// GetProcessDefinitionByKeyWithResponse request
	GetProcessDefinitionByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionByKeyResponse, error)

	// GetProcessDefintionByKeyAsXmlWithResponse request
	GetProcessDefintionByKeyAsXmlWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessDefintionByKeyAsXmlResponse, error)

	// SearchForProcessInstancesWithBodyWithResponse request with any body
	SearchForProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForProcessInstancesResponse, error)

	SearchForProcessInstancesWithResponse(ctx context.Context, body SearchForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForProcessInstancesResponse, error)

	// DeleteProcessInstanceAndDependantDataByKeyWithResponse request
	DeleteProcessInstanceAndDependantDataByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*DeleteProcessInstanceAndDependantDataByKeyResponse, error)

	// GetProcessInstanceByKeyWithResponse request
	GetProcessInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessInstanceByKeyResponse, error)

	// SearchForVariablesWithBodyWithResponse request with any body
	SearchForVariablesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForVariablesResponse, error)

	SearchForVariablesWithResponse(ctx context.Context, body SearchForVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForVariablesResponse, error)

	// GetVariableByKeyWithResponse request
	GetVariableByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetVariableByKeyResponse, error)
}

type SearchForDecisionDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForDecisionDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForDecisionDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionDefinitionByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDecisionDefinitionByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionDefinitionByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForDecisionInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForDecisionInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForDecisionInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionInstanceByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDecisionInstanceByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionInstanceByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForDecisionRequirementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForDecisionRequirementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForDecisionRequirementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionRequirementsByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDecisionRequirementsByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionRequirementsByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDecisionRequirementsByKeyAsXmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDecisionRequirementsByKeyAsXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDecisionRequirementsByKeyAsXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForFlowNodeInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForFlowNodeInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForFlowNodeInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowNodeInstanceByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFlowNodeInstanceByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowNodeInstanceByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForIncidentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForIncidentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForIncidentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncidentByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIncidentByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncidentByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForProcessDefinitionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessDefinitionSearchResponse
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r SearchForProcessDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForProcessDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefinitionByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProcessDefinitionByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefinitionByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessDefintionByKeyAsXmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProcessDefintionByKeyAsXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessDefintionByKeyAsXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForProcessInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForProcessInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForProcessInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProcessInstanceAndDependantDataByKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ProcessInstanceDeleteResponse
	ApplicationproblemJSON400 *Problem
	ApplicationproblemJSON403 *Problem
	ApplicationproblemJSON404 *Problem
	ApplicationproblemJSON500 *Problem
}

// Status returns HTTPResponse.Status
func (r DeleteProcessInstanceAndDependantDataByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProcessInstanceAndDependantDataByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProcessInstanceByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetProcessInstanceByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProcessInstanceByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchForVariablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchForVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchForVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetVariableByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SearchForDecisionDefinitionsWithBodyWithResponse request with arbitrary body returning *SearchForDecisionDefinitionsResponse
func (c *ClientWithResponses) SearchForDecisionDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionDefinitionsResponse, error) {
	rsp, err := c.SearchForDecisionDefinitionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionDefinitionsResponse(rsp)
}

func (c *ClientWithResponses) SearchForDecisionDefinitionsWithResponse(ctx context.Context, body SearchForDecisionDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionDefinitionsResponse, error) {
	rsp, err := c.SearchForDecisionDefinitions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionDefinitionsResponse(rsp)
}

// GetDecisionDefinitionByKeyWithResponse request returning *GetDecisionDefinitionByKeyResponse
func (c *ClientWithResponses) GetDecisionDefinitionByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionDefinitionByKeyResponse, error) {
	rsp, err := c.GetDecisionDefinitionByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionDefinitionByKeyResponse(rsp)
}

// SearchForDecisionInstancesWithBodyWithResponse request with arbitrary body returning *SearchForDecisionInstancesResponse
func (c *ClientWithResponses) SearchForDecisionInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionInstancesResponse, error) {
	rsp, err := c.SearchForDecisionInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchForDecisionInstancesWithResponse(ctx context.Context, body SearchForDecisionInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionInstancesResponse, error) {
	rsp, err := c.SearchForDecisionInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionInstancesResponse(rsp)
}

// GetDecisionInstanceByKeyWithResponse request returning *GetDecisionInstanceByKeyResponse
func (c *ClientWithResponses) GetDecisionInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionInstanceByKeyResponse, error) {
	rsp, err := c.GetDecisionInstanceByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionInstanceByKeyResponse(rsp)
}

// SearchForDecisionRequirementsWithBodyWithResponse request with arbitrary body returning *SearchForDecisionRequirementsResponse
func (c *ClientWithResponses) SearchForDecisionRequirementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForDecisionRequirementsResponse, error) {
	rsp, err := c.SearchForDecisionRequirementsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionRequirementsResponse(rsp)
}

func (c *ClientWithResponses) SearchForDecisionRequirementsWithResponse(ctx context.Context, body SearchForDecisionRequirementsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForDecisionRequirementsResponse, error) {
	rsp, err := c.SearchForDecisionRequirements(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForDecisionRequirementsResponse(rsp)
}

// GetDecisionRequirementsByKeyWithResponse request returning *GetDecisionRequirementsByKeyResponse
func (c *ClientWithResponses) GetDecisionRequirementsByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsByKeyResponse, error) {
	rsp, err := c.GetDecisionRequirementsByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionRequirementsByKeyResponse(rsp)
}

// GetDecisionRequirementsByKeyAsXmlWithResponse request returning *GetDecisionRequirementsByKeyAsXmlResponse
func (c *ClientWithResponses) GetDecisionRequirementsByKeyAsXmlWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetDecisionRequirementsByKeyAsXmlResponse, error) {
	rsp, err := c.GetDecisionRequirementsByKeyAsXml(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDecisionRequirementsByKeyAsXmlResponse(rsp)
}

// SearchForFlowNodeInstancesWithBodyWithResponse request with arbitrary body returning *SearchForFlowNodeInstancesResponse
func (c *ClientWithResponses) SearchForFlowNodeInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForFlowNodeInstancesResponse, error) {
	rsp, err := c.SearchForFlowNodeInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForFlowNodeInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchForFlowNodeInstancesWithResponse(ctx context.Context, body SearchForFlowNodeInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForFlowNodeInstancesResponse, error) {
	rsp, err := c.SearchForFlowNodeInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForFlowNodeInstancesResponse(rsp)
}

// GetFlowNodeInstanceByKeyWithResponse request returning *GetFlowNodeInstanceByKeyResponse
func (c *ClientWithResponses) GetFlowNodeInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetFlowNodeInstanceByKeyResponse, error) {
	rsp, err := c.GetFlowNodeInstanceByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowNodeInstanceByKeyResponse(rsp)
}

// SearchForIncidentsWithResponse request returning *SearchForIncidentsResponse
func (c *ClientWithResponses) SearchForIncidentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchForIncidentsResponse, error) {
	rsp, err := c.SearchForIncidents(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForIncidentsResponse(rsp)
}

// GetIncidentByKeyWithResponse request returning *GetIncidentByKeyResponse
func (c *ClientWithResponses) GetIncidentByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetIncidentByKeyResponse, error) {
	rsp, err := c.GetIncidentByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncidentByKeyResponse(rsp)
}

// SearchForProcessDefinitionsWithBodyWithResponse request with arbitrary body returning *SearchForProcessDefinitionsResponse
func (c *ClientWithResponses) SearchForProcessDefinitionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForProcessDefinitionsResponse, error) {
	rsp, err := c.SearchForProcessDefinitionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForProcessDefinitionsResponse(rsp)
}

func (c *ClientWithResponses) SearchForProcessDefinitionsWithResponse(ctx context.Context, body SearchForProcessDefinitionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForProcessDefinitionsResponse, error) {
	rsp, err := c.SearchForProcessDefinitions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForProcessDefinitionsResponse(rsp)
}

// GetProcessDefinitionByKeyWithResponse request returning *GetProcessDefinitionByKeyResponse
func (c *ClientWithResponses) GetProcessDefinitionByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessDefinitionByKeyResponse, error) {
	rsp, err := c.GetProcessDefinitionByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefinitionByKeyResponse(rsp)
}

// GetProcessDefintionByKeyAsXmlWithResponse request returning *GetProcessDefintionByKeyAsXmlResponse
func (c *ClientWithResponses) GetProcessDefintionByKeyAsXmlWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessDefintionByKeyAsXmlResponse, error) {
	rsp, err := c.GetProcessDefintionByKeyAsXml(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessDefintionByKeyAsXmlResponse(rsp)
}

// SearchForProcessInstancesWithBodyWithResponse request with arbitrary body returning *SearchForProcessInstancesResponse
func (c *ClientWithResponses) SearchForProcessInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForProcessInstancesResponse, error) {
	rsp, err := c.SearchForProcessInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForProcessInstancesResponse(rsp)
}

func (c *ClientWithResponses) SearchForProcessInstancesWithResponse(ctx context.Context, body SearchForProcessInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForProcessInstancesResponse, error) {
	rsp, err := c.SearchForProcessInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForProcessInstancesResponse(rsp)
}

// DeleteProcessInstanceAndDependantDataByKeyWithResponse request returning *DeleteProcessInstanceAndDependantDataByKeyResponse
func (c *ClientWithResponses) DeleteProcessInstanceAndDependantDataByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*DeleteProcessInstanceAndDependantDataByKeyResponse, error) {
	rsp, err := c.DeleteProcessInstanceAndDependantDataByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProcessInstanceAndDependantDataByKeyResponse(rsp)
}

// GetProcessInstanceByKeyWithResponse request returning *GetProcessInstanceByKeyResponse
func (c *ClientWithResponses) GetProcessInstanceByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetProcessInstanceByKeyResponse, error) {
	rsp, err := c.GetProcessInstanceByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProcessInstanceByKeyResponse(rsp)
}

// SearchForVariablesWithBodyWithResponse request with arbitrary body returning *SearchForVariablesResponse
func (c *ClientWithResponses) SearchForVariablesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchForVariablesResponse, error) {
	rsp, err := c.SearchForVariablesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForVariablesResponse(rsp)
}

func (c *ClientWithResponses) SearchForVariablesWithResponse(ctx context.Context, body SearchForVariablesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchForVariablesResponse, error) {
	rsp, err := c.SearchForVariables(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchForVariablesResponse(rsp)
}

// GetVariableByKeyWithResponse request returning *GetVariableByKeyResponse
func (c *ClientWithResponses) GetVariableByKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetVariableByKeyResponse, error) {
	rsp, err := c.GetVariableByKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableByKeyResponse(rsp)
}

// ParseSearchForDecisionDefinitionsResponse parses an HTTP response from a SearchForDecisionDefinitionsWithResponse call
func ParseSearchForDecisionDefinitionsResponse(rsp *http.Response) (*SearchForDecisionDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForDecisionDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDecisionDefinitionByKeyResponse parses an HTTP response from a GetDecisionDefinitionByKeyWithResponse call
func ParseGetDecisionDefinitionByKeyResponse(rsp *http.Response) (*GetDecisionDefinitionByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionDefinitionByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForDecisionInstancesResponse parses an HTTP response from a SearchForDecisionInstancesWithResponse call
func ParseSearchForDecisionInstancesResponse(rsp *http.Response) (*SearchForDecisionInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForDecisionInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDecisionInstanceByKeyResponse parses an HTTP response from a GetDecisionInstanceByKeyWithResponse call
func ParseGetDecisionInstanceByKeyResponse(rsp *http.Response) (*GetDecisionInstanceByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionInstanceByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForDecisionRequirementsResponse parses an HTTP response from a SearchForDecisionRequirementsWithResponse call
func ParseSearchForDecisionRequirementsResponse(rsp *http.Response) (*SearchForDecisionRequirementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForDecisionRequirementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDecisionRequirementsByKeyResponse parses an HTTP response from a GetDecisionRequirementsByKeyWithResponse call
func ParseGetDecisionRequirementsByKeyResponse(rsp *http.Response) (*GetDecisionRequirementsByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionRequirementsByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDecisionRequirementsByKeyAsXmlResponse parses an HTTP response from a GetDecisionRequirementsByKeyAsXmlWithResponse call
func ParseGetDecisionRequirementsByKeyAsXmlResponse(rsp *http.Response) (*GetDecisionRequirementsByKeyAsXmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDecisionRequirementsByKeyAsXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForFlowNodeInstancesResponse parses an HTTP response from a SearchForFlowNodeInstancesWithResponse call
func ParseSearchForFlowNodeInstancesResponse(rsp *http.Response) (*SearchForFlowNodeInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForFlowNodeInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFlowNodeInstanceByKeyResponse parses an HTTP response from a GetFlowNodeInstanceByKeyWithResponse call
func ParseGetFlowNodeInstanceByKeyResponse(rsp *http.Response) (*GetFlowNodeInstanceByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowNodeInstanceByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForIncidentsResponse parses an HTTP response from a SearchForIncidentsWithResponse call
func ParseSearchForIncidentsResponse(rsp *http.Response) (*SearchForIncidentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForIncidentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIncidentByKeyResponse parses an HTTP response from a GetIncidentByKeyWithResponse call
func ParseGetIncidentByKeyResponse(rsp *http.Response) (*GetIncidentByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncidentByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForProcessDefinitionsResponse parses an HTTP response from a SearchForProcessDefinitionsWithResponse call
func ParseSearchForProcessDefinitionsResponse(rsp *http.Response) (*SearchForProcessDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForProcessDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessDefinitionSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.StatusCode == 200:
	// Content-type (text/plain) unsupported

	case rsp.StatusCode == 403:
	// Content-type (*/*) unsupported

	case rsp.StatusCode == 404:
		// Content-type (*/*) unsupported

	}

	return response, nil
}

// ParseGetProcessDefinitionByKeyResponse parses an HTTP response from a GetProcessDefinitionByKeyWithResponse call
func ParseGetProcessDefinitionByKeyResponse(rsp *http.Response) (*GetProcessDefinitionByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefinitionByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProcessDefintionByKeyAsXmlResponse parses an HTTP response from a GetProcessDefintionByKeyAsXmlWithResponse call
func ParseGetProcessDefintionByKeyAsXmlResponse(rsp *http.Response) (*GetProcessDefintionByKeyAsXmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessDefintionByKeyAsXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForProcessInstancesResponse parses an HTTP response from a SearchForProcessInstancesWithResponse call
func ParseSearchForProcessInstancesResponse(rsp *http.Response) (*SearchForProcessInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForProcessInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteProcessInstanceAndDependantDataByKeyResponse parses an HTTP response from a DeleteProcessInstanceAndDependantDataByKeyWithResponse call
func ParseDeleteProcessInstanceAndDependantDataByKeyResponse(rsp *http.Response) (*DeleteProcessInstanceAndDependantDataByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProcessInstanceAndDependantDataByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInstanceDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetProcessInstanceByKeyResponse parses an HTTP response from a GetProcessInstanceByKeyWithResponse call
func ParseGetProcessInstanceByKeyResponse(rsp *http.Response) (*GetProcessInstanceByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProcessInstanceByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchForVariablesResponse parses an HTTP response from a SearchForVariablesWithResponse call
func ParseSearchForVariablesResponse(rsp *http.Response) (*SearchForVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchForVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVariableByKeyResponse parses an HTTP response from a GetVariableByKeyWithResponse call
func ParseGetVariableByKeyResponse(rsp *http.Response) (*GetVariableByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
