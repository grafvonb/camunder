// Package xsrf provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package xsrf

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AuthPropType.
const (
	Checkbox    AuthPropType = 4
	Edit        AuthPropType = 1
	Hidden      AuthPropType = 3
	Info        AuthPropType = 0
	NewPassword AuthPropType = 6
	OAuth2Code  AuthPropType = 5
	Password    AuthPropType = 2
)

// Defines values for ConfigSettingType.
const (
	Double         ConfigSettingType = 4
	Int            ConfigSettingType = 2
	LimitedValues  ConfigSettingType = 7
	None           ConfigSettingType = 0
	PositiveDouble ConfigSettingType = 6
	PositiveInt    ConfigSettingType = 3
	RiskIndex      ConfigSettingType = 5
	Sql            ConfigSettingType = 1
)

// Defines values for LogOp.
const (
	AND       LogOp = 0
	OR        LogOp = 1
	Undefined LogOp = 2
)

// Defines values for XsrfLoginPostParamsAppId.
const (
	Admin         XsrfLoginPostParamsAppId = "admin"
	App           XsrfLoginPostParamsAppId = "App"
	Opsupport     XsrfLoginPostParamsAppId = "opsupport"
	Passwordreset XsrfLoginPostParamsAppId = "passwordreset"
	Portal        XsrfLoginPostParamsAppId = "portal"
	Register      XsrfLoginPostParamsAppId = "register"
	Scim          XsrfLoginPostParamsAppId = "scim"
)

// AuthConfig defines model for AuthConfig.
type AuthConfig struct {
	AuthProps         *[]AuthPropData `json:"AuthProps,omitempty"`
	Display           *string         `json:"Display,omitempty"`
	ExternalLogoutUrl *string         `json:"ExternalLogoutUrl,omitempty"`
	Name              *string         `json:"Name,omitempty"`
}

// AuthPropData defines model for AuthPropData.
type AuthPropData struct {
	Display     *string      `json:"Display,omitempty"`
	IsMandatory bool         `json:"IsMandatory"`
	Name        *string      `json:"Name,omitempty"`
	Type        AuthPropType `json:"Type"`
}

// AuthPropType defines model for AuthPropType.
type AuthPropType int

// AuthStatus Represents the authentication status of a session.
type AuthStatus struct {
	// AuthValidUntil Returns the expiration date for the current authentication.
	AuthValidUntil *time.Time `json:"AuthValidUntil,omitempty"`

	// Culture Returns the currently active culture for interface strings.
	Culture *string `json:"Culture,omitempty"`

	// CultureFormat Returns the currently active culture for value formatting.
	CultureFormat *string `json:"CultureFormat,omitempty"`

	// ExternalLogoutUrl Returns a URL to use for logging out from an external authentication provider.
	ExternalLogoutUrl *string `json:"ExternalLogoutUrl,omitempty"`

	// PrimaryAuth Returns the primary (database) authentication status.
	PrimaryAuth *PrimaryAuthStatus `json:"PrimaryAuth,omitempty"`

	// SecondaryAuth Returns the authentication status for the second factor.
	SecondaryAuth *SecondaryAuthStatus `json:"SecondaryAuth,omitempty"`
}

// ConfigNodeData defines model for ConfigNodeData.
type ConfigNodeData struct {
	CanAddSetting *bool                `json:"CanAddSetting,omitempty"`
	Children      *[]ConfigNodeData    `json:"Children,omitempty"`
	Description   *string              `json:"Description,omitempty"`
	Key           *string              `json:"Key,omitempty"`
	Name          *string              `json:"Name,omitempty"`
	Settings      *[]ConfigSettingData `json:"Settings,omitempty"`
}

// ConfigSettingData defines model for ConfigSettingData.
type ConfigSettingData struct {
	Description          *string           `json:"Description,omitempty"`
	HasCustomGlobalValue *bool             `json:"HasCustomGlobalValue,omitempty"`
	HasCustomLocalValue  *bool             `json:"HasCustomLocalValue,omitempty"`
	Key                  *string           `json:"Key,omitempty"`
	Name                 *string           `json:"Name,omitempty"`
	OriginalValue        interface{}       `json:"OriginalValue,omitempty"`
	Type                 ConfigSettingType `json:"Type"`
	Value                interface{}       `json:"Value,omitempty"`
}

// ConfigSettingType defines model for ConfigSettingType.
type ConfigSettingType int

// ContributingEntitlement defines model for ContributingEntitlement.
type ContributingEntitlement struct {
	Display *string                    `json:"Display,omitempty"`
	Key     *string                    `json:"Key,omitempty"`
	Sources *[]ContributingEntitlement `json:"Sources,omitempty"`
	Type    *string                    `json:"Type,omitempty"`
}

// ContributingEntitlement2 defines model for ContributingEntitlement2.
type ContributingEntitlement2 struct {
	Display              *string                     `json:"Display,omitempty"`
	ObjectKeyEntitlement *string                     `json:"ObjectKeyEntitlement,omitempty"`
	Sources              *[]ContributingEntitlement2 `json:"Sources,omitempty"`
}

// ExceptionData DTO for exception data.
type ExceptionData struct {
	// Message Gets or sets the exception message.
	Message *string `json:"Message,omitempty"`

	// Number Gets or sets the error number for ViException-typed exceptions.
	Number int32 `json:"Number"`
}

// HeatmapData defines model for HeatmapData.
type HeatmapData struct {
	Children *[]HeatmapData `json:"Children,omitempty"`

	// History Historical values. The values in this array correspond to the dates in the  array.
	History   *[]float64 `json:"History,omitempty"`
	Name      *string    `json:"Name,omitempty"`
	ObjectKey *string    `json:"ObjectKey,omitempty"`
	Value     float64    `json:"Value"`
	ValueZ    float64    `json:"ValueZ"`
}

// LogOp defines model for LogOp.
type LogOp int

// PrimaryAssignmentChange defines model for PrimaryAssignmentChange.
type PrimaryAssignmentChange struct {
	DateUpdated     time.Time `json:"DateUpdated"`
	OldValueDisplay *string   `json:"OldValueDisplay,omitempty"`
	UserUpdated     *string   `json:"UserUpdated,omitempty"`
}

// PrimaryAuthStatus defines model for PrimaryAuthStatus.
type PrimaryAuthStatus struct {
	// AuthTime Returns the time of the authentication.
	AuthTime time.Time `json:"AuthTime"`

	// Display Returns the display name of the authenticated user.
	Display         *string `json:"Display,omitempty"`
	IsAuthenticated bool    `json:"IsAuthenticated"`

	// Uid Returns the unique identifier of the associated identity, if any.
	Uid *string `json:"Uid,omitempty"`
}

// RelatedApplication defines model for RelatedApplication.
type RelatedApplication struct {
	ChildApps   *[]RelatedApplication `json:"ChildApps,omitempty"`
	Description *string               `json:"Description,omitempty"`
	Display     *string               `json:"Display,omitempty"`
	DisplayType *string               `json:"DisplayType,omitempty"`
	Icon        *[]byte               `json:"Icon,omitempty"`
	Url         *string               `json:"Url,omitempty"`
}

// RiskObject defines model for RiskObject.
type RiskObject struct {
	CalculationBase float64       `json:"CalculationBase"`
	Children        *[]RiskObject `json:"Children,omitempty"`
	Description     *string       `json:"Description,omitempty"`
	Display         *string       `json:"Display,omitempty"`
	ObjectKeySource *string       `json:"ObjectKeySource,omitempty"`
	ObjectKeyTarget *string       `json:"ObjectKeyTarget,omitempty"`

	// ObjectKeyTargetLeaf If ObjectKeyTarget points to an assignment table, and if
	// ObjectKeySource is empty, then this property contains the object key of the object referenced by
	// the assignment.
	ObjectKeyTargetLeaf *string `json:"ObjectKeyTargetLeaf,omitempty"`
	ResultValue         float64 `json:"ResultValue"`
	SourceDisplay       *string `json:"SourceDisplay,omitempty"`
	SourceValue         float64 `json:"SourceValue"`
	TargetDisplay       *string `json:"TargetDisplay,omitempty"`
	TypeOfCalculation   *string `json:"TypeOfCalculation,omitempty"`
	UidQerRiskIndex     *string `json:"UidQerRiskIndex,omitempty"`
	ValueNotWeighted    float64 `json:"ValueNotWeighted"`
	Weight              float64 `json:"Weight"`
}

// SecondaryAuthStatus defines model for SecondaryAuthStatus.
type SecondaryAuthStatus struct {
	ErrorMessage *string `json:"ErrorMessage,omitempty"`

	// IsAuthenticated Returns a flag indicating if the second authentication factor has succeeded.
	IsAuthenticated bool `json:"IsAuthenticated"`

	// IsEnabled Returns a flag indicating whether two-factor authentication is enabled.
	// If this value is false, two-factor authentication is not required.
	IsEnabled bool `json:"IsEnabled"`

	// Name Returns the name of the two-factor authentication provider.
	Name *string `json:"Name,omitempty"`
}

// ServiceItemHierarchy defines model for ServiceItemHierarchy.
type ServiceItemHierarchy struct {
	Display       *string                 `json:"Display,omitempty"`
	Mandatory     *[]ServiceItemHierarchy `json:"Mandatory,omitempty"`
	Optional      *[]ServiceItemHierarchy `json:"Optional,omitempty"`
	UidAccProduct *string                 `json:"UidAccProduct,omitempty"`
}

// SessionResponse defines model for SessionResponse.
type SessionResponse struct {
	Config *[]AuthConfig `json:"Config,omitempty"`

	// Status Represents the authentication status of a session.
	Status *AuthStatus `json:"Status,omitempty"`
}

// SourceNode Represents a node in the source detective tree.
type SourceNode struct {
	Children *[]SourceNode `json:"Children,omitempty"`

	// IsPrimaryAssignment Gets or sets a flag indicating whether this is a primary assignment to the employee.
	IsPrimaryAssignment bool `json:"IsPrimaryAssignment"`

	// LastPrimaryAssignmentChange If this a primary assignment; contains information about the most recent change of
	// the primary assignment.
	LastPrimaryAssignmentChange *PrimaryAssignmentChange `json:"LastPrimaryAssignmentChange,omitempty"`

	// ObjectDisplay Display of the source object.
	ObjectDisplay           *string            `json:"ObjectDisplay,omitempty"`
	ObjectDisplayParameters *map[string]string `json:"ObjectDisplayParameters,omitempty"`
	ObjectKey               *string            `json:"ObjectKey,omitempty"`

	// ObjectType Type of the source object.
	ObjectType *string `json:"ObjectType,omitempty"`
}

// SqlExpression Represents an expression tree.
type SqlExpression struct {
	// DisplayValues Contains the display values in case that the value is a foreign-key reference or a set of foreign-key references.
	DisplayValues *[]string `json:"DisplayValues,omitempty"`

	// Expressions Child expressions
	Expressions *[]SqlExpression `json:"Expressions,omitempty"`

	// LogOperator The logical operator between expressions on the same level
	LogOperator LogOp `json:"LogOperator"`

	// Operator Operator which is applied to the value
	Operator   *string `json:"Operator,omitempty"`
	PropertyId *string `json:"PropertyId,omitempty"`

	// Value The value for the expression
	Value interface{} `json:"Value,omitempty"`
}

// XsrfLoginPostJSONBody defines parameters for XsrfLoginPost.
type XsrfLoginPostJSONBody map[string]string

// XsrfLoginPostParams defines parameters for XsrfLoginPost.
type XsrfLoginPostParams struct {
	// Noxsrf Disable XSRF protection for the session
	Noxsrf *bool `form:"noxsrf,omitempty" json:"noxsrf,omitempty"`
}

// XsrfLoginPostParamsAppId defines parameters for XsrfLoginPost.
type XsrfLoginPostParamsAppId string

// XsrfLoginPostJSONRequestBody defines body for XsrfLoginPost for application/json ContentType.
type XsrfLoginPostJSONRequestBody XsrfLoginPostJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// XsrfLoginPostWithBody request with any body
	XsrfLoginPostWithBody(ctx context.Context, appId XsrfLoginPostParamsAppId, params *XsrfLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	XsrfLoginPost(ctx context.Context, appId XsrfLoginPostParamsAppId, params *XsrfLoginPostParams, body XsrfLoginPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) XsrfLoginPostWithBody(ctx context.Context, appId XsrfLoginPostParamsAppId, params *XsrfLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewXsrfLoginPostRequestWithBody(c.Server, appId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) XsrfLoginPost(ctx context.Context, appId XsrfLoginPostParamsAppId, params *XsrfLoginPostParams, body XsrfLoginPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewXsrfLoginPostRequest(c.Server, appId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewXsrfLoginPostRequest calls the generic XsrfLoginPost builder with application/json body
func NewXsrfLoginPostRequest(server string, appId XsrfLoginPostParamsAppId, params *XsrfLoginPostParams, body XsrfLoginPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewXsrfLoginPostRequestWithBody(server, appId, params, "application/json", bodyReader)
}

// NewXsrfLoginPostRequestWithBody generates requests for XsrfLoginPost with any type of body
func NewXsrfLoginPostRequestWithBody(server string, appId XsrfLoginPostParamsAppId, params *XsrfLoginPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/xsrf/login/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Noxsrf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "noxsrf", runtime.ParamLocationQuery, *params.Noxsrf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// XsrfLoginPostWithBodyWithResponse request with any body
	XsrfLoginPostWithBodyWithResponse(ctx context.Context, appId XsrfLoginPostParamsAppId, params *XsrfLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*XsrfLoginPostResponse, error)

	XsrfLoginPostWithResponse(ctx context.Context, appId XsrfLoginPostParamsAppId, params *XsrfLoginPostParams, body XsrfLoginPostJSONRequestBody, reqEditors ...RequestEditorFn) (*XsrfLoginPostResponse, error)
}

type XsrfLoginPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r XsrfLoginPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r XsrfLoginPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// XsrfLoginPostWithBodyWithResponse request with arbitrary body returning *XsrfLoginPostResponse
func (c *ClientWithResponses) XsrfLoginPostWithBodyWithResponse(ctx context.Context, appId XsrfLoginPostParamsAppId, params *XsrfLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*XsrfLoginPostResponse, error) {
	rsp, err := c.XsrfLoginPostWithBody(ctx, appId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseXsrfLoginPostResponse(rsp)
}

func (c *ClientWithResponses) XsrfLoginPostWithResponse(ctx context.Context, appId XsrfLoginPostParamsAppId, params *XsrfLoginPostParams, body XsrfLoginPostJSONRequestBody, reqEditors ...RequestEditorFn) (*XsrfLoginPostResponse, error) {
	rsp, err := c.XsrfLoginPost(ctx, appId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseXsrfLoginPostResponse(rsp)
}

// ParseXsrfLoginPostResponse parses an HTTP response from a XsrfLoginPostWithResponse call
func ParseXsrfLoginPostResponse(rsp *http.Response) (*XsrfLoginPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &XsrfLoginPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
